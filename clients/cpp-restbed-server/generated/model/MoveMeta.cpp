/**
 * PokéAPI
 * All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.18.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "MoveMeta.h"

#include <string>
#include <vector>
#include <map>
#include <sstream>
#include <stdexcept>
#include <regex>
#include <boost/lexical_cast.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/json_parser.hpp>
#include "helpers.h"

using boost::property_tree::ptree;
using boost::property_tree::read_json;
using boost::property_tree::write_json;

namespace org {
namespace openapitools {
namespace server {
namespace model {

MoveMeta::MoveMeta(boost::property_tree::ptree const& pt)
{
        fromPropertyTree(pt);
}


std::string MoveMeta::toJsonString(bool prettyJson /* = false */) const
{
	std::stringstream ss;
	write_json(ss, this->toPropertyTree(), prettyJson);
    // workaround inspired by: https://stackoverflow.com/a/56395440
    std::regex reg("\\\"([0-9]+\\.{0,1}[0-9]*)\\\"");
    std::string result = std::regex_replace(ss.str(), reg, "$1");
    return result;
}

void MoveMeta::fromJsonString(std::string const& jsonString)
{
	std::stringstream ss(jsonString);
	ptree pt;
	read_json(ss,pt);
	this->fromPropertyTree(pt);
}

ptree MoveMeta::toPropertyTree() const
{
	ptree pt;
	ptree tmp_node;
	pt.add_child("ailment", m_Ailment.toPropertyTree());
	pt.add_child("category", m_Category.toPropertyTree());
	pt.put("min_hits", m_Min_hits);
	pt.put("max_hits", m_Max_hits);
	pt.put("min_turns", m_Min_turns);
	pt.put("max_turns", m_Max_turns);
	pt.put("drain", m_Drain);
	pt.put("healing", m_Healing);
	pt.put("crit_rate", m_Crit_rate);
	pt.put("ailment_chance", m_Ailment_chance);
	pt.put("flinch_chance", m_Flinch_chance);
	pt.put("stat_chance", m_Stat_chance);
	return pt;
}

void MoveMeta::fromPropertyTree(ptree const &pt)
{
	ptree tmp_node;
	if (pt.get_child_optional("ailment")) {
        m_Ailment = fromPt<MoveMetaAilmentSummary>(pt.get_child("ailment"));
	}
	if (pt.get_child_optional("category")) {
        m_Category = fromPt<MoveMetaCategorySummary>(pt.get_child("category"));
	}
	m_Min_hits = pt.get("min_hits", 0);
	m_Max_hits = pt.get("max_hits", 0);
	m_Min_turns = pt.get("min_turns", 0);
	m_Max_turns = pt.get("max_turns", 0);
	m_Drain = pt.get("drain", 0);
	m_Healing = pt.get("healing", 0);
	m_Crit_rate = pt.get("crit_rate", 0);
	m_Ailment_chance = pt.get("ailment_chance", 0);
	m_Flinch_chance = pt.get("flinch_chance", 0);
	m_Stat_chance = pt.get("stat_chance", 0);
}

MoveMetaAilmentSummary MoveMeta::getAilment() const
{
    return m_Ailment;
}

void MoveMeta::setAilment(MoveMetaAilmentSummary value)
{
    m_Ailment = value;
}


MoveMetaCategorySummary MoveMeta::getCategory() const
{
    return m_Category;
}

void MoveMeta::setCategory(MoveMetaCategorySummary value)
{
    m_Category = value;
}


int32_t MoveMeta::getMinHits() const
{
    return m_Min_hits;
}

void MoveMeta::setMinHits(int32_t value)
{
    m_Min_hits = value;
}


int32_t MoveMeta::getMaxHits() const
{
    return m_Max_hits;
}

void MoveMeta::setMaxHits(int32_t value)
{
    m_Max_hits = value;
}


int32_t MoveMeta::getMinTurns() const
{
    return m_Min_turns;
}

void MoveMeta::setMinTurns(int32_t value)
{
    m_Min_turns = value;
}


int32_t MoveMeta::getMaxTurns() const
{
    return m_Max_turns;
}

void MoveMeta::setMaxTurns(int32_t value)
{
    m_Max_turns = value;
}


int32_t MoveMeta::getDrain() const
{
    return m_Drain;
}

void MoveMeta::setDrain(int32_t value)
{
    m_Drain = value;
}


int32_t MoveMeta::getHealing() const
{
    return m_Healing;
}

void MoveMeta::setHealing(int32_t value)
{
    m_Healing = value;
}


int32_t MoveMeta::getCritRate() const
{
    return m_Crit_rate;
}

void MoveMeta::setCritRate(int32_t value)
{
    m_Crit_rate = value;
}


int32_t MoveMeta::getAilmentChance() const
{
    return m_Ailment_chance;
}

void MoveMeta::setAilmentChance(int32_t value)
{
    m_Ailment_chance = value;
}


int32_t MoveMeta::getFlinchChance() const
{
    return m_Flinch_chance;
}

void MoveMeta::setFlinchChance(int32_t value)
{
    m_Flinch_chance = value;
}


int32_t MoveMeta::getStatChance() const
{
    return m_Stat_chance;
}

void MoveMeta::setStatChance(int32_t value)
{
    m_Stat_chance = value;
}



std::vector<MoveMeta> createMoveMetaVectorFromJsonString(const std::string& json)
{
    std::stringstream sstream(json);
    boost::property_tree::ptree pt;
    boost::property_tree::json_parser::read_json(sstream,pt);

    auto vec = std::vector<MoveMeta>();
    for (const auto& child: pt) {
        vec.emplace_back(MoveMeta(child.second));
    }

    return vec;
}

}
}
}
}

