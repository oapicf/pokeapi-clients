// tslint:disable
/**
 * PokéAPI
 * All the Pokémon data you\'ll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We\'ve covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    AbilityDetail,
    AbilityDetailFromJSON,
    AbilityDetailToJSON,
    CharacteristicDetail,
    CharacteristicDetailFromJSON,
    CharacteristicDetailToJSON,
    EggGroupDetail,
    EggGroupDetailFromJSON,
    EggGroupDetailToJSON,
    GenderDetail,
    GenderDetailFromJSON,
    GenderDetailToJSON,
    GrowthRateDetail,
    GrowthRateDetailFromJSON,
    GrowthRateDetailToJSON,
    MoveDamageClassDetail,
    MoveDamageClassDetailFromJSON,
    MoveDamageClassDetailToJSON,
    NatureDetail,
    NatureDetailFromJSON,
    NatureDetailToJSON,
    PaginatedAbilitySummaryList,
    PaginatedAbilitySummaryListFromJSON,
    PaginatedAbilitySummaryListToJSON,
    PaginatedCharacteristicSummaryList,
    PaginatedCharacteristicSummaryListFromJSON,
    PaginatedCharacteristicSummaryListToJSON,
    PaginatedEggGroupSummaryList,
    PaginatedEggGroupSummaryListFromJSON,
    PaginatedEggGroupSummaryListToJSON,
    PaginatedGenderSummaryList,
    PaginatedGenderSummaryListFromJSON,
    PaginatedGenderSummaryListToJSON,
    PaginatedGrowthRateSummaryList,
    PaginatedGrowthRateSummaryListFromJSON,
    PaginatedGrowthRateSummaryListToJSON,
    PaginatedMoveDamageClassSummaryList,
    PaginatedMoveDamageClassSummaryListFromJSON,
    PaginatedMoveDamageClassSummaryListToJSON,
    PaginatedNatureSummaryList,
    PaginatedNatureSummaryListFromJSON,
    PaginatedNatureSummaryListToJSON,
    PaginatedPokeathlonStatSummaryList,
    PaginatedPokeathlonStatSummaryListFromJSON,
    PaginatedPokeathlonStatSummaryListToJSON,
    PaginatedPokemonColorSummaryList,
    PaginatedPokemonColorSummaryListFromJSON,
    PaginatedPokemonColorSummaryListToJSON,
    PaginatedPokemonFormSummaryList,
    PaginatedPokemonFormSummaryListFromJSON,
    PaginatedPokemonFormSummaryListToJSON,
    PaginatedPokemonHabitatSummaryList,
    PaginatedPokemonHabitatSummaryListFromJSON,
    PaginatedPokemonHabitatSummaryListToJSON,
    PaginatedPokemonShapeSummaryList,
    PaginatedPokemonShapeSummaryListFromJSON,
    PaginatedPokemonShapeSummaryListToJSON,
    PaginatedPokemonSpeciesSummaryList,
    PaginatedPokemonSpeciesSummaryListFromJSON,
    PaginatedPokemonSpeciesSummaryListToJSON,
    PaginatedPokemonSummaryList,
    PaginatedPokemonSummaryListFromJSON,
    PaginatedPokemonSummaryListToJSON,
    PaginatedStatSummaryList,
    PaginatedStatSummaryListFromJSON,
    PaginatedStatSummaryListToJSON,
    PaginatedTypeSummaryList,
    PaginatedTypeSummaryListFromJSON,
    PaginatedTypeSummaryListToJSON,
    PokeathlonStatDetail,
    PokeathlonStatDetailFromJSON,
    PokeathlonStatDetailToJSON,
    PokemonColorDetail,
    PokemonColorDetailFromJSON,
    PokemonColorDetailToJSON,
    PokemonDetail,
    PokemonDetailFromJSON,
    PokemonDetailToJSON,
    PokemonFormDetail,
    PokemonFormDetailFromJSON,
    PokemonFormDetailToJSON,
    PokemonHabitatDetail,
    PokemonHabitatDetailFromJSON,
    PokemonHabitatDetailToJSON,
    PokemonShapeDetail,
    PokemonShapeDetailFromJSON,
    PokemonShapeDetailToJSON,
    PokemonSpeciesDetail,
    PokemonSpeciesDetailFromJSON,
    PokemonSpeciesDetailToJSON,
    StatDetail,
    StatDetailFromJSON,
    StatDetailToJSON,
    TypeDetail,
    TypeDetailFromJSON,
    TypeDetailToJSON,
} from '../models';

export interface AbilityListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface AbilityRetrieveRequest {
    id: string;
}

export interface CharacteristicListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface CharacteristicRetrieveRequest {
    id: string;
}

export interface EggGroupListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface EggGroupRetrieveRequest {
    id: string;
}

export interface GenderListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface GenderRetrieveRequest {
    id: string;
}

export interface GrowthRateListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface GrowthRateRetrieveRequest {
    id: string;
}

export interface MoveDamageClassListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveDamageClassRetrieveRequest {
    id: string;
}

export interface NatureListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface NatureRetrieveRequest {
    id: string;
}

export interface PokeathlonStatListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokeathlonStatRetrieveRequest {
    id: string;
}

export interface PokemonColorListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonColorRetrieveRequest {
    id: string;
}

export interface PokemonFormListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonFormRetrieveRequest {
    id: string;
}

export interface PokemonHabitatListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonHabitatRetrieveRequest {
    id: string;
}

export interface PokemonListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonRetrieveRequest {
    id: string;
}

export interface PokemonShapeListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonShapeRetrieveRequest {
    id: string;
}

export interface PokemonSpeciesListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface PokemonSpeciesRetrieveRequest {
    id: string;
}

export interface StatListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface StatRetrieveRequest {
    id: string;
}

export interface TypeListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface TypeRetrieveRequest {
    id: string;
}


/**
 * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
 */
function abilityListRaw<T>(requestParameters: AbilityListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedAbilitySummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/ability/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedAbilitySummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
*/
export function abilityList<T>(requestParameters: AbilityListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedAbilitySummaryList>): QueryConfig<T> {
    return abilityListRaw(requestParameters, requestConfig);
}

/**
 * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
 */
function abilityRetrieveRaw<T>(requestParameters: AbilityRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, AbilityDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling abilityRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/ability/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(AbilityDetailFromJSON(body), text);
    }

    return config;
}

/**
* Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
*/
export function abilityRetrieve<T>(requestParameters: AbilityRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, AbilityDetail>): QueryConfig<T> {
    return abilityRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
 * List charecterictics
 */
function characteristicListRaw<T>(requestParameters: CharacteristicListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedCharacteristicSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/characteristic/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedCharacteristicSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
* List charecterictics
*/
export function characteristicList<T>(requestParameters: CharacteristicListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedCharacteristicSummaryList>): QueryConfig<T> {
    return characteristicListRaw(requestParameters, requestConfig);
}

/**
 * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
 * Get characteristic
 */
function characteristicRetrieveRaw<T>(requestParameters: CharacteristicRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, CharacteristicDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling characteristicRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/characteristic/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(CharacteristicDetailFromJSON(body), text);
    }

    return config;
}

/**
* Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
* Get characteristic
*/
export function characteristicRetrieve<T>(requestParameters: CharacteristicRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, CharacteristicDetail>): QueryConfig<T> {
    return characteristicRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
 * List egg groups
 */
function eggGroupListRaw<T>(requestParameters: EggGroupListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedEggGroupSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/egg-group/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedEggGroupSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
* List egg groups
*/
export function eggGroupList<T>(requestParameters: EggGroupListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedEggGroupSummaryList>): QueryConfig<T> {
    return eggGroupListRaw(requestParameters, requestConfig);
}

/**
 * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
 * Get egg group
 */
function eggGroupRetrieveRaw<T>(requestParameters: EggGroupRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, EggGroupDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling eggGroupRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/egg-group/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(EggGroupDetailFromJSON(body), text);
    }

    return config;
}

/**
* Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
* Get egg group
*/
export function eggGroupRetrieve<T>(requestParameters: EggGroupRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, EggGroupDetail>): QueryConfig<T> {
    return eggGroupRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
 * List genders
 */
function genderListRaw<T>(requestParameters: GenderListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedGenderSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/gender/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedGenderSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
* List genders
*/
export function genderList<T>(requestParameters: GenderListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedGenderSummaryList>): QueryConfig<T> {
    return genderListRaw(requestParameters, requestConfig);
}

/**
 * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
 * Get gender
 */
function genderRetrieveRaw<T>(requestParameters: GenderRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, GenderDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling genderRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/gender/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GenderDetailFromJSON(body), text);
    }

    return config;
}

/**
* Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
* Get gender
*/
export function genderRetrieve<T>(requestParameters: GenderRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, GenderDetail>): QueryConfig<T> {
    return genderRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
 * List growth rates
 */
function growthRateListRaw<T>(requestParameters: GrowthRateListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedGrowthRateSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/growth-rate/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedGrowthRateSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
* List growth rates
*/
export function growthRateList<T>(requestParameters: GrowthRateListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedGrowthRateSummaryList>): QueryConfig<T> {
    return growthRateListRaw(requestParameters, requestConfig);
}

/**
 * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
 * Get growth rate
 */
function growthRateRetrieveRaw<T>(requestParameters: GrowthRateRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, GrowthRateDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling growthRateRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/growth-rate/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(GrowthRateDetailFromJSON(body), text);
    }

    return config;
}

/**
* Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
* Get growth rate
*/
export function growthRateRetrieve<T>(requestParameters: GrowthRateRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, GrowthRateDetail>): QueryConfig<T> {
    return growthRateRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Damage classes moves can have, e.g. physical, special, or non-damaging.
 * List move damage classes
 */
function moveDamageClassListRaw<T>(requestParameters: MoveDamageClassListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedMoveDamageClassSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-damage-class/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedMoveDamageClassSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Damage classes moves can have, e.g. physical, special, or non-damaging.
* List move damage classes
*/
export function moveDamageClassList<T>(requestParameters: MoveDamageClassListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedMoveDamageClassSummaryList>): QueryConfig<T> {
    return moveDamageClassListRaw(requestParameters, requestConfig);
}

/**
 * Damage classes moves can have, e.g. physical, special, or non-damaging.
 * Get move damage class
 */
function moveDamageClassRetrieveRaw<T>(requestParameters: MoveDamageClassRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, MoveDamageClassDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling moveDamageClassRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-damage-class/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MoveDamageClassDetailFromJSON(body), text);
    }

    return config;
}

/**
* Damage classes moves can have, e.g. physical, special, or non-damaging.
* Get move damage class
*/
export function moveDamageClassRetrieve<T>(requestParameters: MoveDamageClassRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, MoveDamageClassDetail>): QueryConfig<T> {
    return moveDamageClassRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
 * List natures
 */
function natureListRaw<T>(requestParameters: NatureListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedNatureSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/nature/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedNatureSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
* List natures
*/
export function natureList<T>(requestParameters: NatureListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedNatureSummaryList>): QueryConfig<T> {
    return natureListRaw(requestParameters, requestConfig);
}

/**
 * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
 * Get nature
 */
function natureRetrieveRaw<T>(requestParameters: NatureRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, NatureDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling natureRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/nature/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(NatureDetailFromJSON(body), text);
    }

    return config;
}

/**
* Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
* Get nature
*/
export function natureRetrieve<T>(requestParameters: NatureRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, NatureDetail>): QueryConfig<T> {
    return natureRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
 * List pokeathlon stats
 */
function pokeathlonStatListRaw<T>(requestParameters: PokeathlonStatListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedPokeathlonStatSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokeathlon-stat/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedPokeathlonStatSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
* List pokeathlon stats
*/
export function pokeathlonStatList<T>(requestParameters: PokeathlonStatListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedPokeathlonStatSummaryList>): QueryConfig<T> {
    return pokeathlonStatListRaw(requestParameters, requestConfig);
}

/**
 * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
 * Get pokeathlon stat
 */
function pokeathlonStatRetrieveRaw<T>(requestParameters: PokeathlonStatRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, PokeathlonStatDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pokeathlonStatRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokeathlon-stat/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PokeathlonStatDetailFromJSON(body), text);
    }

    return config;
}

/**
* Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
* Get pokeathlon stat
*/
export function pokeathlonStatRetrieve<T>(requestParameters: PokeathlonStatRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, PokeathlonStatDetail>): QueryConfig<T> {
    return pokeathlonStatRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
 * List pokemon colors
 */
function pokemonColorListRaw<T>(requestParameters: PokemonColorListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedPokemonColorSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-color/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedPokemonColorSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
* List pokemon colors
*/
export function pokemonColorList<T>(requestParameters: PokemonColorListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedPokemonColorSummaryList>): QueryConfig<T> {
    return pokemonColorListRaw(requestParameters, requestConfig);
}

/**
 * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
 * Get pokemon color
 */
function pokemonColorRetrieveRaw<T>(requestParameters: PokemonColorRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, PokemonColorDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pokemonColorRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-color/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PokemonColorDetailFromJSON(body), text);
    }

    return config;
}

/**
* Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
* Get pokemon color
*/
export function pokemonColorRetrieve<T>(requestParameters: PokemonColorRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, PokemonColorDetail>): QueryConfig<T> {
    return pokemonColorRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
 * List pokemon forms
 */
function pokemonFormListRaw<T>(requestParameters: PokemonFormListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedPokemonFormSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-form/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedPokemonFormSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
* List pokemon forms
*/
export function pokemonFormList<T>(requestParameters: PokemonFormListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedPokemonFormSummaryList>): QueryConfig<T> {
    return pokemonFormListRaw(requestParameters, requestConfig);
}

/**
 * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
 * Get pokemon form
 */
function pokemonFormRetrieveRaw<T>(requestParameters: PokemonFormRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, PokemonFormDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pokemonFormRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-form/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PokemonFormDetailFromJSON(body), text);
    }

    return config;
}

/**
* Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
* Get pokemon form
*/
export function pokemonFormRetrieve<T>(requestParameters: PokemonFormRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, PokemonFormDetail>): QueryConfig<T> {
    return pokemonFormRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
 * List pokemom habitas
 */
function pokemonHabitatListRaw<T>(requestParameters: PokemonHabitatListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedPokemonHabitatSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-habitat/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedPokemonHabitatSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
* List pokemom habitas
*/
export function pokemonHabitatList<T>(requestParameters: PokemonHabitatListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedPokemonHabitatSummaryList>): QueryConfig<T> {
    return pokemonHabitatListRaw(requestParameters, requestConfig);
}

/**
 * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
 * Get pokemom habita
 */
function pokemonHabitatRetrieveRaw<T>(requestParameters: PokemonHabitatRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, PokemonHabitatDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pokemonHabitatRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-habitat/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PokemonHabitatDetailFromJSON(body), text);
    }

    return config;
}

/**
* Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
* Get pokemom habita
*/
export function pokemonHabitatRetrieve<T>(requestParameters: PokemonHabitatRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, PokemonHabitatDetail>): QueryConfig<T> {
    return pokemonHabitatRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
 * List pokemon
 */
function pokemonListRaw<T>(requestParameters: PokemonListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedPokemonSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedPokemonSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
* List pokemon
*/
export function pokemonList<T>(requestParameters: PokemonListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedPokemonSummaryList>): QueryConfig<T> {
    return pokemonListRaw(requestParameters, requestConfig);
}

/**
 * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
 * Get pokemon
 */
function pokemonRetrieveRaw<T>(requestParameters: PokemonRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, PokemonDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pokemonRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PokemonDetailFromJSON(body), text);
    }

    return config;
}

/**
* Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
* Get pokemon
*/
export function pokemonRetrieve<T>(requestParameters: PokemonRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, PokemonDetail>): QueryConfig<T> {
    return pokemonRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Shapes used for sorting Pokémon in a Pokédex.
 * List pokemon shapes
 */
function pokemonShapeListRaw<T>(requestParameters: PokemonShapeListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedPokemonShapeSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-shape/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedPokemonShapeSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Shapes used for sorting Pokémon in a Pokédex.
* List pokemon shapes
*/
export function pokemonShapeList<T>(requestParameters: PokemonShapeListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedPokemonShapeSummaryList>): QueryConfig<T> {
    return pokemonShapeListRaw(requestParameters, requestConfig);
}

/**
 * Shapes used for sorting Pokémon in a Pokédex.
 * Get pokemon shape
 */
function pokemonShapeRetrieveRaw<T>(requestParameters: PokemonShapeRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, PokemonShapeDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pokemonShapeRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-shape/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PokemonShapeDetailFromJSON(body), text);
    }

    return config;
}

/**
* Shapes used for sorting Pokémon in a Pokédex.
* Get pokemon shape
*/
export function pokemonShapeRetrieve<T>(requestParameters: PokemonShapeRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, PokemonShapeDetail>): QueryConfig<T> {
    return pokemonShapeRetrieveRaw(requestParameters, requestConfig);
}

/**
 * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
 * List pokemon species
 */
function pokemonSpeciesListRaw<T>(requestParameters: PokemonSpeciesListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedPokemonSpeciesSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-species/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedPokemonSpeciesSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
* List pokemon species
*/
export function pokemonSpeciesList<T>(requestParameters: PokemonSpeciesListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedPokemonSpeciesSummaryList>): QueryConfig<T> {
    return pokemonSpeciesListRaw(requestParameters, requestConfig);
}

/**
 * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
 * Get pokemon species
 */
function pokemonSpeciesRetrieveRaw<T>(requestParameters: PokemonSpeciesRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, PokemonSpeciesDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling pokemonSpeciesRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/pokemon-species/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PokemonSpeciesDetailFromJSON(body), text);
    }

    return config;
}

/**
* A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
* Get pokemon species
*/
export function pokemonSpeciesRetrieve<T>(requestParameters: PokemonSpeciesRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, PokemonSpeciesDetail>): QueryConfig<T> {
    return pokemonSpeciesRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
 * List stats
 */
function statListRaw<T>(requestParameters: StatListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedStatSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/stat/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedStatSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
* List stats
*/
export function statList<T>(requestParameters: StatListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedStatSummaryList>): QueryConfig<T> {
    return statListRaw(requestParameters, requestConfig);
}

/**
 * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
 * Get stat
 */
function statRetrieveRaw<T>(requestParameters: StatRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, StatDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling statRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/stat/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(StatDetailFromJSON(body), text);
    }

    return config;
}

/**
* Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
* Get stat
*/
export function statRetrieve<T>(requestParameters: StatRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, StatDetail>): QueryConfig<T> {
    return statRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
 * List types
 */
function typeListRaw<T>(requestParameters: TypeListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedTypeSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/type/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedTypeSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
* List types
*/
export function typeList<T>(requestParameters: TypeListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedTypeSummaryList>): QueryConfig<T> {
    return typeListRaw(requestParameters, requestConfig);
}

/**
 * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
 * Get types
 */
function typeRetrieveRaw<T>(requestParameters: TypeRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, TypeDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling typeRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/type/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(TypeDetailFromJSON(body), text);
    }

    return config;
}

/**
* Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
* Get types
*/
export function typeRetrieve<T>(requestParameters: TypeRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, TypeDetail>): QueryConfig<T> {
    return typeRetrieveRaw(requestParameters, requestConfig);
}

