// tslint:disable
/**
 * PokéAPI
 * All the Pokémon data you\'ll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We\'ve covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { HttpMethods, QueryConfig, ResponseBody, ResponseText } from 'redux-query';
import * as runtime from '../runtime';
import {
    MoveBattleStyleDetail,
    MoveBattleStyleDetailFromJSON,
    MoveBattleStyleDetailToJSON,
    MoveDetail,
    MoveDetailFromJSON,
    MoveDetailToJSON,
    MoveLearnMethodDetail,
    MoveLearnMethodDetailFromJSON,
    MoveLearnMethodDetailToJSON,
    MoveMetaAilmentDetail,
    MoveMetaAilmentDetailFromJSON,
    MoveMetaAilmentDetailToJSON,
    MoveMetaCategoryDetail,
    MoveMetaCategoryDetailFromJSON,
    MoveMetaCategoryDetailToJSON,
    MoveTargetDetail,
    MoveTargetDetailFromJSON,
    MoveTargetDetailToJSON,
    PaginatedMoveBattleStyleSummaryList,
    PaginatedMoveBattleStyleSummaryListFromJSON,
    PaginatedMoveBattleStyleSummaryListToJSON,
    PaginatedMoveLearnMethodSummaryList,
    PaginatedMoveLearnMethodSummaryListFromJSON,
    PaginatedMoveLearnMethodSummaryListToJSON,
    PaginatedMoveMetaAilmentSummaryList,
    PaginatedMoveMetaAilmentSummaryListFromJSON,
    PaginatedMoveMetaAilmentSummaryListToJSON,
    PaginatedMoveMetaCategorySummaryList,
    PaginatedMoveMetaCategorySummaryListFromJSON,
    PaginatedMoveMetaCategorySummaryListToJSON,
    PaginatedMoveSummaryList,
    PaginatedMoveSummaryListFromJSON,
    PaginatedMoveSummaryListToJSON,
    PaginatedMoveTargetSummaryList,
    PaginatedMoveTargetSummaryListFromJSON,
    PaginatedMoveTargetSummaryListToJSON,
} from '../models';

export interface MoveAilmentListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveAilmentRetrieveRequest {
    id: string;
}

export interface MoveBattleStyleListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveBattleStyleRetrieveRequest {
    id: string;
}

export interface MoveCategoryListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveCategoryRetrieveRequest {
    id: string;
}

export interface MoveLearnMethodListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveLearnMethodRetrieveRequest {
    id: string;
}

export interface MoveListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveRetrieveRequest {
    id: string;
}

export interface MoveTargetListRequest {
    limit?: number;
    offset?: number;
    q?: string;
}

export interface MoveTargetRetrieveRequest {
    id: string;
}


/**
 * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
 * List move meta ailments
 */
function moveAilmentListRaw<T>(requestParameters: MoveAilmentListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedMoveMetaAilmentSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-ailment/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedMoveMetaAilmentSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
* List move meta ailments
*/
export function moveAilmentList<T>(requestParameters: MoveAilmentListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedMoveMetaAilmentSummaryList>): QueryConfig<T> {
    return moveAilmentListRaw(requestParameters, requestConfig);
}

/**
 * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
 * Get move meta ailment
 */
function moveAilmentRetrieveRaw<T>(requestParameters: MoveAilmentRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, MoveMetaAilmentDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling moveAilmentRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-ailment/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MoveMetaAilmentDetailFromJSON(body), text);
    }

    return config;
}

/**
* Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
* Get move meta ailment
*/
export function moveAilmentRetrieve<T>(requestParameters: MoveAilmentRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, MoveMetaAilmentDetail>): QueryConfig<T> {
    return moveAilmentRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
 * List move battle styles
 */
function moveBattleStyleListRaw<T>(requestParameters: MoveBattleStyleListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedMoveBattleStyleSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-battle-style/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedMoveBattleStyleSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
* List move battle styles
*/
export function moveBattleStyleList<T>(requestParameters: MoveBattleStyleListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedMoveBattleStyleSummaryList>): QueryConfig<T> {
    return moveBattleStyleListRaw(requestParameters, requestConfig);
}

/**
 * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
 * Get move battle style
 */
function moveBattleStyleRetrieveRaw<T>(requestParameters: MoveBattleStyleRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, MoveBattleStyleDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling moveBattleStyleRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-battle-style/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MoveBattleStyleDetailFromJSON(body), text);
    }

    return config;
}

/**
* Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
* Get move battle style
*/
export function moveBattleStyleRetrieve<T>(requestParameters: MoveBattleStyleRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, MoveBattleStyleDetail>): QueryConfig<T> {
    return moveBattleStyleRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Very general categories that loosely group move effects.
 * List move meta categories
 */
function moveCategoryListRaw<T>(requestParameters: MoveCategoryListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedMoveMetaCategorySummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-category/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedMoveMetaCategorySummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Very general categories that loosely group move effects.
* List move meta categories
*/
export function moveCategoryList<T>(requestParameters: MoveCategoryListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedMoveMetaCategorySummaryList>): QueryConfig<T> {
    return moveCategoryListRaw(requestParameters, requestConfig);
}

/**
 * Very general categories that loosely group move effects.
 * Get move meta category
 */
function moveCategoryRetrieveRaw<T>(requestParameters: MoveCategoryRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, MoveMetaCategoryDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling moveCategoryRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-category/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MoveMetaCategoryDetailFromJSON(body), text);
    }

    return config;
}

/**
* Very general categories that loosely group move effects.
* Get move meta category
*/
export function moveCategoryRetrieve<T>(requestParameters: MoveCategoryRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, MoveMetaCategoryDetail>): QueryConfig<T> {
    return moveCategoryRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Methods by which Pokémon can learn moves.
 * List move learn methods
 */
function moveLearnMethodListRaw<T>(requestParameters: MoveLearnMethodListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedMoveLearnMethodSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-learn-method/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedMoveLearnMethodSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Methods by which Pokémon can learn moves.
* List move learn methods
*/
export function moveLearnMethodList<T>(requestParameters: MoveLearnMethodListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedMoveLearnMethodSummaryList>): QueryConfig<T> {
    return moveLearnMethodListRaw(requestParameters, requestConfig);
}

/**
 * Methods by which Pokémon can learn moves.
 * Get move learn method
 */
function moveLearnMethodRetrieveRaw<T>(requestParameters: MoveLearnMethodRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, MoveLearnMethodDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling moveLearnMethodRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-learn-method/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MoveLearnMethodDetailFromJSON(body), text);
    }

    return config;
}

/**
* Methods by which Pokémon can learn moves.
* Get move learn method
*/
export function moveLearnMethodRetrieve<T>(requestParameters: MoveLearnMethodRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, MoveLearnMethodDetail>): QueryConfig<T> {
    return moveLearnMethodRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
 * List moves
 */
function moveListRaw<T>(requestParameters: MoveListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedMoveSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedMoveSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
* List moves
*/
export function moveList<T>(requestParameters: MoveListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedMoveSummaryList>): QueryConfig<T> {
    return moveListRaw(requestParameters, requestConfig);
}

/**
 * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
 * Get move
 */
function moveRetrieveRaw<T>(requestParameters: MoveRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, MoveDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling moveRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MoveDetailFromJSON(body), text);
    }

    return config;
}

/**
* Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
* Get move
*/
export function moveRetrieve<T>(requestParameters: MoveRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, MoveDetail>): QueryConfig<T> {
    return moveRetrieveRaw(requestParameters, requestConfig);
}

/**
 * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
 * List move targets
 */
function moveTargetListRaw<T>(requestParameters: MoveTargetListRequest, requestConfig: runtime.TypedQueryConfig<T, PaginatedMoveTargetSummaryList> = {}): QueryConfig<T> {
    let queryParameters = null;

    queryParameters = {};


    if (requestParameters.limit !== undefined) {
        queryParameters['limit'] = requestParameters.limit;
    }


    if (requestParameters.offset !== undefined) {
        queryParameters['offset'] = requestParameters.offset;
    }


    if (requestParameters.q !== undefined) {
        queryParameters['q'] = requestParameters.q;
    }

    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-target/`,
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(PaginatedMoveTargetSummaryListFromJSON(body), text);
    }

    return config;
}

/**
* Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
* List move targets
*/
export function moveTargetList<T>(requestParameters: MoveTargetListRequest, requestConfig?: runtime.TypedQueryConfig<T, PaginatedMoveTargetSummaryList>): QueryConfig<T> {
    return moveTargetListRaw(requestParameters, requestConfig);
}

/**
 * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
 * Get move target
 */
function moveTargetRetrieveRaw<T>(requestParameters: MoveTargetRetrieveRequest, requestConfig: runtime.TypedQueryConfig<T, MoveTargetDetail> = {}): QueryConfig<T> {
    if (requestParameters.id === null || requestParameters.id === undefined) {
        throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling moveTargetRetrieve.');
    }

    let queryParameters = null;


    const headerParameters : runtime.HttpHeaders = {};


    const { meta = {} } = requestConfig;

    meta.authType = ['basic'];
    const config: QueryConfig<T> = {
        url: `${runtime.Configuration.basePath}/api/v2/move-target/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
        meta,
        update: requestConfig.update,
        queryKey: requestConfig.queryKey,
        optimisticUpdate: requestConfig.optimisticUpdate,
        force: requestConfig.force,
        rollback: requestConfig.rollback,
        options: {
            method: 'GET',
            headers: headerParameters,
        },
        body: queryParameters,
    };

    const { transform: requestTransform } = requestConfig;
    if (requestTransform) {
        config.transform = (body: ResponseBody, text: ResponseBody) => requestTransform(MoveTargetDetailFromJSON(body), text);
    }

    return config;
}

/**
* Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
* Get move target
*/
export function moveTargetRetrieve<T>(requestParameters: MoveTargetRetrieveRequest, requestConfig?: runtime.TypedQueryConfig<T, MoveTargetDetail>): QueryConfig<T> {
    return moveTargetRetrieveRaw(requestParameters, requestConfig);
}

