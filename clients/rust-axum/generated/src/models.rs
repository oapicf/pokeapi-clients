#![allow(unused_qualifications)]

use http::HeaderValue;
use validator::Validate;

#[cfg(feature = "server")]
use crate::header;
use crate::{models, types::*};

#[allow(dead_code)]
fn from_validation_error(e: validator::ValidationError) -> validator::ValidationErrors {
  let mut errs = validator::ValidationErrors::new();
  errs.add("na", e);
  errs
}

#[allow(dead_code)]
pub fn check_xss_string(v: &str) -> std::result::Result<(), validator::ValidationError> {
    if ammonia::is_html(v) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}

#[allow(dead_code)]
pub fn check_xss_vec_string(v: &[String]) -> std::result::Result<(), validator::ValidationError> {
    if v.iter().any(|i| ammonia::is_html(i)) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}

#[allow(dead_code)]
pub fn check_xss_map_string(
    v: &std::collections::HashMap<String, String>,
) -> std::result::Result<(), validator::ValidationError> {
    if v.keys().any(|k| ammonia::is_html(k)) || v.values().any(|v| ammonia::is_html(v)) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}

#[allow(dead_code)]
pub fn check_xss_map_nested<T>(
    v: &std::collections::HashMap<String, T>,
) -> std::result::Result<(), validator::ValidationError>
where
    T: validator::Validate,
{
    if v.keys().any(|k| ammonia::is_html(k)) || v.values().any(|v| v.validate().is_err()) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}

#[allow(dead_code)]
pub fn check_xss_map<T>(v: &std::collections::HashMap<String, T>) -> std::result::Result<(), validator::ValidationError> {
    if v.keys().any(|k| ammonia::is_html(k)) {
        std::result::Result::Err(validator::ValidationError::new("xss detected"))
    } else {
        std::result::Result::Ok(())
    }
}


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct BerryFirmnessListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct BerryFirmnessRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct BerryFlavorListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct BerryFlavorRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct BerryListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct BerryRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContestEffectListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContestEffectRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContestTypeListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ContestTypeRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SuperContestEffectListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct SuperContestEffectRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EncounterConditionListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EncounterConditionRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EncounterConditionValueListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EncounterConditionValueRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EncounterMethodListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EncounterMethodRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonEncountersRetrievePathParams {
                #[validate(
                          regex(path = *RE_POKEMONENCOUNTERSRETRIEVEPATHPARAMS_POKEMON_ID),
            )]
                pub pokemon_id: String,
    }

    lazy_static::lazy_static! {
        static ref RE_POKEMONENCOUNTERSRETRIEVEPATHPARAMS_POKEMON_ID: regex::Regex = regex::Regex::new("^\\d+$").unwrap();
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EvolutionChainListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EvolutionChainRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EvolutionTriggerListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EvolutionTriggerRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GenerationListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GenerationRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokedexListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokedexRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VersionGroupListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VersionGroupRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VersionListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct VersionRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemAttributeListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemAttributeRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemCategoryListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemCategoryRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemFlingEffectListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemFlingEffectRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemPocketListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemPocketRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct ItemRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct LocationAreaListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct LocationAreaRetrievePathParams {
            /// A unique integer value identifying this location area.
                pub id: i32,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct LocationListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct LocationRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PalParkAreaListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PalParkAreaRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RegionListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct RegionRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MachineListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MachineRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveAilmentListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveAilmentRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveBattleStyleListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveBattleStyleRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveCategoryListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveCategoryRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveLearnMethodListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveLearnMethodRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveTargetListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveTargetRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct AbilityListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct AbilityRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CharacteristicListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct CharacteristicRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EggGroupListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct EggGroupRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GenderListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GenderRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GrowthRateListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct GrowthRateRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveDamageClassListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct MoveDamageClassRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NatureListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct NatureRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokeathlonStatListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokeathlonStatRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonColorListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonColorRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonFormListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonFormRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonHabitatListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonHabitatRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonShapeListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonShapeRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonSpeciesListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct PokemonSpeciesRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct StatListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct StatRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct TypeListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct TypeRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }



    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct LanguageListQueryParams {
            /// Number of results to return per page.
                #[serde(rename = "limit")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub limit: Option<i32>,
            /// The initial index from which to return the results.
                #[serde(rename = "offset")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub offset: Option<i32>,
            /// > Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the `name` property. 
                #[serde(rename = "q")]
                    #[serde(skip_serializing_if="Option::is_none")]
                    pub q: Option<String>,
    }


    #[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
    #[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
    pub struct LanguageRetrievePathParams {
            /// This parameter can be a string or an integer.
                pub id: String,
    }




#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilityChange {
    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::VersionGroupSummary,

    #[serde(rename = "effect_entries")]
          #[validate(nested)]
    pub effect_entries: Vec<models::AbilityChangeEffectText>,

}



impl AbilityChange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(version_group: models::VersionGroupSummary, effect_entries: Vec<models::AbilityChangeEffectText>, ) -> AbilityChange {
        AbilityChange {
 version_group,
 effect_entries,
        }
    }
}

/// Converts the AbilityChange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilityChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping version_group in query parameter serialization

            // Skipping effect_entries in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilityChange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilityChange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version_group: Vec<models::VersionGroupSummary>,
            pub effect_entries: Vec<Vec<models::AbilityChangeEffectText>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilityChange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::VersionGroupSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "effect_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in AbilityChange".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilityChange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilityChange {
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in AbilityChange".to_string())?,
            effect_entries: intermediate_rep.effect_entries.into_iter().next().ok_or_else(|| "effect_entries missing in AbilityChange".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilityChange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilityChange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilityChange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilityChange - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilityChange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilityChange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilityChange - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilityChangeEffectText {
    #[serde(rename = "effect")]
    #[validate(
            length(max = 6000),
          custom(function = "check_xss_string"),
    )]
    pub effect: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl AbilityChangeEffectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect: String, language: models::LanguageSummary, ) -> AbilityChangeEffectText {
        AbilityChangeEffectText {
 effect,
 language,
        }
    }
}

/// Converts the AbilityChangeEffectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilityChangeEffectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("effect".to_string()),
            Some(self.effect.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilityChangeEffectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilityChangeEffectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilityChangeEffectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "effect" => intermediate_rep.effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilityChangeEffectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilityChangeEffectText {
            effect: intermediate_rep.effect.into_iter().next().ok_or_else(|| "effect missing in AbilityChangeEffectText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in AbilityChangeEffectText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilityChangeEffectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilityChangeEffectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilityChangeEffectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilityChangeEffectText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilityChangeEffectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilityChangeEffectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilityChangeEffectText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilityDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "is_main_series")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_main_series: Option<bool>,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::GenerationSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::AbilityName>,

    #[serde(rename = "effect_entries")]
          #[validate(nested)]
    pub effect_entries: Vec<models::AbilityEffectText>,

    #[serde(rename = "effect_changes")]
          #[validate(nested)]
    pub effect_changes: Vec<models::AbilityChange>,

    #[serde(rename = "flavor_text_entries")]
          #[validate(nested)]
    pub flavor_text_entries: Vec<models::AbilityFlavorText>,

    #[serde(rename = "pokemon")]
          #[validate(nested)]
    pub pokemon: Vec<models::AbilityDetailPokemonInner>,

}



impl AbilityDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, generation: models::GenerationSummary, names: Vec<models::AbilityName>, effect_entries: Vec<models::AbilityEffectText>, effect_changes: Vec<models::AbilityChange>, flavor_text_entries: Vec<models::AbilityFlavorText>, pokemon: Vec<models::AbilityDetailPokemonInner>, ) -> AbilityDetail {
        AbilityDetail {
 id,
 name,
 is_main_series: None,
 generation,
 names,
 effect_entries,
 effect_changes,
 flavor_text_entries,
 pokemon,
        }
    }
}

/// Converts the AbilityDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilityDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.is_main_series.as_ref().map(|is_main_series| {
                [
                    "is_main_series".to_string(),
                    is_main_series.to_string(),
                ].join(",")
            }),

            // Skipping generation in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping effect_entries in query parameter serialization

            // Skipping effect_changes in query parameter serialization

            // Skipping flavor_text_entries in query parameter serialization

            // Skipping pokemon in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilityDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilityDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub is_main_series: Vec<bool>,
            pub generation: Vec<models::GenerationSummary>,
            pub names: Vec<Vec<models::AbilityName>>,
            pub effect_entries: Vec<Vec<models::AbilityEffectText>>,
            pub effect_changes: Vec<Vec<models::AbilityChange>>,
            pub flavor_text_entries: Vec<Vec<models::AbilityFlavorText>>,
            pub pokemon: Vec<Vec<models::AbilityDetailPokemonInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilityDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_main_series" => intermediate_rep.is_main_series.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in AbilityDetail".to_string()),
                    "effect_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in AbilityDetail".to_string()),
                    "effect_changes" => return std::result::Result::Err("Parsing a container in this style is not supported in AbilityDetail".to_string()),
                    "flavor_text_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in AbilityDetail".to_string()),
                    "pokemon" => return std::result::Result::Err("Parsing a container in this style is not supported in AbilityDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilityDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilityDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in AbilityDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AbilityDetail".to_string())?,
            is_main_series: intermediate_rep.is_main_series.into_iter().next(),
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in AbilityDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in AbilityDetail".to_string())?,
            effect_entries: intermediate_rep.effect_entries.into_iter().next().ok_or_else(|| "effect_entries missing in AbilityDetail".to_string())?,
            effect_changes: intermediate_rep.effect_changes.into_iter().next().ok_or_else(|| "effect_changes missing in AbilityDetail".to_string())?,
            flavor_text_entries: intermediate_rep.flavor_text_entries.into_iter().next().ok_or_else(|| "flavor_text_entries missing in AbilityDetail".to_string())?,
            pokemon: intermediate_rep.pokemon.into_iter().next().ok_or_else(|| "pokemon missing in AbilityDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilityDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilityDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilityDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilityDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilityDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilityDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilityDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilityDetailPokemonInner {
    #[serde(rename = "is_hidden")]
    pub is_hidden: bool,

    #[serde(rename = "slot")]
    pub slot: i32,

    #[serde(rename = "pokemon")]
          #[validate(nested)]
    pub pokemon: models::AbilityDetailPokemonInnerPokemon,

}



impl AbilityDetailPokemonInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(is_hidden: bool, slot: i32, pokemon: models::AbilityDetailPokemonInnerPokemon, ) -> AbilityDetailPokemonInner {
        AbilityDetailPokemonInner {
 is_hidden,
 slot,
 pokemon,
        }
    }
}

/// Converts the AbilityDetailPokemonInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilityDetailPokemonInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("is_hidden".to_string()),
            Some(self.is_hidden.to_string()),


            Some("slot".to_string()),
            Some(self.slot.to_string()),

            // Skipping pokemon in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilityDetailPokemonInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilityDetailPokemonInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub is_hidden: Vec<bool>,
            pub slot: Vec<i32>,
            pub pokemon: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilityDetailPokemonInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "is_hidden" => intermediate_rep.is_hidden.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "slot" => intermediate_rep.slot.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokemon" => intermediate_rep.pokemon.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilityDetailPokemonInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilityDetailPokemonInner {
            is_hidden: intermediate_rep.is_hidden.into_iter().next().ok_or_else(|| "is_hidden missing in AbilityDetailPokemonInner".to_string())?,
            slot: intermediate_rep.slot.into_iter().next().ok_or_else(|| "slot missing in AbilityDetailPokemonInner".to_string())?,
            pokemon: intermediate_rep.pokemon.into_iter().next().ok_or_else(|| "pokemon missing in AbilityDetailPokemonInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilityDetailPokemonInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilityDetailPokemonInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilityDetailPokemonInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilityDetailPokemonInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilityDetailPokemonInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilityDetailPokemonInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilityDetailPokemonInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilityDetailPokemonInnerPokemon {
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl AbilityDetailPokemonInnerPokemon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> AbilityDetailPokemonInnerPokemon {
        AbilityDetailPokemonInnerPokemon {
 name,
 url,
        }
    }
}

/// Converts the AbilityDetailPokemonInnerPokemon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilityDetailPokemonInnerPokemon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilityDetailPokemonInnerPokemon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilityDetailPokemonInnerPokemon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilityDetailPokemonInnerPokemon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilityDetailPokemonInnerPokemon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilityDetailPokemonInnerPokemon {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AbilityDetailPokemonInnerPokemon".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in AbilityDetailPokemonInnerPokemon".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilityDetailPokemonInnerPokemon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilityDetailPokemonInnerPokemon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilityDetailPokemonInnerPokemon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilityDetailPokemonInnerPokemon - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilityDetailPokemonInnerPokemon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilityDetailPokemonInnerPokemon - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilityEffectText {
    #[serde(rename = "effect")]
    #[validate(
            length(max = 6000),
          custom(function = "check_xss_string"),
    )]
    pub effect: String,

    #[serde(rename = "short_effect")]
    #[validate(
            length(max = 300),
          custom(function = "check_xss_string"),
    )]
    pub short_effect: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl AbilityEffectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect: String, short_effect: String, language: models::LanguageSummary, ) -> AbilityEffectText {
        AbilityEffectText {
 effect,
 short_effect,
 language,
        }
    }
}

/// Converts the AbilityEffectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilityEffectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("effect".to_string()),
            Some(self.effect.to_string()),


            Some("short_effect".to_string()),
            Some(self.short_effect.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilityEffectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilityEffectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect: Vec<String>,
            pub short_effect: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilityEffectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "effect" => intermediate_rep.effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "short_effect" => intermediate_rep.short_effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilityEffectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilityEffectText {
            effect: intermediate_rep.effect.into_iter().next().ok_or_else(|| "effect missing in AbilityEffectText".to_string())?,
            short_effect: intermediate_rep.short_effect.into_iter().next().ok_or_else(|| "short_effect missing in AbilityEffectText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in AbilityEffectText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilityEffectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilityEffectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilityEffectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilityEffectText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilityEffectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilityEffectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilityEffectText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilityFlavorText {
    #[serde(rename = "flavor_text")]
          #[validate(custom(function = "check_xss_string"))]
    pub flavor_text: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::VersionGroupSummary,

}



impl AbilityFlavorText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(flavor_text: String, language: models::LanguageSummary, version_group: models::VersionGroupSummary, ) -> AbilityFlavorText {
        AbilityFlavorText {
 flavor_text,
 language,
 version_group,
        }
    }
}

/// Converts the AbilityFlavorText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilityFlavorText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("flavor_text".to_string()),
            Some(self.flavor_text.to_string()),

            // Skipping language in query parameter serialization

            // Skipping version_group in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilityFlavorText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilityFlavorText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub flavor_text: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
            pub version_group: Vec<models::VersionGroupSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilityFlavorText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "flavor_text" => intermediate_rep.flavor_text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::VersionGroupSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilityFlavorText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilityFlavorText {
            flavor_text: intermediate_rep.flavor_text.into_iter().next().ok_or_else(|| "flavor_text missing in AbilityFlavorText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in AbilityFlavorText".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in AbilityFlavorText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilityFlavorText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilityFlavorText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilityFlavorText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilityFlavorText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilityFlavorText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilityFlavorText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilityFlavorText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilityName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl AbilityName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> AbilityName {
        AbilityName {
 name,
 language,
        }
    }
}

/// Converts the AbilityName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilityName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilityName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilityName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilityName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilityName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilityName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AbilityName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in AbilityName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilityName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilityName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilityName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilityName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilityName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilityName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilityName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct AbilitySummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl AbilitySummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> AbilitySummary {
        AbilitySummary {
 name,
 url,
        }
    }
}

/// Converts the AbilitySummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for AbilitySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a AbilitySummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for AbilitySummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing AbilitySummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing AbilitySummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(AbilitySummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in AbilitySummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in AbilitySummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<AbilitySummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<AbilitySummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<AbilitySummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for AbilitySummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<AbilitySummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <AbilitySummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into AbilitySummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "growth_time")]
    pub growth_time: i32,

    #[serde(rename = "max_harvest")]
    pub max_harvest: i32,

    #[serde(rename = "natural_gift_power")]
    pub natural_gift_power: i32,

    #[serde(rename = "size")]
    pub size: i32,

    #[serde(rename = "smoothness")]
    pub smoothness: i32,

    #[serde(rename = "soil_dryness")]
    pub soil_dryness: i32,

    #[serde(rename = "firmness")]
          #[validate(nested)]
    pub firmness: models::BerryFirmnessSummary,

    #[serde(rename = "flavors")]
          #[validate(nested)]
    pub flavors: Vec<models::BerryDetailFlavorsInner>,

    #[serde(rename = "item")]
          #[validate(nested)]
    pub item: models::ItemSummary,

    #[serde(rename = "natural_gift_type")]
          #[validate(nested)]
    pub natural_gift_type: models::TypeSummary,

}



impl BerryDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, growth_time: i32, max_harvest: i32, natural_gift_power: i32, size: i32, smoothness: i32, soil_dryness: i32, firmness: models::BerryFirmnessSummary, flavors: Vec<models::BerryDetailFlavorsInner>, item: models::ItemSummary, natural_gift_type: models::TypeSummary, ) -> BerryDetail {
        BerryDetail {
 id,
 name,
 growth_time,
 max_harvest,
 natural_gift_power,
 size,
 smoothness,
 soil_dryness,
 firmness,
 flavors,
 item,
 natural_gift_type,
        }
    }
}

/// Converts the BerryDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("growth_time".to_string()),
            Some(self.growth_time.to_string()),


            Some("max_harvest".to_string()),
            Some(self.max_harvest.to_string()),


            Some("natural_gift_power".to_string()),
            Some(self.natural_gift_power.to_string()),


            Some("size".to_string()),
            Some(self.size.to_string()),


            Some("smoothness".to_string()),
            Some(self.smoothness.to_string()),


            Some("soil_dryness".to_string()),
            Some(self.soil_dryness.to_string()),

            // Skipping firmness in query parameter serialization

            // Skipping flavors in query parameter serialization

            // Skipping item in query parameter serialization

            // Skipping natural_gift_type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub growth_time: Vec<i32>,
            pub max_harvest: Vec<i32>,
            pub natural_gift_power: Vec<i32>,
            pub size: Vec<i32>,
            pub smoothness: Vec<i32>,
            pub soil_dryness: Vec<i32>,
            pub firmness: Vec<models::BerryFirmnessSummary>,
            pub flavors: Vec<Vec<models::BerryDetailFlavorsInner>>,
            pub item: Vec<models::ItemSummary>,
            pub natural_gift_type: Vec<models::TypeSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "growth_time" => intermediate_rep.growth_time.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_harvest" => intermediate_rep.max_harvest.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "natural_gift_power" => intermediate_rep.natural_gift_power.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "size" => intermediate_rep.size.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "smoothness" => intermediate_rep.smoothness.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "soil_dryness" => intermediate_rep.soil_dryness.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "firmness" => intermediate_rep.firmness.push(<models::BerryFirmnessSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "flavors" => return std::result::Result::Err("Parsing a container in this style is not supported in BerryDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "item" => intermediate_rep.item.push(<models::ItemSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "natural_gift_type" => intermediate_rep.natural_gift_type.push(<models::TypeSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in BerryDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BerryDetail".to_string())?,
            growth_time: intermediate_rep.growth_time.into_iter().next().ok_or_else(|| "growth_time missing in BerryDetail".to_string())?,
            max_harvest: intermediate_rep.max_harvest.into_iter().next().ok_or_else(|| "max_harvest missing in BerryDetail".to_string())?,
            natural_gift_power: intermediate_rep.natural_gift_power.into_iter().next().ok_or_else(|| "natural_gift_power missing in BerryDetail".to_string())?,
            size: intermediate_rep.size.into_iter().next().ok_or_else(|| "size missing in BerryDetail".to_string())?,
            smoothness: intermediate_rep.smoothness.into_iter().next().ok_or_else(|| "smoothness missing in BerryDetail".to_string())?,
            soil_dryness: intermediate_rep.soil_dryness.into_iter().next().ok_or_else(|| "soil_dryness missing in BerryDetail".to_string())?,
            firmness: intermediate_rep.firmness.into_iter().next().ok_or_else(|| "firmness missing in BerryDetail".to_string())?,
            flavors: intermediate_rep.flavors.into_iter().next().ok_or_else(|| "flavors missing in BerryDetail".to_string())?,
            item: intermediate_rep.item.into_iter().next().ok_or_else(|| "item missing in BerryDetail".to_string())?,
            natural_gift_type: intermediate_rep.natural_gift_type.into_iter().next().ok_or_else(|| "natural_gift_type missing in BerryDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryDetailFlavorsInner {
    #[serde(rename = "potency")]
    pub potency: i32,

    #[serde(rename = "flavor")]
          #[validate(nested)]
    pub flavor: models::BerryDetailFlavorsInnerFlavor,

}



impl BerryDetailFlavorsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(potency: i32, flavor: models::BerryDetailFlavorsInnerFlavor, ) -> BerryDetailFlavorsInner {
        BerryDetailFlavorsInner {
 potency,
 flavor,
        }
    }
}

/// Converts the BerryDetailFlavorsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryDetailFlavorsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("potency".to_string()),
            Some(self.potency.to_string()),

            // Skipping flavor in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryDetailFlavorsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryDetailFlavorsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub potency: Vec<i32>,
            pub flavor: Vec<models::BerryDetailFlavorsInnerFlavor>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryDetailFlavorsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "potency" => intermediate_rep.potency.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "flavor" => intermediate_rep.flavor.push(<models::BerryDetailFlavorsInnerFlavor as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryDetailFlavorsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryDetailFlavorsInner {
            potency: intermediate_rep.potency.into_iter().next().ok_or_else(|| "potency missing in BerryDetailFlavorsInner".to_string())?,
            flavor: intermediate_rep.flavor.into_iter().next().ok_or_else(|| "flavor missing in BerryDetailFlavorsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryDetailFlavorsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryDetailFlavorsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryDetailFlavorsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryDetailFlavorsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryDetailFlavorsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryDetailFlavorsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryDetailFlavorsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryDetailFlavorsInnerFlavor {
    /// The name of the flavor
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The URL to get more information about the flavor
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

}



impl BerryDetailFlavorsInnerFlavor {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BerryDetailFlavorsInnerFlavor {
        BerryDetailFlavorsInnerFlavor {
 name: None,
 url: None,
        }
    }
}

/// Converts the BerryDetailFlavorsInnerFlavor value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryDetailFlavorsInnerFlavor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryDetailFlavorsInnerFlavor value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryDetailFlavorsInnerFlavor {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryDetailFlavorsInnerFlavor".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryDetailFlavorsInnerFlavor".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryDetailFlavorsInnerFlavor {
            name: intermediate_rep.name.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryDetailFlavorsInnerFlavor> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryDetailFlavorsInnerFlavor>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryDetailFlavorsInnerFlavor>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryDetailFlavorsInnerFlavor - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryDetailFlavorsInnerFlavor> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryDetailFlavorsInnerFlavor as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryDetailFlavorsInnerFlavor - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryFirmnessDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "berries")]
          #[validate(nested)]
    pub berries: Vec<models::BerrySummary>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::BerryFirmnessName>,

}



impl BerryFirmnessDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, berries: Vec<models::BerrySummary>, names: Vec<models::BerryFirmnessName>, ) -> BerryFirmnessDetail {
        BerryFirmnessDetail {
 id,
 name,
 berries,
 names,
        }
    }
}

/// Converts the BerryFirmnessDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryFirmnessDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping berries in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryFirmnessDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryFirmnessDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub berries: Vec<Vec<models::BerrySummary>>,
            pub names: Vec<Vec<models::BerryFirmnessName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryFirmnessDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "berries" => return std::result::Result::Err("Parsing a container in this style is not supported in BerryFirmnessDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in BerryFirmnessDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryFirmnessDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryFirmnessDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in BerryFirmnessDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BerryFirmnessDetail".to_string())?,
            berries: intermediate_rep.berries.into_iter().next().ok_or_else(|| "berries missing in BerryFirmnessDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in BerryFirmnessDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryFirmnessDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryFirmnessDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryFirmnessDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryFirmnessDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryFirmnessDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryFirmnessDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryFirmnessDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryFirmnessName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl BerryFirmnessName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> BerryFirmnessName {
        BerryFirmnessName {
 name,
 language,
        }
    }
}

/// Converts the BerryFirmnessName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryFirmnessName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryFirmnessName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryFirmnessName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryFirmnessName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryFirmnessName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryFirmnessName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BerryFirmnessName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in BerryFirmnessName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryFirmnessName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryFirmnessName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryFirmnessName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryFirmnessName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryFirmnessName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryFirmnessName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryFirmnessName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryFirmnessSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl BerryFirmnessSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> BerryFirmnessSummary {
        BerryFirmnessSummary {
 name,
 url,
        }
    }
}

/// Converts the BerryFirmnessSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryFirmnessSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryFirmnessSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryFirmnessSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryFirmnessSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryFirmnessSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryFirmnessSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BerryFirmnessSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in BerryFirmnessSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryFirmnessSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryFirmnessSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryFirmnessSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryFirmnessSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryFirmnessSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryFirmnessSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryFirmnessSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryFlavorDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "berries")]
          #[validate(nested)]
    pub berries: Vec<models::BerryFlavorDetailBerriesInner>,

    #[serde(rename = "contest_type")]
          #[validate(nested)]
    pub contest_type: models::ContestTypeSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::BerryFlavorName>,

}



impl BerryFlavorDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, berries: Vec<models::BerryFlavorDetailBerriesInner>, contest_type: models::ContestTypeSummary, names: Vec<models::BerryFlavorName>, ) -> BerryFlavorDetail {
        BerryFlavorDetail {
 id,
 name,
 berries,
 contest_type,
 names,
        }
    }
}

/// Converts the BerryFlavorDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryFlavorDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping berries in query parameter serialization

            // Skipping contest_type in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryFlavorDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryFlavorDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub berries: Vec<Vec<models::BerryFlavorDetailBerriesInner>>,
            pub contest_type: Vec<models::ContestTypeSummary>,
            pub names: Vec<Vec<models::BerryFlavorName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryFlavorDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "berries" => return std::result::Result::Err("Parsing a container in this style is not supported in BerryFlavorDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "contest_type" => intermediate_rep.contest_type.push(<models::ContestTypeSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in BerryFlavorDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryFlavorDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryFlavorDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in BerryFlavorDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BerryFlavorDetail".to_string())?,
            berries: intermediate_rep.berries.into_iter().next().ok_or_else(|| "berries missing in BerryFlavorDetail".to_string())?,
            contest_type: intermediate_rep.contest_type.into_iter().next().ok_or_else(|| "contest_type missing in BerryFlavorDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in BerryFlavorDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryFlavorDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryFlavorDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryFlavorDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryFlavorDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryFlavorDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryFlavorDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryFlavorDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryFlavorDetailBerriesInner {
    #[serde(rename = "potency")]
    pub potency: i32,

    #[serde(rename = "berry")]
          #[validate(nested)]
    pub berry: models::BerryFlavorDetailBerriesInnerBerry,

}



impl BerryFlavorDetailBerriesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(potency: i32, berry: models::BerryFlavorDetailBerriesInnerBerry, ) -> BerryFlavorDetailBerriesInner {
        BerryFlavorDetailBerriesInner {
 potency,
 berry,
        }
    }
}

/// Converts the BerryFlavorDetailBerriesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryFlavorDetailBerriesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("potency".to_string()),
            Some(self.potency.to_string()),

            // Skipping berry in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryFlavorDetailBerriesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryFlavorDetailBerriesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub potency: Vec<i32>,
            pub berry: Vec<models::BerryFlavorDetailBerriesInnerBerry>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryFlavorDetailBerriesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "potency" => intermediate_rep.potency.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "berry" => intermediate_rep.berry.push(<models::BerryFlavorDetailBerriesInnerBerry as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryFlavorDetailBerriesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryFlavorDetailBerriesInner {
            potency: intermediate_rep.potency.into_iter().next().ok_or_else(|| "potency missing in BerryFlavorDetailBerriesInner".to_string())?,
            berry: intermediate_rep.berry.into_iter().next().ok_or_else(|| "berry missing in BerryFlavorDetailBerriesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryFlavorDetailBerriesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryFlavorDetailBerriesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryFlavorDetailBerriesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryFlavorDetailBerriesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryFlavorDetailBerriesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryFlavorDetailBerriesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryFlavorDetailBerriesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryFlavorDetailBerriesInnerBerry {
    /// The name of the berry
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The URL to get more information about the berry
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

}



impl BerryFlavorDetailBerriesInnerBerry {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> BerryFlavorDetailBerriesInnerBerry {
        BerryFlavorDetailBerriesInnerBerry {
 name: None,
 url: None,
        }
    }
}

/// Converts the BerryFlavorDetailBerriesInnerBerry value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryFlavorDetailBerriesInnerBerry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryFlavorDetailBerriesInnerBerry value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryFlavorDetailBerriesInnerBerry {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryFlavorDetailBerriesInnerBerry".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryFlavorDetailBerriesInnerBerry".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryFlavorDetailBerriesInnerBerry {
            name: intermediate_rep.name.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryFlavorDetailBerriesInnerBerry> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryFlavorDetailBerriesInnerBerry>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryFlavorDetailBerriesInnerBerry>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryFlavorDetailBerriesInnerBerry - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryFlavorDetailBerriesInnerBerry> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryFlavorDetailBerriesInnerBerry as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryFlavorDetailBerriesInnerBerry - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryFlavorName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl BerryFlavorName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> BerryFlavorName {
        BerryFlavorName {
 name,
 language,
        }
    }
}

/// Converts the BerryFlavorName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryFlavorName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryFlavorName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryFlavorName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryFlavorName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryFlavorName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryFlavorName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BerryFlavorName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in BerryFlavorName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryFlavorName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryFlavorName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryFlavorName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryFlavorName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryFlavorName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryFlavorName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryFlavorName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerryFlavorSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl BerryFlavorSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> BerryFlavorSummary {
        BerryFlavorSummary {
 name,
 url,
        }
    }
}

/// Converts the BerryFlavorSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerryFlavorSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerryFlavorSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerryFlavorSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerryFlavorSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerryFlavorSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerryFlavorSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BerryFlavorSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in BerryFlavorSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerryFlavorSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerryFlavorSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerryFlavorSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerryFlavorSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerryFlavorSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerryFlavorSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerryFlavorSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct BerrySummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl BerrySummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> BerrySummary {
        BerrySummary {
 name,
 url,
        }
    }
}

/// Converts the BerrySummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for BerrySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a BerrySummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for BerrySummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing BerrySummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing BerrySummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(BerrySummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in BerrySummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in BerrySummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<BerrySummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<BerrySummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<BerrySummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for BerrySummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<BerrySummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <BerrySummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into BerrySummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CharacteristicDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl CharacteristicDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> CharacteristicDescription {
        CharacteristicDescription {
 description: None,
 language,
        }
    }
}

/// Converts the CharacteristicDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CharacteristicDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CharacteristicDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CharacteristicDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CharacteristicDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CharacteristicDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CharacteristicDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in CharacteristicDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CharacteristicDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CharacteristicDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CharacteristicDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CharacteristicDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CharacteristicDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CharacteristicDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CharacteristicDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CharacteristicDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "gene_modulo")]
    pub gene_modulo: i32,

    #[serde(rename = "possible_values")]
    pub possible_values: Vec<i32>,

    #[serde(rename = "highest_stat")]
          #[validate(nested)]
    pub highest_stat: models::StatSummary,

    #[serde(rename = "descriptions")]
          #[validate(nested)]
    pub descriptions: Vec<models::CharacteristicDescription>,

}



impl CharacteristicDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, gene_modulo: i32, possible_values: Vec<i32>, highest_stat: models::StatSummary, descriptions: Vec<models::CharacteristicDescription>, ) -> CharacteristicDetail {
        CharacteristicDetail {
 id,
 gene_modulo,
 possible_values,
 highest_stat,
 descriptions,
        }
    }
}

/// Converts the CharacteristicDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CharacteristicDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("gene_modulo".to_string()),
            Some(self.gene_modulo.to_string()),


            Some("possible_values".to_string()),
            Some(self.possible_values.iter().map(|x| x.to_string()).collect::<Vec<_>>().join(",")),

            // Skipping highest_stat in query parameter serialization

            // Skipping descriptions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CharacteristicDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CharacteristicDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub gene_modulo: Vec<i32>,
            pub possible_values: Vec<Vec<i32>>,
            pub highest_stat: Vec<models::StatSummary>,
            pub descriptions: Vec<Vec<models::CharacteristicDescription>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CharacteristicDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "gene_modulo" => intermediate_rep.gene_modulo.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "possible_values" => return std::result::Result::Err("Parsing a container in this style is not supported in CharacteristicDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "highest_stat" => intermediate_rep.highest_stat.push(<models::StatSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in CharacteristicDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing CharacteristicDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CharacteristicDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in CharacteristicDetail".to_string())?,
            gene_modulo: intermediate_rep.gene_modulo.into_iter().next().ok_or_else(|| "gene_modulo missing in CharacteristicDetail".to_string())?,
            possible_values: intermediate_rep.possible_values.into_iter().next().ok_or_else(|| "possible_values missing in CharacteristicDetail".to_string())?,
            highest_stat: intermediate_rep.highest_stat.into_iter().next().ok_or_else(|| "highest_stat missing in CharacteristicDetail".to_string())?,
            descriptions: intermediate_rep.descriptions.into_iter().next().ok_or_else(|| "descriptions missing in CharacteristicDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CharacteristicDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CharacteristicDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CharacteristicDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CharacteristicDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CharacteristicDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CharacteristicDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CharacteristicDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct CharacteristicSummary {
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl CharacteristicSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> CharacteristicSummary {
        CharacteristicSummary {
 url,
        }
    }
}

/// Converts the CharacteristicSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for CharacteristicSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a CharacteristicSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for CharacteristicSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing CharacteristicSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing CharacteristicSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(CharacteristicSummary {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in CharacteristicSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<CharacteristicSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<CharacteristicSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<CharacteristicSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for CharacteristicSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<CharacteristicSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <CharacteristicSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into CharacteristicSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContestEffectDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "appeal")]
    pub appeal: i32,

    #[serde(rename = "jam")]
    pub jam: i32,

    #[serde(rename = "effect_entries")]
          #[validate(nested)]
    pub effect_entries: Vec<models::ContestEffectEffectText>,

    #[serde(rename = "flavor_text_entries")]
          #[validate(nested)]
    pub flavor_text_entries: Vec<models::ContestEffectFlavorText>,

}



impl ContestEffectDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, appeal: i32, jam: i32, effect_entries: Vec<models::ContestEffectEffectText>, flavor_text_entries: Vec<models::ContestEffectFlavorText>, ) -> ContestEffectDetail {
        ContestEffectDetail {
 id,
 appeal,
 jam,
 effect_entries,
 flavor_text_entries,
        }
    }
}

/// Converts the ContestEffectDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContestEffectDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("appeal".to_string()),
            Some(self.appeal.to_string()),


            Some("jam".to_string()),
            Some(self.jam.to_string()),

            // Skipping effect_entries in query parameter serialization

            // Skipping flavor_text_entries in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContestEffectDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContestEffectDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub appeal: Vec<i32>,
            pub jam: Vec<i32>,
            pub effect_entries: Vec<Vec<models::ContestEffectEffectText>>,
            pub flavor_text_entries: Vec<Vec<models::ContestEffectFlavorText>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContestEffectDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appeal" => intermediate_rep.appeal.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "jam" => intermediate_rep.jam.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "effect_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in ContestEffectDetail".to_string()),
                    "flavor_text_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in ContestEffectDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContestEffectDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContestEffectDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ContestEffectDetail".to_string())?,
            appeal: intermediate_rep.appeal.into_iter().next().ok_or_else(|| "appeal missing in ContestEffectDetail".to_string())?,
            jam: intermediate_rep.jam.into_iter().next().ok_or_else(|| "jam missing in ContestEffectDetail".to_string())?,
            effect_entries: intermediate_rep.effect_entries.into_iter().next().ok_or_else(|| "effect_entries missing in ContestEffectDetail".to_string())?,
            flavor_text_entries: intermediate_rep.flavor_text_entries.into_iter().next().ok_or_else(|| "flavor_text_entries missing in ContestEffectDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContestEffectDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContestEffectDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContestEffectDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ContestEffectDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContestEffectDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContestEffectDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ContestEffectDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContestEffectEffectText {
    #[serde(rename = "effect")]
    #[validate(
            length(max = 6000),
          custom(function = "check_xss_string"),
    )]
    pub effect: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ContestEffectEffectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect: String, language: models::LanguageSummary, ) -> ContestEffectEffectText {
        ContestEffectEffectText {
 effect,
 language,
        }
    }
}

/// Converts the ContestEffectEffectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContestEffectEffectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("effect".to_string()),
            Some(self.effect.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContestEffectEffectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContestEffectEffectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContestEffectEffectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "effect" => intermediate_rep.effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContestEffectEffectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContestEffectEffectText {
            effect: intermediate_rep.effect.into_iter().next().ok_or_else(|| "effect missing in ContestEffectEffectText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ContestEffectEffectText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContestEffectEffectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContestEffectEffectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContestEffectEffectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ContestEffectEffectText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContestEffectEffectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContestEffectEffectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ContestEffectEffectText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContestEffectFlavorText {
    #[serde(rename = "flavor_text")]
    #[validate(
            length(max = 500),
          custom(function = "check_xss_string"),
    )]
    pub flavor_text: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ContestEffectFlavorText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(flavor_text: String, language: models::LanguageSummary, ) -> ContestEffectFlavorText {
        ContestEffectFlavorText {
 flavor_text,
 language,
        }
    }
}

/// Converts the ContestEffectFlavorText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContestEffectFlavorText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("flavor_text".to_string()),
            Some(self.flavor_text.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContestEffectFlavorText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContestEffectFlavorText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub flavor_text: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContestEffectFlavorText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "flavor_text" => intermediate_rep.flavor_text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContestEffectFlavorText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContestEffectFlavorText {
            flavor_text: intermediate_rep.flavor_text.into_iter().next().ok_or_else(|| "flavor_text missing in ContestEffectFlavorText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ContestEffectFlavorText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContestEffectFlavorText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContestEffectFlavorText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContestEffectFlavorText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ContestEffectFlavorText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContestEffectFlavorText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContestEffectFlavorText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ContestEffectFlavorText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContestEffectSummary {
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl ContestEffectSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> ContestEffectSummary {
        ContestEffectSummary {
 url,
        }
    }
}

/// Converts the ContestEffectSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContestEffectSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContestEffectSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContestEffectSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContestEffectSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContestEffectSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContestEffectSummary {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ContestEffectSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContestEffectSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContestEffectSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContestEffectSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ContestEffectSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContestEffectSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContestEffectSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ContestEffectSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContestTypeDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "berry_flavor")]
          #[validate(nested)]
    pub berry_flavor: models::BerryFlavorSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::ContestTypeName>,

}



impl ContestTypeDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, berry_flavor: models::BerryFlavorSummary, names: Vec<models::ContestTypeName>, ) -> ContestTypeDetail {
        ContestTypeDetail {
 id,
 name,
 berry_flavor,
 names,
        }
    }
}

/// Converts the ContestTypeDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContestTypeDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping berry_flavor in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContestTypeDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContestTypeDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub berry_flavor: Vec<models::BerryFlavorSummary>,
            pub names: Vec<Vec<models::ContestTypeName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContestTypeDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "berry_flavor" => intermediate_rep.berry_flavor.push(<models::BerryFlavorSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in ContestTypeDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContestTypeDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContestTypeDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ContestTypeDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ContestTypeDetail".to_string())?,
            berry_flavor: intermediate_rep.berry_flavor.into_iter().next().ok_or_else(|| "berry_flavor missing in ContestTypeDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in ContestTypeDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContestTypeDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContestTypeDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContestTypeDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ContestTypeDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContestTypeDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContestTypeDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ContestTypeDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContestTypeName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "color")]
    #[validate(
            length(max = 10),
          custom(function = "check_xss_string"),
    )]
    pub color: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ContestTypeName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, color: String, language: models::LanguageSummary, ) -> ContestTypeName {
        ContestTypeName {
 name,
 color,
 language,
        }
    }
}

/// Converts the ContestTypeName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContestTypeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("color".to_string()),
            Some(self.color.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContestTypeName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContestTypeName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub color: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContestTypeName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "color" => intermediate_rep.color.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContestTypeName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContestTypeName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ContestTypeName".to_string())?,
            color: intermediate_rep.color.into_iter().next().ok_or_else(|| "color missing in ContestTypeName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ContestTypeName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContestTypeName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContestTypeName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContestTypeName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ContestTypeName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContestTypeName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContestTypeName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ContestTypeName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ContestTypeSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl ContestTypeSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> ContestTypeSummary {
        ContestTypeSummary {
 name,
 url,
        }
    }
}

/// Converts the ContestTypeSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ContestTypeSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ContestTypeSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ContestTypeSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ContestTypeSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ContestTypeSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ContestTypeSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ContestTypeSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ContestTypeSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ContestTypeSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ContestTypeSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ContestTypeSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ContestTypeSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ContestTypeSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ContestTypeSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ContestTypeSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EggGroupDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::EggGroupName>,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: Vec<models::EggGroupDetailPokemonSpeciesInner>,

}



impl EggGroupDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::EggGroupName>, pokemon_species: Vec<models::EggGroupDetailPokemonSpeciesInner>, ) -> EggGroupDetail {
        EggGroupDetail {
 id,
 name,
 names,
 pokemon_species,
        }
    }
}

/// Converts the EggGroupDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EggGroupDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping names in query parameter serialization

            // Skipping pokemon_species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EggGroupDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EggGroupDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub names: Vec<Vec<models::EggGroupName>>,
            pub pokemon_species: Vec<Vec<models::EggGroupDetailPokemonSpeciesInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EggGroupDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in EggGroupDetail".to_string()),
                    "pokemon_species" => return std::result::Result::Err("Parsing a container in this style is not supported in EggGroupDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EggGroupDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EggGroupDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in EggGroupDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EggGroupDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in EggGroupDetail".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in EggGroupDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EggGroupDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EggGroupDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EggGroupDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EggGroupDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EggGroupDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EggGroupDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EggGroupDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EggGroupDetailPokemonSpeciesInner {
    /// Pokemon species name.
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The URL to get more information about the species
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

}



impl EggGroupDetailPokemonSpeciesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> EggGroupDetailPokemonSpeciesInner {
        EggGroupDetailPokemonSpeciesInner {
 name: None,
 url: None,
        }
    }
}

/// Converts the EggGroupDetailPokemonSpeciesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EggGroupDetailPokemonSpeciesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EggGroupDetailPokemonSpeciesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EggGroupDetailPokemonSpeciesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EggGroupDetailPokemonSpeciesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EggGroupDetailPokemonSpeciesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EggGroupDetailPokemonSpeciesInner {
            name: intermediate_rep.name.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EggGroupDetailPokemonSpeciesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EggGroupDetailPokemonSpeciesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EggGroupDetailPokemonSpeciesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EggGroupDetailPokemonSpeciesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EggGroupDetailPokemonSpeciesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EggGroupDetailPokemonSpeciesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EggGroupDetailPokemonSpeciesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EggGroupName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl EggGroupName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> EggGroupName {
        EggGroupName {
 name,
 language,
        }
    }
}

/// Converts the EggGroupName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EggGroupName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EggGroupName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EggGroupName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EggGroupName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EggGroupName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EggGroupName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EggGroupName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in EggGroupName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EggGroupName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EggGroupName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EggGroupName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EggGroupName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EggGroupName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EggGroupName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EggGroupName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EggGroupSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl EggGroupSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> EggGroupSummary {
        EggGroupSummary {
 name,
 url,
        }
    }
}

/// Converts the EggGroupSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EggGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EggGroupSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EggGroupSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EggGroupSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EggGroupSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EggGroupSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EggGroupSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in EggGroupSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EggGroupSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EggGroupSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EggGroupSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EggGroupSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EggGroupSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EggGroupSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EggGroupSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterConditionDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "values")]
          #[validate(nested)]
    pub values: Vec<models::EncounterConditionValueSummary>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::EncounterConditionName>,

}



impl EncounterConditionDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, values: Vec<models::EncounterConditionValueSummary>, names: Vec<models::EncounterConditionName>, ) -> EncounterConditionDetail {
        EncounterConditionDetail {
 id,
 name,
 values,
 names,
        }
    }
}

/// Converts the EncounterConditionDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterConditionDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping values in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterConditionDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterConditionDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub values: Vec<Vec<models::EncounterConditionValueSummary>>,
            pub names: Vec<Vec<models::EncounterConditionName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterConditionDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "values" => return std::result::Result::Err("Parsing a container in this style is not supported in EncounterConditionDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in EncounterConditionDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterConditionDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterConditionDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in EncounterConditionDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterConditionDetail".to_string())?,
            values: intermediate_rep.values.into_iter().next().ok_or_else(|| "values missing in EncounterConditionDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in EncounterConditionDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterConditionDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterConditionDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterConditionDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterConditionDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterConditionDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterConditionDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterConditionDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterConditionName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl EncounterConditionName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> EncounterConditionName {
        EncounterConditionName {
 name,
 language,
        }
    }
}

/// Converts the EncounterConditionName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterConditionName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterConditionName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterConditionName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterConditionName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterConditionName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterConditionName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterConditionName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in EncounterConditionName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterConditionName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterConditionName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterConditionName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterConditionName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterConditionName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterConditionName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterConditionName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterConditionSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl EncounterConditionSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> EncounterConditionSummary {
        EncounterConditionSummary {
 name,
 url,
        }
    }
}

/// Converts the EncounterConditionSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterConditionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterConditionSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterConditionSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterConditionSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterConditionSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterConditionSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterConditionSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in EncounterConditionSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterConditionSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterConditionSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterConditionSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterConditionSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterConditionSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterConditionSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterConditionSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterConditionValueDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "condition")]
          #[validate(nested)]
    pub condition: models::EncounterConditionSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::EncounterConditionValueName>,

}



impl EncounterConditionValueDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, condition: models::EncounterConditionSummary, names: Vec<models::EncounterConditionValueName>, ) -> EncounterConditionValueDetail {
        EncounterConditionValueDetail {
 id,
 name,
 condition,
 names,
        }
    }
}

/// Converts the EncounterConditionValueDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterConditionValueDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping condition in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterConditionValueDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterConditionValueDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub condition: Vec<models::EncounterConditionSummary>,
            pub names: Vec<Vec<models::EncounterConditionValueName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterConditionValueDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "condition" => intermediate_rep.condition.push(<models::EncounterConditionSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in EncounterConditionValueDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterConditionValueDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterConditionValueDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in EncounterConditionValueDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterConditionValueDetail".to_string())?,
            condition: intermediate_rep.condition.into_iter().next().ok_or_else(|| "condition missing in EncounterConditionValueDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in EncounterConditionValueDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterConditionValueDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterConditionValueDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterConditionValueDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterConditionValueDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterConditionValueDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterConditionValueDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterConditionValueDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterConditionValueName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl EncounterConditionValueName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> EncounterConditionValueName {
        EncounterConditionValueName {
 name,
 language,
        }
    }
}

/// Converts the EncounterConditionValueName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterConditionValueName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterConditionValueName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterConditionValueName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterConditionValueName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterConditionValueName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterConditionValueName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterConditionValueName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in EncounterConditionValueName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterConditionValueName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterConditionValueName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterConditionValueName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterConditionValueName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterConditionValueName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterConditionValueName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterConditionValueName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterConditionValueSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl EncounterConditionValueSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> EncounterConditionValueSummary {
        EncounterConditionValueSummary {
 name,
 url,
        }
    }
}

/// Converts the EncounterConditionValueSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterConditionValueSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterConditionValueSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterConditionValueSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterConditionValueSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterConditionValueSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterConditionValueSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterConditionValueSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in EncounterConditionValueSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterConditionValueSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterConditionValueSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterConditionValueSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterConditionValueSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterConditionValueSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterConditionValueSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterConditionValueSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterMethodDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "order")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order: Option<Nullable<i32>>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::EncounterMethodName>,

}



impl EncounterMethodDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::EncounterMethodName>, ) -> EncounterMethodDetail {
        EncounterMethodDetail {
 id,
 name,
 order: None,
 names,
        }
    }
}

/// Converts the EncounterMethodDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterMethodDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.order.as_ref().map(|order| {
                [
                    "order".to_string(),
                    order.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterMethodDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterMethodDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub order: Vec<i32>,
            pub names: Vec<Vec<models::EncounterMethodName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterMethodDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "order" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in EncounterMethodDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in EncounterMethodDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterMethodDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterMethodDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in EncounterMethodDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterMethodDetail".to_string())?,
            order: std::result::Result::Err("Nullable types not supported in EncounterMethodDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in EncounterMethodDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterMethodDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterMethodDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterMethodDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterMethodDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterMethodDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterMethodDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterMethodDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterMethodName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl EncounterMethodName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> EncounterMethodName {
        EncounterMethodName {
 name,
 language,
        }
    }
}

/// Converts the EncounterMethodName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterMethodName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterMethodName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterMethodName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterMethodName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterMethodName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterMethodName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterMethodName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in EncounterMethodName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterMethodName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterMethodName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterMethodName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterMethodName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterMethodName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterMethodName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterMethodName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EncounterMethodSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl EncounterMethodSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> EncounterMethodSummary {
        EncounterMethodSummary {
 name,
 url,
        }
    }
}

/// Converts the EncounterMethodSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EncounterMethodSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EncounterMethodSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EncounterMethodSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EncounterMethodSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EncounterMethodSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EncounterMethodSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EncounterMethodSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in EncounterMethodSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EncounterMethodSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EncounterMethodSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EncounterMethodSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EncounterMethodSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EncounterMethodSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EncounterMethodSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EncounterMethodSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionChainDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "baby_trigger_item")]
          #[validate(nested)]
    pub baby_trigger_item: models::ItemSummary,

    #[serde(rename = "chain")]
          #[validate(nested)]
    pub chain: models::EvolutionChainDetailChain,

}



impl EvolutionChainDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, baby_trigger_item: models::ItemSummary, chain: models::EvolutionChainDetailChain, ) -> EvolutionChainDetail {
        EvolutionChainDetail {
 id,
 baby_trigger_item,
 chain,
        }
    }
}

/// Converts the EvolutionChainDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionChainDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping baby_trigger_item in query parameter serialization

            // Skipping chain in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionChainDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionChainDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub baby_trigger_item: Vec<models::ItemSummary>,
            pub chain: Vec<models::EvolutionChainDetailChain>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionChainDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "baby_trigger_item" => intermediate_rep.baby_trigger_item.push(<models::ItemSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "chain" => intermediate_rep.chain.push(<models::EvolutionChainDetailChain as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionChainDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionChainDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in EvolutionChainDetail".to_string())?,
            baby_trigger_item: intermediate_rep.baby_trigger_item.into_iter().next().ok_or_else(|| "baby_trigger_item missing in EvolutionChainDetail".to_string())?,
            chain: intermediate_rep.chain.into_iter().next().ok_or_else(|| "chain missing in EvolutionChainDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionChainDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionChainDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionChainDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionChainDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionChainDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionChainDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionChainDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionChainDetailChain {
    #[serde(rename = "evolution_details")]
    pub evolution_details: Vec<crate::types::Object>,

    #[serde(rename = "evolves_to")]
          #[validate(nested)]
    pub evolves_to: Vec<models::EvolutionChainDetailChainEvolvesToInner>,

    #[serde(rename = "is_baby")]
    pub is_baby: bool,

    #[serde(rename = "species")]
          #[validate(nested)]
    pub species: models::AbilityDetailPokemonInnerPokemon,

}



impl EvolutionChainDetailChain {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(evolution_details: Vec<crate::types::Object>, evolves_to: Vec<models::EvolutionChainDetailChainEvolvesToInner>, is_baby: bool, species: models::AbilityDetailPokemonInnerPokemon, ) -> EvolutionChainDetailChain {
        EvolutionChainDetailChain {
 evolution_details,
 evolves_to,
 is_baby,
 species,
        }
    }
}

/// Converts the EvolutionChainDetailChain value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionChainDetailChain {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping evolution_details in query parameter serialization

            // Skipping evolves_to in query parameter serialization


            Some("is_baby".to_string()),
            Some(self.is_baby.to_string()),

            // Skipping species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionChainDetailChain value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionChainDetailChain {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub evolution_details: Vec<Vec<crate::types::Object>>,
            pub evolves_to: Vec<Vec<models::EvolutionChainDetailChainEvolvesToInner>>,
            pub is_baby: Vec<bool>,
            pub species: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionChainDetailChain".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "evolution_details" => return std::result::Result::Err("Parsing a container in this style is not supported in EvolutionChainDetailChain".to_string()),
                    "evolves_to" => return std::result::Result::Err("Parsing a container in this style is not supported in EvolutionChainDetailChain".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_baby" => intermediate_rep.is_baby.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "species" => intermediate_rep.species.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionChainDetailChain".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionChainDetailChain {
            evolution_details: intermediate_rep.evolution_details.into_iter().next().ok_or_else(|| "evolution_details missing in EvolutionChainDetailChain".to_string())?,
            evolves_to: intermediate_rep.evolves_to.into_iter().next().ok_or_else(|| "evolves_to missing in EvolutionChainDetailChain".to_string())?,
            is_baby: intermediate_rep.is_baby.into_iter().next().ok_or_else(|| "is_baby missing in EvolutionChainDetailChain".to_string())?,
            species: intermediate_rep.species.into_iter().next().ok_or_else(|| "species missing in EvolutionChainDetailChain".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionChainDetailChain> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionChainDetailChain>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionChainDetailChain>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionChainDetailChain - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionChainDetailChain> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionChainDetailChain as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionChainDetailChain - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionChainDetailChainEvolvesToInner {
    #[serde(rename = "evolution_details")]
          #[validate(nested)]
    pub evolution_details: Vec<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner>,

    #[serde(rename = "is_baby")]
    pub is_baby: bool,

    #[serde(rename = "species")]
          #[validate(nested)]
    pub species: models::AbilityDetailPokemonInnerPokemon,

}



impl EvolutionChainDetailChainEvolvesToInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(evolution_details: Vec<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner>, is_baby: bool, species: models::AbilityDetailPokemonInnerPokemon, ) -> EvolutionChainDetailChainEvolvesToInner {
        EvolutionChainDetailChainEvolvesToInner {
 evolution_details,
 is_baby,
 species,
        }
    }
}

/// Converts the EvolutionChainDetailChainEvolvesToInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionChainDetailChainEvolvesToInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping evolution_details in query parameter serialization


            Some("is_baby".to_string()),
            Some(self.is_baby.to_string()),

            // Skipping species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionChainDetailChainEvolvesToInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionChainDetailChainEvolvesToInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub evolution_details: Vec<Vec<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner>>,
            pub is_baby: Vec<bool>,
            pub species: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionChainDetailChainEvolvesToInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "evolution_details" => return std::result::Result::Err("Parsing a container in this style is not supported in EvolutionChainDetailChainEvolvesToInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_baby" => intermediate_rep.is_baby.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "species" => intermediate_rep.species.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionChainDetailChainEvolvesToInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionChainDetailChainEvolvesToInner {
            evolution_details: intermediate_rep.evolution_details.into_iter().next().ok_or_else(|| "evolution_details missing in EvolutionChainDetailChainEvolvesToInner".to_string())?,
            is_baby: intermediate_rep.is_baby.into_iter().next().ok_or_else(|| "is_baby missing in EvolutionChainDetailChainEvolvesToInner".to_string())?,
            species: intermediate_rep.species.into_iter().next().ok_or_else(|| "species missing in EvolutionChainDetailChainEvolvesToInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionChainDetailChainEvolvesToInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionChainDetailChainEvolvesToInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionChainDetailChainEvolvesToInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner {
    #[serde(rename = "gender")]
          #[validate(nested)]
    pub gender: models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender,

    #[serde(rename = "held_item")]
          #[validate(nested)]
    pub held_item: models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender,

    #[serde(rename = "item")]
          #[validate(nested)]
    pub item: models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender,

    #[serde(rename = "known_move")]
    pub known_move: crate::types::Object,

    #[serde(rename = "known_move_type")]
    pub known_move_type: crate::types::Object,

    #[serde(rename = "location")]
          #[validate(nested)]
    pub location: models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender,

    #[serde(rename = "min_affection")]
    pub min_affection: i32,

    #[serde(rename = "min_beauty")]
    pub min_beauty: i32,

    #[serde(rename = "min_happiness")]
    pub min_happiness: i32,

    #[serde(rename = "min_level")]
    pub min_level: i32,

    #[serde(rename = "needs_overworld_rain")]
    pub needs_overworld_rain: bool,

    #[serde(rename = "party_species")]
          #[validate(custom(function = "check_xss_string"))]
    pub party_species: String,

    #[serde(rename = "party_type")]
          #[validate(custom(function = "check_xss_string"))]
    pub party_type: String,

    #[serde(rename = "relative_physical_stats")]
          #[validate(custom(function = "check_xss_string"))]
    pub relative_physical_stats: String,

    #[serde(rename = "time_of_day")]
          #[validate(custom(function = "check_xss_string"))]
    pub time_of_day: String,

    #[serde(rename = "trade_species")]
          #[validate(custom(function = "check_xss_string"))]
    pub trade_species: String,

    #[serde(rename = "trigger")]
          #[validate(nested)]
    pub trigger: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "turn_upside_down")]
    pub turn_upside_down: bool,

}



impl EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(gender: models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender, held_item: models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender, item: models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender, known_move: crate::types::Object, known_move_type: crate::types::Object, location: models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender, min_affection: i32, min_beauty: i32, min_happiness: i32, min_level: i32, needs_overworld_rain: bool, party_species: String, party_type: String, relative_physical_stats: String, time_of_day: String, trade_species: String, trigger: models::AbilityDetailPokemonInnerPokemon, turn_upside_down: bool, ) -> EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner {
        EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner {
 gender,
 held_item,
 item,
 known_move,
 known_move_type,
 location,
 min_affection,
 min_beauty,
 min_happiness,
 min_level,
 needs_overworld_rain,
 party_species,
 party_type,
 relative_physical_stats,
 time_of_day,
 trade_species,
 trigger,
 turn_upside_down,
        }
    }
}

/// Converts the EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping gender in query parameter serialization

            // Skipping held_item in query parameter serialization

            // Skipping item in query parameter serialization

            // Skipping known_move in query parameter serialization

            // Skipping known_move_type in query parameter serialization

            // Skipping location in query parameter serialization


            Some("min_affection".to_string()),
            Some(self.min_affection.to_string()),


            Some("min_beauty".to_string()),
            Some(self.min_beauty.to_string()),


            Some("min_happiness".to_string()),
            Some(self.min_happiness.to_string()),


            Some("min_level".to_string()),
            Some(self.min_level.to_string()),


            Some("needs_overworld_rain".to_string()),
            Some(self.needs_overworld_rain.to_string()),


            Some("party_species".to_string()),
            Some(self.party_species.to_string()),


            Some("party_type".to_string()),
            Some(self.party_type.to_string()),


            Some("relative_physical_stats".to_string()),
            Some(self.relative_physical_stats.to_string()),


            Some("time_of_day".to_string()),
            Some(self.time_of_day.to_string()),


            Some("trade_species".to_string()),
            Some(self.trade_species.to_string()),

            // Skipping trigger in query parameter serialization


            Some("turn_upside_down".to_string()),
            Some(self.turn_upside_down.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub gender: Vec<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender>,
            pub held_item: Vec<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender>,
            pub item: Vec<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender>,
            pub known_move: Vec<crate::types::Object>,
            pub known_move_type: Vec<crate::types::Object>,
            pub location: Vec<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender>,
            pub min_affection: Vec<i32>,
            pub min_beauty: Vec<i32>,
            pub min_happiness: Vec<i32>,
            pub min_level: Vec<i32>,
            pub needs_overworld_rain: Vec<bool>,
            pub party_species: Vec<String>,
            pub party_type: Vec<String>,
            pub relative_physical_stats: Vec<String>,
            pub time_of_day: Vec<String>,
            pub trade_species: Vec<String>,
            pub trigger: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub turn_upside_down: Vec<bool>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "gender" => intermediate_rep.gender.push(<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "held_item" => intermediate_rep.held_item.push(<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item" => intermediate_rep.item.push(<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "known_move" => intermediate_rep.known_move.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "known_move_type" => intermediate_rep.known_move_type.push(<crate::types::Object as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<models::EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "min_affection" => intermediate_rep.min_affection.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "min_beauty" => intermediate_rep.min_beauty.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "min_happiness" => intermediate_rep.min_happiness.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "min_level" => intermediate_rep.min_level.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "needs_overworld_rain" => intermediate_rep.needs_overworld_rain.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "party_species" => intermediate_rep.party_species.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "party_type" => intermediate_rep.party_type.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "relative_physical_stats" => intermediate_rep.relative_physical_stats.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "time_of_day" => intermediate_rep.time_of_day.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "trade_species" => intermediate_rep.trade_species.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "trigger" => intermediate_rep.trigger.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "turn_upside_down" => intermediate_rep.turn_upside_down.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner {
            gender: intermediate_rep.gender.into_iter().next().ok_or_else(|| "gender missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            held_item: intermediate_rep.held_item.into_iter().next().ok_or_else(|| "held_item missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            item: intermediate_rep.item.into_iter().next().ok_or_else(|| "item missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            known_move: intermediate_rep.known_move.into_iter().next().ok_or_else(|| "known_move missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            known_move_type: intermediate_rep.known_move_type.into_iter().next().ok_or_else(|| "known_move_type missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or_else(|| "location missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            min_affection: intermediate_rep.min_affection.into_iter().next().ok_or_else(|| "min_affection missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            min_beauty: intermediate_rep.min_beauty.into_iter().next().ok_or_else(|| "min_beauty missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            min_happiness: intermediate_rep.min_happiness.into_iter().next().ok_or_else(|| "min_happiness missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            min_level: intermediate_rep.min_level.into_iter().next().ok_or_else(|| "min_level missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            needs_overworld_rain: intermediate_rep.needs_overworld_rain.into_iter().next().ok_or_else(|| "needs_overworld_rain missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            party_species: intermediate_rep.party_species.into_iter().next().ok_or_else(|| "party_species missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            party_type: intermediate_rep.party_type.into_iter().next().ok_or_else(|| "party_type missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            relative_physical_stats: intermediate_rep.relative_physical_stats.into_iter().next().ok_or_else(|| "relative_physical_stats missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            time_of_day: intermediate_rep.time_of_day.into_iter().next().ok_or_else(|| "time_of_day missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            trade_species: intermediate_rep.trade_species.into_iter().next().ok_or_else(|| "trade_species missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            trigger: intermediate_rep.trigger.into_iter().next().ok_or_else(|| "trigger missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
            turn_upside_down: intermediate_rep.turn_upside_down.into_iter().next().ok_or_else(|| "turn_upside_down missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender {
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender {
        EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender {
 name,
 url,
        }
    }
}

/// Converts the EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionChainSummary {
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl EvolutionChainSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> EvolutionChainSummary {
        EvolutionChainSummary {
 url,
        }
    }
}

/// Converts the EvolutionChainSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionChainSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionChainSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionChainSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionChainSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionChainSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionChainSummary {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in EvolutionChainSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionChainSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionChainSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionChainSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionChainSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionChainSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionChainSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionChainSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionTriggerDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::EvolutionTriggerName>,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl EvolutionTriggerDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::EvolutionTriggerName>, pokemon_species: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> EvolutionTriggerDetail {
        EvolutionTriggerDetail {
 id,
 name,
 names,
 pokemon_species,
        }
    }
}

/// Converts the EvolutionTriggerDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionTriggerDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping names in query parameter serialization

            // Skipping pokemon_species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionTriggerDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionTriggerDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub names: Vec<Vec<models::EvolutionTriggerName>>,
            pub pokemon_species: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionTriggerDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in EvolutionTriggerDetail".to_string()),
                    "pokemon_species" => return std::result::Result::Err("Parsing a container in this style is not supported in EvolutionTriggerDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionTriggerDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionTriggerDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in EvolutionTriggerDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EvolutionTriggerDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in EvolutionTriggerDetail".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in EvolutionTriggerDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionTriggerDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionTriggerDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionTriggerDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionTriggerDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionTriggerDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionTriggerDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionTriggerDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionTriggerName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl EvolutionTriggerName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> EvolutionTriggerName {
        EvolutionTriggerName {
 name,
 language,
        }
    }
}

/// Converts the EvolutionTriggerName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionTriggerName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionTriggerName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionTriggerName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionTriggerName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionTriggerName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionTriggerName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EvolutionTriggerName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in EvolutionTriggerName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionTriggerName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionTriggerName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionTriggerName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionTriggerName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionTriggerName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionTriggerName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionTriggerName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct EvolutionTriggerSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl EvolutionTriggerSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> EvolutionTriggerSummary {
        EvolutionTriggerSummary {
 name,
 url,
        }
    }
}

/// Converts the EvolutionTriggerSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for EvolutionTriggerSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a EvolutionTriggerSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for EvolutionTriggerSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing EvolutionTriggerSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing EvolutionTriggerSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(EvolutionTriggerSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in EvolutionTriggerSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in EvolutionTriggerSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<EvolutionTriggerSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<EvolutionTriggerSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<EvolutionTriggerSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for EvolutionTriggerSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<EvolutionTriggerSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <EvolutionTriggerSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into EvolutionTriggerSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct Experience {
    #[serde(rename = "level")]
    pub level: i32,

    #[serde(rename = "experience")]
    pub experience: i32,

}



impl Experience {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(level: i32, experience: i32, ) -> Experience {
        Experience {
 level,
 experience,
        }
    }
}

/// Converts the Experience value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for Experience {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("level".to_string()),
            Some(self.level.to_string()),


            Some("experience".to_string()),
            Some(self.experience.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a Experience value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for Experience {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub level: Vec<i32>,
            pub experience: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing Experience".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "level" => intermediate_rep.level.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "experience" => intermediate_rep.experience.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing Experience".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(Experience {
            level: intermediate_rep.level.into_iter().next().ok_or_else(|| "level missing in Experience".to_string())?,
            experience: intermediate_rep.experience.into_iter().next().ok_or_else(|| "experience missing in Experience".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<Experience> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<Experience>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<Experience>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for Experience - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<Experience> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <Experience as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into Experience - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenderDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "pokemon_species_details")]
          #[validate(nested)]
    pub pokemon_species_details: Vec<models::GenderDetailPokemonSpeciesDetailsInner>,

    #[serde(rename = "required_for_evolution")]
          #[validate(nested)]
    pub required_for_evolution: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl GenderDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, pokemon_species_details: Vec<models::GenderDetailPokemonSpeciesDetailsInner>, required_for_evolution: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> GenderDetail {
        GenderDetail {
 id,
 name,
 pokemon_species_details,
 required_for_evolution,
        }
    }
}

/// Converts the GenderDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GenderDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping pokemon_species_details in query parameter serialization

            // Skipping required_for_evolution in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenderDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenderDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub pokemon_species_details: Vec<Vec<models::GenderDetailPokemonSpeciesDetailsInner>>,
            pub required_for_evolution: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenderDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pokemon_species_details" => return std::result::Result::Err("Parsing a container in this style is not supported in GenderDetail".to_string()),
                    "required_for_evolution" => return std::result::Result::Err("Parsing a container in this style is not supported in GenderDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenderDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenderDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in GenderDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in GenderDetail".to_string())?,
            pokemon_species_details: intermediate_rep.pokemon_species_details.into_iter().next().ok_or_else(|| "pokemon_species_details missing in GenderDetail".to_string())?,
            required_for_evolution: intermediate_rep.required_for_evolution.into_iter().next().ok_or_else(|| "required_for_evolution missing in GenderDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenderDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GenderDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenderDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GenderDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GenderDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenderDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GenderDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenderDetailPokemonSpeciesDetailsInner {
    #[serde(rename = "rate")]
    pub rate: i32,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: models::AbilityDetailPokemonInnerPokemon,

}



impl GenderDetailPokemonSpeciesDetailsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(rate: i32, pokemon_species: models::AbilityDetailPokemonInnerPokemon, ) -> GenderDetailPokemonSpeciesDetailsInner {
        GenderDetailPokemonSpeciesDetailsInner {
 rate,
 pokemon_species,
        }
    }
}

/// Converts the GenderDetailPokemonSpeciesDetailsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GenderDetailPokemonSpeciesDetailsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("rate".to_string()),
            Some(self.rate.to_string()),

            // Skipping pokemon_species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenderDetailPokemonSpeciesDetailsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenderDetailPokemonSpeciesDetailsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rate: Vec<i32>,
            pub pokemon_species: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenderDetailPokemonSpeciesDetailsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rate" => intermediate_rep.rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokemon_species" => intermediate_rep.pokemon_species.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenderDetailPokemonSpeciesDetailsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenderDetailPokemonSpeciesDetailsInner {
            rate: intermediate_rep.rate.into_iter().next().ok_or_else(|| "rate missing in GenderDetailPokemonSpeciesDetailsInner".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in GenderDetailPokemonSpeciesDetailsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenderDetailPokemonSpeciesDetailsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GenderDetailPokemonSpeciesDetailsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenderDetailPokemonSpeciesDetailsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GenderDetailPokemonSpeciesDetailsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GenderDetailPokemonSpeciesDetailsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenderDetailPokemonSpeciesDetailsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GenderDetailPokemonSpeciesDetailsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenderSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl GenderSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> GenderSummary {
        GenderSummary {
 name,
 url,
        }
    }
}

/// Converts the GenderSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GenderSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenderSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenderSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenderSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenderSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenderSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in GenderSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in GenderSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenderSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GenderSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenderSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GenderSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GenderSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenderSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GenderSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerationDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "abilities")]
          #[validate(nested)]
    pub abilities: Vec<models::AbilitySummary>,

    #[serde(rename = "main_region")]
          #[validate(nested)]
    pub main_region: models::RegionSummary,

    #[serde(rename = "moves")]
          #[validate(nested)]
    pub moves: Vec<models::MoveSummary>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::GenerationName>,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: Vec<models::PokemonSpeciesSummary>,

    #[serde(rename = "types")]
          #[validate(nested)]
    pub types: Vec<models::TypeSummary>,

    #[serde(rename = "version_groups")]
          #[validate(nested)]
    pub version_groups: Vec<models::VersionGroupSummary>,

}



impl GenerationDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, abilities: Vec<models::AbilitySummary>, main_region: models::RegionSummary, moves: Vec<models::MoveSummary>, names: Vec<models::GenerationName>, pokemon_species: Vec<models::PokemonSpeciesSummary>, types: Vec<models::TypeSummary>, version_groups: Vec<models::VersionGroupSummary>, ) -> GenerationDetail {
        GenerationDetail {
 id,
 name,
 abilities,
 main_region,
 moves,
 names,
 pokemon_species,
 types,
 version_groups,
        }
    }
}

/// Converts the GenerationDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GenerationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping abilities in query parameter serialization

            // Skipping main_region in query parameter serialization

            // Skipping moves in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping pokemon_species in query parameter serialization

            // Skipping types in query parameter serialization

            // Skipping version_groups in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerationDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerationDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub abilities: Vec<Vec<models::AbilitySummary>>,
            pub main_region: Vec<models::RegionSummary>,
            pub moves: Vec<Vec<models::MoveSummary>>,
            pub names: Vec<Vec<models::GenerationName>>,
            pub pokemon_species: Vec<Vec<models::PokemonSpeciesSummary>>,
            pub types: Vec<Vec<models::TypeSummary>>,
            pub version_groups: Vec<Vec<models::VersionGroupSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerationDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "abilities" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerationDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "main_region" => intermediate_rep.main_region.push(<models::RegionSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "moves" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerationDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerationDetail".to_string()),
                    "pokemon_species" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerationDetail".to_string()),
                    "types" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerationDetail".to_string()),
                    "version_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in GenerationDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerationDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerationDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in GenerationDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in GenerationDetail".to_string())?,
            abilities: intermediate_rep.abilities.into_iter().next().ok_or_else(|| "abilities missing in GenerationDetail".to_string())?,
            main_region: intermediate_rep.main_region.into_iter().next().ok_or_else(|| "main_region missing in GenerationDetail".to_string())?,
            moves: intermediate_rep.moves.into_iter().next().ok_or_else(|| "moves missing in GenerationDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in GenerationDetail".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in GenerationDetail".to_string())?,
            types: intermediate_rep.types.into_iter().next().ok_or_else(|| "types missing in GenerationDetail".to_string())?,
            version_groups: intermediate_rep.version_groups.into_iter().next().ok_or_else(|| "version_groups missing in GenerationDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerationDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerationDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerationDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GenerationDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GenerationDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerationDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GenerationDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerationName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl GenerationName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> GenerationName {
        GenerationName {
 name,
 language,
        }
    }
}

/// Converts the GenerationName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GenerationName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerationName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerationName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerationName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerationName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerationName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in GenerationName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in GenerationName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerationName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerationName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerationName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GenerationName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GenerationName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerationName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GenerationName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GenerationSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl GenerationSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> GenerationSummary {
        GenerationSummary {
 name,
 url,
        }
    }
}

/// Converts the GenerationSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GenerationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GenerationSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GenerationSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GenerationSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GenerationSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GenerationSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in GenerationSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in GenerationSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GenerationSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GenerationSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GenerationSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GenerationSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GenerationSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GenerationSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GenerationSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GrowthRateDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl GrowthRateDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> GrowthRateDescription {
        GrowthRateDescription {
 description: None,
 language,
        }
    }
}

/// Converts the GrowthRateDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GrowthRateDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GrowthRateDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GrowthRateDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GrowthRateDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GrowthRateDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GrowthRateDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in GrowthRateDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GrowthRateDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GrowthRateDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GrowthRateDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GrowthRateDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GrowthRateDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GrowthRateDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GrowthRateDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GrowthRateDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "formula")]
    #[validate(
            length(max = 500),
          custom(function = "check_xss_string"),
    )]
    pub formula: String,

    #[serde(rename = "descriptions")]
          #[validate(nested)]
    pub descriptions: Vec<models::GrowthRateDescription>,

    #[serde(rename = "levels")]
          #[validate(nested)]
    pub levels: Vec<models::Experience>,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: Vec<models::PokemonSpeciesSummary>,

}



impl GrowthRateDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, formula: String, descriptions: Vec<models::GrowthRateDescription>, levels: Vec<models::Experience>, pokemon_species: Vec<models::PokemonSpeciesSummary>, ) -> GrowthRateDetail {
        GrowthRateDetail {
 id,
 name,
 formula,
 descriptions,
 levels,
 pokemon_species,
        }
    }
}

/// Converts the GrowthRateDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GrowthRateDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("formula".to_string()),
            Some(self.formula.to_string()),

            // Skipping descriptions in query parameter serialization

            // Skipping levels in query parameter serialization

            // Skipping pokemon_species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GrowthRateDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GrowthRateDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub formula: Vec<String>,
            pub descriptions: Vec<Vec<models::GrowthRateDescription>>,
            pub levels: Vec<Vec<models::Experience>>,
            pub pokemon_species: Vec<Vec<models::PokemonSpeciesSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GrowthRateDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "formula" => intermediate_rep.formula.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in GrowthRateDetail".to_string()),
                    "levels" => return std::result::Result::Err("Parsing a container in this style is not supported in GrowthRateDetail".to_string()),
                    "pokemon_species" => return std::result::Result::Err("Parsing a container in this style is not supported in GrowthRateDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing GrowthRateDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GrowthRateDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in GrowthRateDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in GrowthRateDetail".to_string())?,
            formula: intermediate_rep.formula.into_iter().next().ok_or_else(|| "formula missing in GrowthRateDetail".to_string())?,
            descriptions: intermediate_rep.descriptions.into_iter().next().ok_or_else(|| "descriptions missing in GrowthRateDetail".to_string())?,
            levels: intermediate_rep.levels.into_iter().next().ok_or_else(|| "levels missing in GrowthRateDetail".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in GrowthRateDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GrowthRateDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GrowthRateDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GrowthRateDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GrowthRateDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GrowthRateDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GrowthRateDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GrowthRateDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct GrowthRateSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl GrowthRateSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> GrowthRateSummary {
        GrowthRateSummary {
 name,
 url,
        }
    }
}

/// Converts the GrowthRateSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for GrowthRateSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a GrowthRateSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for GrowthRateSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing GrowthRateSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing GrowthRateSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(GrowthRateSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in GrowthRateSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in GrowthRateSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<GrowthRateSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<GrowthRateSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<GrowthRateSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for GrowthRateSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<GrowthRateSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <GrowthRateSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into GrowthRateSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemAttributeDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ItemAttributeDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> ItemAttributeDescription {
        ItemAttributeDescription {
 description: None,
 language,
        }
    }
}

/// Converts the ItemAttributeDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemAttributeDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemAttributeDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemAttributeDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemAttributeDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemAttributeDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemAttributeDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ItemAttributeDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemAttributeDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemAttributeDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemAttributeDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemAttributeDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemAttributeDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemAttributeDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemAttributeDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemAttributeDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "descriptions")]
          #[validate(nested)]
    pub descriptions: Vec<models::ItemAttributeDescription>,

    #[serde(rename = "items")]
          #[validate(nested)]
    pub items: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::ItemAttributeName>,

}



impl ItemAttributeDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, descriptions: Vec<models::ItemAttributeDescription>, items: Vec<models::AbilityDetailPokemonInnerPokemon>, names: Vec<models::ItemAttributeName>, ) -> ItemAttributeDetail {
        ItemAttributeDetail {
 id,
 name,
 descriptions,
 items,
 names,
        }
    }
}

/// Converts the ItemAttributeDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemAttributeDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping descriptions in query parameter serialization

            // Skipping items in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemAttributeDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemAttributeDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub descriptions: Vec<Vec<models::ItemAttributeDescription>>,
            pub items: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub names: Vec<Vec<models::ItemAttributeName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemAttributeDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributeDetail".to_string()),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributeDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemAttributeDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemAttributeDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemAttributeDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ItemAttributeDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemAttributeDetail".to_string())?,
            descriptions: intermediate_rep.descriptions.into_iter().next().ok_or_else(|| "descriptions missing in ItemAttributeDetail".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in ItemAttributeDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in ItemAttributeDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemAttributeDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemAttributeDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemAttributeDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemAttributeDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemAttributeDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemAttributeDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemAttributeDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemAttributeName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ItemAttributeName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> ItemAttributeName {
        ItemAttributeName {
 name,
 language,
        }
    }
}

/// Converts the ItemAttributeName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemAttributeName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemAttributeName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemAttributeName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemAttributeName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemAttributeName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemAttributeName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemAttributeName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ItemAttributeName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemAttributeName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemAttributeName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemAttributeName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemAttributeName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemAttributeName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemAttributeName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemAttributeName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemAttributeSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl ItemAttributeSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> ItemAttributeSummary {
        ItemAttributeSummary {
 name,
 url,
        }
    }
}

/// Converts the ItemAttributeSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemAttributeSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemAttributeSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemAttributeSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemAttributeSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemAttributeSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemAttributeSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemAttributeSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ItemAttributeSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemAttributeSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemAttributeSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemAttributeSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemAttributeSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemAttributeSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemAttributeSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemAttributeSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemCategoryDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "items")]
          #[validate(nested)]
    pub items: Vec<models::ItemSummary>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::ItemCategoryName>,

    #[serde(rename = "pocket")]
          #[validate(nested)]
    pub pocket: models::ItemPocketSummary,

}



impl ItemCategoryDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, items: Vec<models::ItemSummary>, names: Vec<models::ItemCategoryName>, pocket: models::ItemPocketSummary, ) -> ItemCategoryDetail {
        ItemCategoryDetail {
 id,
 name,
 items,
 names,
 pocket,
        }
    }
}

/// Converts the ItemCategoryDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemCategoryDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping items in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping pocket in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemCategoryDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemCategoryDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub items: Vec<Vec<models::ItemSummary>>,
            pub names: Vec<Vec<models::ItemCategoryName>>,
            pub pocket: Vec<models::ItemPocketSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemCategoryDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemCategoryDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemCategoryDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "pocket" => intermediate_rep.pocket.push(<models::ItemPocketSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemCategoryDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemCategoryDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ItemCategoryDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemCategoryDetail".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in ItemCategoryDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in ItemCategoryDetail".to_string())?,
            pocket: intermediate_rep.pocket.into_iter().next().ok_or_else(|| "pocket missing in ItemCategoryDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemCategoryDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemCategoryDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemCategoryDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemCategoryDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemCategoryDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemCategoryDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemCategoryDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemCategoryName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ItemCategoryName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> ItemCategoryName {
        ItemCategoryName {
 name,
 language,
        }
    }
}

/// Converts the ItemCategoryName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemCategoryName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemCategoryName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemCategoryName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemCategoryName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemCategoryName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemCategoryName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemCategoryName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ItemCategoryName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemCategoryName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemCategoryName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemCategoryName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemCategoryName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemCategoryName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemCategoryName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemCategoryName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemCategorySummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl ItemCategorySummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> ItemCategorySummary {
        ItemCategorySummary {
 name,
 url,
        }
    }
}

/// Converts the ItemCategorySummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemCategorySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemCategorySummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemCategorySummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemCategorySummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemCategorySummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemCategorySummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemCategorySummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ItemCategorySummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemCategorySummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemCategorySummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemCategorySummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemCategorySummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemCategorySummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemCategorySummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemCategorySummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "cost")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub cost: Option<Nullable<i32>>,

    #[serde(rename = "fling_power")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub fling_power: Option<Nullable<i32>>,

    #[serde(rename = "fling_effect")]
          #[validate(nested)]
    pub fling_effect: models::ItemFlingEffectSummary,

    #[serde(rename = "attributes")]
          #[validate(nested)]
    pub attributes: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "category")]
          #[validate(nested)]
    pub category: models::ItemCategorySummary,

    #[serde(rename = "effect_entries")]
          #[validate(nested)]
    pub effect_entries: Vec<models::ItemEffectText>,

    #[serde(rename = "flavor_text_entries")]
          #[validate(nested)]
    pub flavor_text_entries: Vec<models::ItemFlavorText>,

    #[serde(rename = "game_indices")]
          #[validate(nested)]
    pub game_indices: Vec<models::ItemGameIndex>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::ItemName>,

    #[serde(rename = "held_by_pokemon")]
          #[validate(nested)]
    pub held_by_pokemon: Vec<models::ItemDetailHeldByPokemonInner>,

    #[serde(rename = "sprites")]
          #[validate(nested)]
    pub sprites: models::ItemDetailSprites,

    #[serde(rename = "baby_trigger_for")]
          #[validate(nested)]
    pub baby_trigger_for: models::ItemDetailBabyTriggerFor,

    #[serde(rename = "machines")]
          #[validate(nested)]
    pub machines: Vec<models::ItemDetailMachinesInner>,

}



impl ItemDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, fling_effect: models::ItemFlingEffectSummary, attributes: Vec<models::AbilityDetailPokemonInnerPokemon>, category: models::ItemCategorySummary, effect_entries: Vec<models::ItemEffectText>, flavor_text_entries: Vec<models::ItemFlavorText>, game_indices: Vec<models::ItemGameIndex>, names: Vec<models::ItemName>, held_by_pokemon: Vec<models::ItemDetailHeldByPokemonInner>, sprites: models::ItemDetailSprites, baby_trigger_for: models::ItemDetailBabyTriggerFor, machines: Vec<models::ItemDetailMachinesInner>, ) -> ItemDetail {
        ItemDetail {
 id,
 name,
 cost: None,
 fling_power: None,
 fling_effect,
 attributes,
 category,
 effect_entries,
 flavor_text_entries,
 game_indices,
 names,
 held_by_pokemon,
 sprites,
 baby_trigger_for,
 machines,
        }
    }
}

/// Converts the ItemDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.cost.as_ref().map(|cost| {
                [
                    "cost".to_string(),
                    cost.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.fling_power.as_ref().map(|fling_power| {
                [
                    "fling_power".to_string(),
                    fling_power.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping fling_effect in query parameter serialization

            // Skipping attributes in query parameter serialization

            // Skipping category in query parameter serialization

            // Skipping effect_entries in query parameter serialization

            // Skipping flavor_text_entries in query parameter serialization

            // Skipping game_indices in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping held_by_pokemon in query parameter serialization

            // Skipping sprites in query parameter serialization

            // Skipping baby_trigger_for in query parameter serialization

            // Skipping machines in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub cost: Vec<i32>,
            pub fling_power: Vec<i32>,
            pub fling_effect: Vec<models::ItemFlingEffectSummary>,
            pub attributes: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub category: Vec<models::ItemCategorySummary>,
            pub effect_entries: Vec<Vec<models::ItemEffectText>>,
            pub flavor_text_entries: Vec<Vec<models::ItemFlavorText>>,
            pub game_indices: Vec<Vec<models::ItemGameIndex>>,
            pub names: Vec<Vec<models::ItemName>>,
            pub held_by_pokemon: Vec<Vec<models::ItemDetailHeldByPokemonInner>>,
            pub sprites: Vec<models::ItemDetailSprites>,
            pub baby_trigger_for: Vec<models::ItemDetailBabyTriggerFor>,
            pub machines: Vec<Vec<models::ItemDetailMachinesInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "cost" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemDetail".to_string()),
                    "fling_power" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in ItemDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "fling_effect" => intermediate_rep.fling_effect.push(<models::ItemFlingEffectSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "attributes" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<models::ItemCategorySummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "effect_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemDetail".to_string()),
                    "flavor_text_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemDetail".to_string()),
                    "game_indices" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemDetail".to_string()),
                    "held_by_pokemon" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "sprites" => intermediate_rep.sprites.push(<models::ItemDetailSprites as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "baby_trigger_for" => intermediate_rep.baby_trigger_for.push(<models::ItemDetailBabyTriggerFor as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "machines" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ItemDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemDetail".to_string())?,
            cost: std::result::Result::Err("Nullable types not supported in ItemDetail".to_string())?,
            fling_power: std::result::Result::Err("Nullable types not supported in ItemDetail".to_string())?,
            fling_effect: intermediate_rep.fling_effect.into_iter().next().ok_or_else(|| "fling_effect missing in ItemDetail".to_string())?,
            attributes: intermediate_rep.attributes.into_iter().next().ok_or_else(|| "attributes missing in ItemDetail".to_string())?,
            category: intermediate_rep.category.into_iter().next().ok_or_else(|| "category missing in ItemDetail".to_string())?,
            effect_entries: intermediate_rep.effect_entries.into_iter().next().ok_or_else(|| "effect_entries missing in ItemDetail".to_string())?,
            flavor_text_entries: intermediate_rep.flavor_text_entries.into_iter().next().ok_or_else(|| "flavor_text_entries missing in ItemDetail".to_string())?,
            game_indices: intermediate_rep.game_indices.into_iter().next().ok_or_else(|| "game_indices missing in ItemDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in ItemDetail".to_string())?,
            held_by_pokemon: intermediate_rep.held_by_pokemon.into_iter().next().ok_or_else(|| "held_by_pokemon missing in ItemDetail".to_string())?,
            sprites: intermediate_rep.sprites.into_iter().next().ok_or_else(|| "sprites missing in ItemDetail".to_string())?,
            baby_trigger_for: intermediate_rep.baby_trigger_for.into_iter().next().ok_or_else(|| "baby_trigger_for missing in ItemDetail".to_string())?,
            machines: intermediate_rep.machines.into_iter().next().ok_or_else(|| "machines missing in ItemDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDetailBabyTriggerFor {
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl ItemDetailBabyTriggerFor {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> ItemDetailBabyTriggerFor {
        ItemDetailBabyTriggerFor {
 url,
        }
    }
}

/// Converts the ItemDetailBabyTriggerFor value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDetailBabyTriggerFor {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDetailBabyTriggerFor value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDetailBabyTriggerFor {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemDetailBabyTriggerFor".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemDetailBabyTriggerFor".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDetailBabyTriggerFor {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ItemDetailBabyTriggerFor".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDetailBabyTriggerFor> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDetailBabyTriggerFor>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemDetailBabyTriggerFor>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemDetailBabyTriggerFor - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDetailBabyTriggerFor> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemDetailBabyTriggerFor as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemDetailBabyTriggerFor - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDetailHeldByPokemonInner {
    #[serde(rename = "pokemon")]
          #[validate(nested)]
    pub pokemon: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "version-details")]
          #[validate(nested)]
    pub version_details: Vec<models::ItemDetailHeldByPokemonInnerVersionDetailsInner>,

}



impl ItemDetailHeldByPokemonInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(pokemon: models::AbilityDetailPokemonInnerPokemon, version_details: Vec<models::ItemDetailHeldByPokemonInnerVersionDetailsInner>, ) -> ItemDetailHeldByPokemonInner {
        ItemDetailHeldByPokemonInner {
 pokemon,
 version_details,
        }
    }
}

/// Converts the ItemDetailHeldByPokemonInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDetailHeldByPokemonInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping pokemon in query parameter serialization

            // Skipping version-details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDetailHeldByPokemonInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDetailHeldByPokemonInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pokemon: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub version_details: Vec<Vec<models::ItemDetailHeldByPokemonInnerVersionDetailsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemDetailHeldByPokemonInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pokemon" => intermediate_rep.pokemon.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "version-details" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemDetailHeldByPokemonInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemDetailHeldByPokemonInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDetailHeldByPokemonInner {
            pokemon: intermediate_rep.pokemon.into_iter().next().ok_or_else(|| "pokemon missing in ItemDetailHeldByPokemonInner".to_string())?,
            version_details: intermediate_rep.version_details.into_iter().next().ok_or_else(|| "version-details missing in ItemDetailHeldByPokemonInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDetailHeldByPokemonInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDetailHeldByPokemonInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemDetailHeldByPokemonInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemDetailHeldByPokemonInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDetailHeldByPokemonInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemDetailHeldByPokemonInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemDetailHeldByPokemonInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDetailHeldByPokemonInnerVersionDetailsInner {
    #[serde(rename = "rarity")]
    pub rarity: i32,

    #[serde(rename = "version")]
          #[validate(nested)]
    pub version: models::AbilityDetailPokemonInnerPokemon,

}



impl ItemDetailHeldByPokemonInnerVersionDetailsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(rarity: i32, version: models::AbilityDetailPokemonInnerPokemon, ) -> ItemDetailHeldByPokemonInnerVersionDetailsInner {
        ItemDetailHeldByPokemonInnerVersionDetailsInner {
 rarity,
 version,
        }
    }
}

/// Converts the ItemDetailHeldByPokemonInnerVersionDetailsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDetailHeldByPokemonInnerVersionDetailsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("rarity".to_string()),
            Some(self.rarity.to_string()),

            // Skipping version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDetailHeldByPokemonInnerVersionDetailsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDetailHeldByPokemonInnerVersionDetailsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rarity: Vec<i32>,
            pub version: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemDetailHeldByPokemonInnerVersionDetailsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rarity" => intermediate_rep.rarity.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemDetailHeldByPokemonInnerVersionDetailsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDetailHeldByPokemonInnerVersionDetailsInner {
            rarity: intermediate_rep.rarity.into_iter().next().ok_or_else(|| "rarity missing in ItemDetailHeldByPokemonInnerVersionDetailsInner".to_string())?,
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| "version missing in ItemDetailHeldByPokemonInnerVersionDetailsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDetailHeldByPokemonInnerVersionDetailsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDetailHeldByPokemonInnerVersionDetailsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemDetailHeldByPokemonInnerVersionDetailsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemDetailHeldByPokemonInnerVersionDetailsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDetailHeldByPokemonInnerVersionDetailsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemDetailHeldByPokemonInnerVersionDetailsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemDetailHeldByPokemonInnerVersionDetailsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDetailMachinesInner {
    #[serde(rename = "machine")]
          #[validate(custom(function = "check_xss_string"))]
    pub machine: String,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::AbilityDetailPokemonInnerPokemon,

}



impl ItemDetailMachinesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(machine: String, version_group: models::AbilityDetailPokemonInnerPokemon, ) -> ItemDetailMachinesInner {
        ItemDetailMachinesInner {
 machine,
 version_group,
        }
    }
}

/// Converts the ItemDetailMachinesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDetailMachinesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("machine".to_string()),
            Some(self.machine.to_string()),

            // Skipping version_group in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDetailMachinesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDetailMachinesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub machine: Vec<String>,
            pub version_group: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemDetailMachinesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "machine" => intermediate_rep.machine.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemDetailMachinesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDetailMachinesInner {
            machine: intermediate_rep.machine.into_iter().next().ok_or_else(|| "machine missing in ItemDetailMachinesInner".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in ItemDetailMachinesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDetailMachinesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDetailMachinesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemDetailMachinesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemDetailMachinesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDetailMachinesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemDetailMachinesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemDetailMachinesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemDetailSprites {
    #[serde(rename = "default")]
          #[validate(custom(function = "check_xss_string"))]
    pub default: String,

}



impl ItemDetailSprites {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(default: String, ) -> ItemDetailSprites {
        ItemDetailSprites {
 default,
        }
    }
}

/// Converts the ItemDetailSprites value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemDetailSprites {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("default".to_string()),
            Some(self.default.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemDetailSprites value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemDetailSprites {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemDetailSprites".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "default" => intermediate_rep.default.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemDetailSprites".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemDetailSprites {
            default: intermediate_rep.default.into_iter().next().ok_or_else(|| "default missing in ItemDetailSprites".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemDetailSprites> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemDetailSprites>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemDetailSprites>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemDetailSprites - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemDetailSprites> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemDetailSprites as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemDetailSprites - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemEffectText {
    #[serde(rename = "effect")]
    #[validate(
            length(max = 6000),
          custom(function = "check_xss_string"),
    )]
    pub effect: String,

    #[serde(rename = "short_effect")]
    #[validate(
            length(max = 300),
          custom(function = "check_xss_string"),
    )]
    pub short_effect: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ItemEffectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect: String, short_effect: String, language: models::LanguageSummary, ) -> ItemEffectText {
        ItemEffectText {
 effect,
 short_effect,
 language,
        }
    }
}

/// Converts the ItemEffectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemEffectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("effect".to_string()),
            Some(self.effect.to_string()),


            Some("short_effect".to_string()),
            Some(self.short_effect.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemEffectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemEffectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect: Vec<String>,
            pub short_effect: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemEffectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "effect" => intermediate_rep.effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "short_effect" => intermediate_rep.short_effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemEffectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemEffectText {
            effect: intermediate_rep.effect.into_iter().next().ok_or_else(|| "effect missing in ItemEffectText".to_string())?,
            short_effect: intermediate_rep.short_effect.into_iter().next().ok_or_else(|| "short_effect missing in ItemEffectText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ItemEffectText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemEffectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemEffectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemEffectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemEffectText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemEffectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemEffectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemEffectText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemFlavorText {
    #[serde(rename = "text")]
          #[validate(custom(function = "check_xss_string"))]
    pub text: String,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::VersionGroupSummary,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ItemFlavorText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(text: String, version_group: models::VersionGroupSummary, language: models::LanguageSummary, ) -> ItemFlavorText {
        ItemFlavorText {
 text,
 version_group,
 language,
        }
    }
}

/// Converts the ItemFlavorText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemFlavorText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("text".to_string()),
            Some(self.text.to_string()),

            // Skipping version_group in query parameter serialization

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemFlavorText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemFlavorText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub text: Vec<String>,
            pub version_group: Vec<models::VersionGroupSummary>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemFlavorText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "text" => intermediate_rep.text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::VersionGroupSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemFlavorText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemFlavorText {
            text: intermediate_rep.text.into_iter().next().ok_or_else(|| "text missing in ItemFlavorText".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in ItemFlavorText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ItemFlavorText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemFlavorText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemFlavorText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemFlavorText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemFlavorText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemFlavorText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemFlavorText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemFlavorText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemFlingEffectDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "effect_entries")]
          #[validate(nested)]
    pub effect_entries: Vec<models::ItemFlingEffectEffectText>,

    #[serde(rename = "items")]
          #[validate(nested)]
    pub items: Vec<models::ItemSummary>,

}



impl ItemFlingEffectDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, effect_entries: Vec<models::ItemFlingEffectEffectText>, items: Vec<models::ItemSummary>, ) -> ItemFlingEffectDetail {
        ItemFlingEffectDetail {
 id,
 name,
 effect_entries,
 items,
        }
    }
}

/// Converts the ItemFlingEffectDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemFlingEffectDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping effect_entries in query parameter serialization

            // Skipping items in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemFlingEffectDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemFlingEffectDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub effect_entries: Vec<Vec<models::ItemFlingEffectEffectText>>,
            pub items: Vec<Vec<models::ItemSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemFlingEffectDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "effect_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemFlingEffectDetail".to_string()),
                    "items" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemFlingEffectDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemFlingEffectDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemFlingEffectDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ItemFlingEffectDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemFlingEffectDetail".to_string())?,
            effect_entries: intermediate_rep.effect_entries.into_iter().next().ok_or_else(|| "effect_entries missing in ItemFlingEffectDetail".to_string())?,
            items: intermediate_rep.items.into_iter().next().ok_or_else(|| "items missing in ItemFlingEffectDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemFlingEffectDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemFlingEffectDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemFlingEffectDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemFlingEffectDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemFlingEffectDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemFlingEffectDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemFlingEffectDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemFlingEffectEffectText {
    #[serde(rename = "effect")]
    #[validate(
            length(max = 6000),
          custom(function = "check_xss_string"),
    )]
    pub effect: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ItemFlingEffectEffectText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect: String, language: models::LanguageSummary, ) -> ItemFlingEffectEffectText {
        ItemFlingEffectEffectText {
 effect,
 language,
        }
    }
}

/// Converts the ItemFlingEffectEffectText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemFlingEffectEffectText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("effect".to_string()),
            Some(self.effect.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemFlingEffectEffectText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemFlingEffectEffectText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemFlingEffectEffectText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "effect" => intermediate_rep.effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemFlingEffectEffectText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemFlingEffectEffectText {
            effect: intermediate_rep.effect.into_iter().next().ok_or_else(|| "effect missing in ItemFlingEffectEffectText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ItemFlingEffectEffectText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemFlingEffectEffectText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemFlingEffectEffectText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemFlingEffectEffectText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemFlingEffectEffectText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemFlingEffectEffectText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemFlingEffectEffectText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemFlingEffectEffectText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemFlingEffectSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl ItemFlingEffectSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> ItemFlingEffectSummary {
        ItemFlingEffectSummary {
 name,
 url,
        }
    }
}

/// Converts the ItemFlingEffectSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemFlingEffectSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemFlingEffectSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemFlingEffectSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemFlingEffectSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemFlingEffectSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemFlingEffectSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemFlingEffectSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ItemFlingEffectSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemFlingEffectSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemFlingEffectSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemFlingEffectSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemFlingEffectSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemFlingEffectSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemFlingEffectSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemFlingEffectSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemGameIndex {
    #[serde(rename = "game_index")]
    pub game_index: i32,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::GenerationSummary,

}



impl ItemGameIndex {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(game_index: i32, generation: models::GenerationSummary, ) -> ItemGameIndex {
        ItemGameIndex {
 game_index,
 generation,
        }
    }
}

/// Converts the ItemGameIndex value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemGameIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("game_index".to_string()),
            Some(self.game_index.to_string()),

            // Skipping generation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemGameIndex value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemGameIndex {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub game_index: Vec<i32>,
            pub generation: Vec<models::GenerationSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemGameIndex".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "game_index" => intermediate_rep.game_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemGameIndex".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemGameIndex {
            game_index: intermediate_rep.game_index.into_iter().next().ok_or_else(|| "game_index missing in ItemGameIndex".to_string())?,
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in ItemGameIndex".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemGameIndex> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemGameIndex>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemGameIndex>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemGameIndex - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemGameIndex> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemGameIndex as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemGameIndex - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ItemName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> ItemName {
        ItemName {
 name,
 language,
        }
    }
}

/// Converts the ItemName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ItemName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemPocketDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "categories")]
          #[validate(nested)]
    pub categories: Vec<models::ItemCategorySummary>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::ItemPocketName>,

}



impl ItemPocketDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, categories: Vec<models::ItemCategorySummary>, names: Vec<models::ItemPocketName>, ) -> ItemPocketDetail {
        ItemPocketDetail {
 id,
 name,
 categories,
 names,
        }
    }
}

/// Converts the ItemPocketDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemPocketDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping categories in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemPocketDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemPocketDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub categories: Vec<Vec<models::ItemCategorySummary>>,
            pub names: Vec<Vec<models::ItemPocketName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemPocketDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "categories" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemPocketDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in ItemPocketDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemPocketDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemPocketDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in ItemPocketDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemPocketDetail".to_string())?,
            categories: intermediate_rep.categories.into_iter().next().ok_or_else(|| "categories missing in ItemPocketDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in ItemPocketDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemPocketDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemPocketDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemPocketDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemPocketDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemPocketDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemPocketDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemPocketDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemPocketName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl ItemPocketName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> ItemPocketName {
        ItemPocketName {
 name,
 language,
        }
    }
}

/// Converts the ItemPocketName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemPocketName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemPocketName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemPocketName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemPocketName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemPocketName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemPocketName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemPocketName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in ItemPocketName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemPocketName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemPocketName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemPocketName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemPocketName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemPocketName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemPocketName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemPocketName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemPocketSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl ItemPocketSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> ItemPocketSummary {
        ItemPocketSummary {
 name,
 url,
        }
    }
}

/// Converts the ItemPocketSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemPocketSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemPocketSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemPocketSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemPocketSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemPocketSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemPocketSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemPocketSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ItemPocketSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemPocketSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemPocketSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemPocketSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemPocketSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemPocketSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemPocketSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemPocketSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct ItemSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl ItemSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> ItemSummary {
        ItemSummary {
 name,
 url,
        }
    }
}

/// Converts the ItemSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for ItemSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a ItemSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for ItemSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing ItemSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing ItemSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(ItemSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in ItemSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in ItemSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<ItemSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<ItemSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<ItemSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for ItemSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<ItemSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <ItemSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into ItemSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LanguageDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "official")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub official: Option<bool>,

    #[serde(rename = "iso639")]
    #[validate(
            length(max = 10),
          custom(function = "check_xss_string"),
    )]
    pub iso639: String,

    #[serde(rename = "iso3166")]
    #[validate(
            length(max = 2),
          custom(function = "check_xss_string"),
    )]
    pub iso3166: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::LanguageName>,

}



impl LanguageDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, iso639: String, iso3166: String, names: Vec<models::LanguageName>, ) -> LanguageDetail {
        LanguageDetail {
 id,
 name,
 official: None,
 iso639,
 iso3166,
 names,
        }
    }
}

/// Converts the LanguageDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LanguageDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.official.as_ref().map(|official| {
                [
                    "official".to_string(),
                    official.to_string(),
                ].join(",")
            }),


            Some("iso639".to_string()),
            Some(self.iso639.to_string()),


            Some("iso3166".to_string()),
            Some(self.iso3166.to_string()),

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LanguageDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LanguageDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub official: Vec<bool>,
            pub iso639: Vec<String>,
            pub iso3166: Vec<String>,
            pub names: Vec<Vec<models::LanguageName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LanguageDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "official" => intermediate_rep.official.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iso639" => intermediate_rep.iso639.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "iso3166" => intermediate_rep.iso3166.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in LanguageDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LanguageDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LanguageDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in LanguageDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LanguageDetail".to_string())?,
            official: intermediate_rep.official.into_iter().next(),
            iso639: intermediate_rep.iso639.into_iter().next().ok_or_else(|| "iso639 missing in LanguageDetail".to_string())?,
            iso3166: intermediate_rep.iso3166.into_iter().next().ok_or_else(|| "iso3166 missing in LanguageDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in LanguageDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LanguageDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LanguageDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LanguageDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LanguageDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LanguageDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LanguageDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LanguageDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LanguageName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl LanguageName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> LanguageName {
        LanguageName {
 name,
 language,
        }
    }
}

/// Converts the LanguageName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LanguageName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LanguageName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LanguageName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LanguageName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LanguageName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LanguageName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LanguageName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in LanguageName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LanguageName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LanguageName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LanguageName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LanguageName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LanguageName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LanguageName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LanguageName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LanguageSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl LanguageSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> LanguageSummary {
        LanguageSummary {
 name,
 url,
        }
    }
}

/// Converts the LanguageSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LanguageSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LanguageSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LanguageSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LanguageSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LanguageSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LanguageSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LanguageSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in LanguageSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LanguageSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LanguageSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LanguageSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LanguageSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LanguageSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LanguageSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LanguageSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "game_index")]
    pub game_index: i32,

    #[serde(rename = "encounter_method_rates")]
          #[validate(nested)]
    pub encounter_method_rates: Vec<models::LocationAreaDetailEncounterMethodRatesInner>,

    #[serde(rename = "location")]
          #[validate(nested)]
    pub location: models::LocationSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::LocationAreaName>,

    #[serde(rename = "pokemon_encounters")]
          #[validate(nested)]
    pub pokemon_encounters: Vec<models::LocationAreaDetailPokemonEncountersInner>,

}



impl LocationAreaDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, game_index: i32, encounter_method_rates: Vec<models::LocationAreaDetailEncounterMethodRatesInner>, location: models::LocationSummary, names: Vec<models::LocationAreaName>, pokemon_encounters: Vec<models::LocationAreaDetailPokemonEncountersInner>, ) -> LocationAreaDetail {
        LocationAreaDetail {
 id,
 name,
 game_index,
 encounter_method_rates,
 location,
 names,
 pokemon_encounters,
        }
    }
}

/// Converts the LocationAreaDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationAreaDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("game_index".to_string()),
            Some(self.game_index.to_string()),

            // Skipping encounter_method_rates in query parameter serialization

            // Skipping location in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping pokemon_encounters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub game_index: Vec<i32>,
            pub encounter_method_rates: Vec<Vec<models::LocationAreaDetailEncounterMethodRatesInner>>,
            pub location: Vec<models::LocationSummary>,
            pub names: Vec<Vec<models::LocationAreaName>>,
            pub pokemon_encounters: Vec<Vec<models::LocationAreaDetailPokemonEncountersInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationAreaDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "game_index" => intermediate_rep.game_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "encounter_method_rates" => return std::result::Result::Err("Parsing a container in this style is not supported in LocationAreaDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "location" => intermediate_rep.location.push(<models::LocationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in LocationAreaDetail".to_string()),
                    "pokemon_encounters" => return std::result::Result::Err("Parsing a container in this style is not supported in LocationAreaDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationAreaDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in LocationAreaDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LocationAreaDetail".to_string())?,
            game_index: intermediate_rep.game_index.into_iter().next().ok_or_else(|| "game_index missing in LocationAreaDetail".to_string())?,
            encounter_method_rates: intermediate_rep.encounter_method_rates.into_iter().next().ok_or_else(|| "encounter_method_rates missing in LocationAreaDetail".to_string())?,
            location: intermediate_rep.location.into_iter().next().ok_or_else(|| "location missing in LocationAreaDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in LocationAreaDetail".to_string())?,
            pokemon_encounters: intermediate_rep.pokemon_encounters.into_iter().next().ok_or_else(|| "pokemon_encounters missing in LocationAreaDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationAreaDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationAreaDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationAreaDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationAreaDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationAreaDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaDetailEncounterMethodRatesInner {
    #[serde(rename = "encounter_method")]
          #[validate(nested)]
    pub encounter_method: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "version_details")]
          #[validate(nested)]
    pub version_details: Vec<models::LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner>,

}



impl LocationAreaDetailEncounterMethodRatesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(encounter_method: models::AbilityDetailPokemonInnerPokemon, version_details: Vec<models::LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner>, ) -> LocationAreaDetailEncounterMethodRatesInner {
        LocationAreaDetailEncounterMethodRatesInner {
 encounter_method,
 version_details,
        }
    }
}

/// Converts the LocationAreaDetailEncounterMethodRatesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationAreaDetailEncounterMethodRatesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping encounter_method in query parameter serialization

            // Skipping version_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaDetailEncounterMethodRatesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaDetailEncounterMethodRatesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub encounter_method: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub version_details: Vec<Vec<models::LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationAreaDetailEncounterMethodRatesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "encounter_method" => intermediate_rep.encounter_method.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "version_details" => return std::result::Result::Err("Parsing a container in this style is not supported in LocationAreaDetailEncounterMethodRatesInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationAreaDetailEncounterMethodRatesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaDetailEncounterMethodRatesInner {
            encounter_method: intermediate_rep.encounter_method.into_iter().next().ok_or_else(|| "encounter_method missing in LocationAreaDetailEncounterMethodRatesInner".to_string())?,
            version_details: intermediate_rep.version_details.into_iter().next().ok_or_else(|| "version_details missing in LocationAreaDetailEncounterMethodRatesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaDetailEncounterMethodRatesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaDetailEncounterMethodRatesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationAreaDetailEncounterMethodRatesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationAreaDetailEncounterMethodRatesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationAreaDetailEncounterMethodRatesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationAreaDetailEncounterMethodRatesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationAreaDetailEncounterMethodRatesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner {
    #[serde(rename = "rate")]
    pub rate: i32,

    #[serde(rename = "version")]
          #[validate(nested)]
    pub version: models::AbilityDetailPokemonInnerPokemon,

}



impl LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(rate: i32, version: models::AbilityDetailPokemonInnerPokemon, ) -> LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner {
        LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner {
 rate,
 version,
        }
    }
}

/// Converts the LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("rate".to_string()),
            Some(self.rate.to_string()),

            // Skipping version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub rate: Vec<i32>,
            pub version: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "rate" => intermediate_rep.rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner {
            rate: intermediate_rep.rate.into_iter().next().ok_or_else(|| "rate missing in LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner".to_string())?,
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| "version missing in LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaDetailPokemonEncountersInner {
    #[serde(rename = "pokemon")]
          #[validate(nested)]
    pub pokemon: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "version_details")]
          #[validate(nested)]
    pub version_details: Vec<models::LocationAreaDetailPokemonEncountersInnerVersionDetailsInner>,

}



impl LocationAreaDetailPokemonEncountersInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(pokemon: models::AbilityDetailPokemonInnerPokemon, version_details: Vec<models::LocationAreaDetailPokemonEncountersInnerVersionDetailsInner>, ) -> LocationAreaDetailPokemonEncountersInner {
        LocationAreaDetailPokemonEncountersInner {
 pokemon,
 version_details,
        }
    }
}

/// Converts the LocationAreaDetailPokemonEncountersInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationAreaDetailPokemonEncountersInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping pokemon in query parameter serialization

            // Skipping version_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaDetailPokemonEncountersInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaDetailPokemonEncountersInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub pokemon: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub version_details: Vec<Vec<models::LocationAreaDetailPokemonEncountersInnerVersionDetailsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationAreaDetailPokemonEncountersInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "pokemon" => intermediate_rep.pokemon.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "version_details" => return std::result::Result::Err("Parsing a container in this style is not supported in LocationAreaDetailPokemonEncountersInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationAreaDetailPokemonEncountersInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaDetailPokemonEncountersInner {
            pokemon: intermediate_rep.pokemon.into_iter().next().ok_or_else(|| "pokemon missing in LocationAreaDetailPokemonEncountersInner".to_string())?,
            version_details: intermediate_rep.version_details.into_iter().next().ok_or_else(|| "version_details missing in LocationAreaDetailPokemonEncountersInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationAreaDetailPokemonEncountersInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationAreaDetailPokemonEncountersInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationAreaDetailPokemonEncountersInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaDetailPokemonEncountersInnerVersionDetailsInner {
    #[serde(rename = "version")]
          #[validate(nested)]
    pub version: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "max_chance")]
    pub max_chance: i32,

    #[serde(rename = "encounter_details")]
          #[validate(nested)]
    pub encounter_details: models::LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails,

}



impl LocationAreaDetailPokemonEncountersInnerVersionDetailsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(version: models::AbilityDetailPokemonInnerPokemon, max_chance: i32, encounter_details: models::LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails, ) -> LocationAreaDetailPokemonEncountersInnerVersionDetailsInner {
        LocationAreaDetailPokemonEncountersInnerVersionDetailsInner {
 version,
 max_chance,
 encounter_details,
        }
    }
}

/// Converts the LocationAreaDetailPokemonEncountersInnerVersionDetailsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationAreaDetailPokemonEncountersInnerVersionDetailsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping version in query parameter serialization


            Some("max_chance".to_string()),
            Some(self.max_chance.to_string()),

            // Skipping encounter_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaDetailPokemonEncountersInnerVersionDetailsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaDetailPokemonEncountersInnerVersionDetailsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub version: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub max_chance: Vec<i32>,
            pub encounter_details: Vec<models::LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationAreaDetailPokemonEncountersInnerVersionDetailsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_chance" => intermediate_rep.max_chance.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "encounter_details" => intermediate_rep.encounter_details.push(<models::LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationAreaDetailPokemonEncountersInnerVersionDetailsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaDetailPokemonEncountersInnerVersionDetailsInner {
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| "version missing in LocationAreaDetailPokemonEncountersInnerVersionDetailsInner".to_string())?,
            max_chance: intermediate_rep.max_chance.into_iter().next().ok_or_else(|| "max_chance missing in LocationAreaDetailPokemonEncountersInnerVersionDetailsInner".to_string())?,
            encounter_details: intermediate_rep.encounter_details.into_iter().next().ok_or_else(|| "encounter_details missing in LocationAreaDetailPokemonEncountersInnerVersionDetailsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInnerVersionDetailsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInnerVersionDetailsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInnerVersionDetailsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationAreaDetailPokemonEncountersInnerVersionDetailsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInnerVersionDetailsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationAreaDetailPokemonEncountersInnerVersionDetailsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationAreaDetailPokemonEncountersInnerVersionDetailsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails {
    #[serde(rename = "min_level")]
    pub min_level: i32,

    #[serde(rename = "max_level")]
    pub max_level: i32,

    #[serde(rename = "condition_values")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub condition_values: Option<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "chance")]
    pub chance: i32,

    #[serde(rename = "method")]
          #[validate(nested)]
    pub method: models::AbilityDetailPokemonInnerPokemon,

}



impl LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(min_level: i32, max_level: i32, chance: i32, method: models::AbilityDetailPokemonInnerPokemon, ) -> LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails {
        LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails {
 min_level,
 max_level,
 condition_values: None,
 chance,
 method,
        }
    }
}

/// Converts the LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("min_level".to_string()),
            Some(self.min_level.to_string()),


            Some("max_level".to_string()),
            Some(self.max_level.to_string()),

            // Skipping condition_values in query parameter serialization


            Some("chance".to_string()),
            Some(self.chance.to_string()),

            // Skipping method in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub min_level: Vec<i32>,
            pub max_level: Vec<i32>,
            pub condition_values: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub chance: Vec<i32>,
            pub method: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "min_level" => intermediate_rep.min_level.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "max_level" => intermediate_rep.max_level.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "condition_values" => intermediate_rep.condition_values.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "chance" => intermediate_rep.chance.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "method" => intermediate_rep.method.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails {
            min_level: intermediate_rep.min_level.into_iter().next().ok_or_else(|| "min_level missing in LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails".to_string())?,
            max_level: intermediate_rep.max_level.into_iter().next().ok_or_else(|| "max_level missing in LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails".to_string())?,
            condition_values: intermediate_rep.condition_values.into_iter().next(),
            chance: intermediate_rep.chance.into_iter().next().ok_or_else(|| "chance missing in LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails".to_string())?,
            method: intermediate_rep.method.into_iter().next().ok_or_else(|| "method missing in LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl LocationAreaName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> LocationAreaName {
        LocationAreaName {
 name,
 language,
        }
    }
}

/// Converts the LocationAreaName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationAreaName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationAreaName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationAreaName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LocationAreaName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in LocationAreaName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationAreaName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationAreaName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationAreaName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationAreaName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationAreaName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationAreaSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl LocationAreaSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> LocationAreaSummary {
        LocationAreaSummary {
 name,
 url,
        }
    }
}

/// Converts the LocationAreaSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationAreaSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationAreaSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationAreaSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationAreaSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationAreaSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationAreaSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LocationAreaSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in LocationAreaSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationAreaSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationAreaSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationAreaSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationAreaSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationAreaSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationAreaSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationAreaSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "region")]
          #[validate(nested)]
    pub region: models::RegionSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::LocationName>,

    #[serde(rename = "game_indices")]
          #[validate(nested)]
    pub game_indices: Vec<models::LocationGameIndex>,

    #[serde(rename = "areas")]
          #[validate(nested)]
    pub areas: Vec<models::LocationAreaSummary>,

}



impl LocationDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, region: models::RegionSummary, names: Vec<models::LocationName>, game_indices: Vec<models::LocationGameIndex>, areas: Vec<models::LocationAreaSummary>, ) -> LocationDetail {
        LocationDetail {
 id,
 name,
 region,
 names,
 game_indices,
 areas,
        }
    }
}

/// Converts the LocationDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping region in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping game_indices in query parameter serialization

            // Skipping areas in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub region: Vec<models::RegionSummary>,
            pub names: Vec<Vec<models::LocationName>>,
            pub game_indices: Vec<Vec<models::LocationGameIndex>>,
            pub areas: Vec<Vec<models::LocationAreaSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<models::RegionSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in LocationDetail".to_string()),
                    "game_indices" => return std::result::Result::Err("Parsing a container in this style is not supported in LocationDetail".to_string()),
                    "areas" => return std::result::Result::Err("Parsing a container in this style is not supported in LocationDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in LocationDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LocationDetail".to_string())?,
            region: intermediate_rep.region.into_iter().next().ok_or_else(|| "region missing in LocationDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in LocationDetail".to_string())?,
            game_indices: intermediate_rep.game_indices.into_iter().next().ok_or_else(|| "game_indices missing in LocationDetail".to_string())?,
            areas: intermediate_rep.areas.into_iter().next().ok_or_else(|| "areas missing in LocationDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationGameIndex {
    #[serde(rename = "game_index")]
    pub game_index: i32,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::GenerationSummary,

}



impl LocationGameIndex {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(game_index: i32, generation: models::GenerationSummary, ) -> LocationGameIndex {
        LocationGameIndex {
 game_index,
 generation,
        }
    }
}

/// Converts the LocationGameIndex value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationGameIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("game_index".to_string()),
            Some(self.game_index.to_string()),

            // Skipping generation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationGameIndex value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationGameIndex {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub game_index: Vec<i32>,
            pub generation: Vec<models::GenerationSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationGameIndex".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "game_index" => intermediate_rep.game_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationGameIndex".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationGameIndex {
            game_index: intermediate_rep.game_index.into_iter().next().ok_or_else(|| "game_index missing in LocationGameIndex".to_string())?,
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in LocationGameIndex".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationGameIndex> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationGameIndex>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationGameIndex>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationGameIndex - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationGameIndex> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationGameIndex as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationGameIndex - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl LocationName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> LocationName {
        LocationName {
 name,
 language,
        }
    }
}

/// Converts the LocationName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LocationName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in LocationName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct LocationSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl LocationSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> LocationSummary {
        LocationSummary {
 name,
 url,
        }
    }
}

/// Converts the LocationSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for LocationSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a LocationSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for LocationSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing LocationSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing LocationSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(LocationSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in LocationSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in LocationSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<LocationSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<LocationSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<LocationSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for LocationSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<LocationSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <LocationSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into LocationSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MachineDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "item")]
          #[validate(nested)]
    pub item: models::ItemSummary,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::VersionGroupSummary,

    #[serde(rename = "move")]
          #[validate(nested)]
    pub r_move: models::MoveSummary,

}



impl MachineDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, item: models::ItemSummary, version_group: models::VersionGroupSummary, r_move: models::MoveSummary, ) -> MachineDetail {
        MachineDetail {
 id,
 item,
 version_group,
 r_move,
        }
    }
}

/// Converts the MachineDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MachineDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),

            // Skipping item in query parameter serialization

            // Skipping version_group in query parameter serialization

            // Skipping move in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MachineDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MachineDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub item: Vec<models::ItemSummary>,
            pub version_group: Vec<models::VersionGroupSummary>,
            pub r_move: Vec<models::MoveSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MachineDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "item" => intermediate_rep.item.push(<models::ItemSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::VersionGroupSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "move" => intermediate_rep.r_move.push(<models::MoveSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MachineDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MachineDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MachineDetail".to_string())?,
            item: intermediate_rep.item.into_iter().next().ok_or_else(|| "item missing in MachineDetail".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in MachineDetail".to_string())?,
            r_move: intermediate_rep.r_move.into_iter().next().ok_or_else(|| "move missing in MachineDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MachineDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MachineDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MachineDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MachineDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MachineDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MachineDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MachineDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MachineSummary {
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MachineSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> MachineSummary {
        MachineSummary {
 url,
        }
    }
}

/// Converts the MachineSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MachineSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MachineSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MachineSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MachineSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MachineSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MachineSummary {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MachineSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MachineSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MachineSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MachineSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MachineSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MachineSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MachineSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MachineSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveBattleStyleDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::MoveBattleStyleName>,

}



impl MoveBattleStyleDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::MoveBattleStyleName>, ) -> MoveBattleStyleDetail {
        MoveBattleStyleDetail {
 id,
 name,
 names,
        }
    }
}

/// Converts the MoveBattleStyleDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveBattleStyleDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveBattleStyleDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveBattleStyleDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub names: Vec<Vec<models::MoveBattleStyleName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveBattleStyleDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveBattleStyleDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveBattleStyleDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveBattleStyleDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MoveBattleStyleDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveBattleStyleDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in MoveBattleStyleDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveBattleStyleDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveBattleStyleDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveBattleStyleDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveBattleStyleDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveBattleStyleDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveBattleStyleDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveBattleStyleDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveBattleStyleName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveBattleStyleName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> MoveBattleStyleName {
        MoveBattleStyleName {
 name,
 language,
        }
    }
}

/// Converts the MoveBattleStyleName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveBattleStyleName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveBattleStyleName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveBattleStyleName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveBattleStyleName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveBattleStyleName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveBattleStyleName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveBattleStyleName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveBattleStyleName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveBattleStyleName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveBattleStyleName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveBattleStyleName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveBattleStyleName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveBattleStyleName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveBattleStyleName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveBattleStyleName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveBattleStyleSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MoveBattleStyleSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> MoveBattleStyleSummary {
        MoveBattleStyleSummary {
 name,
 url,
        }
    }
}

/// Converts the MoveBattleStyleSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveBattleStyleSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveBattleStyleSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveBattleStyleSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveBattleStyleSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveBattleStyleSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveBattleStyleSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveBattleStyleSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MoveBattleStyleSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveBattleStyleSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveBattleStyleSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveBattleStyleSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveBattleStyleSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveBattleStyleSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveBattleStyleSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveBattleStyleSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveChange {
    #[serde(rename = "accuracy")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accuracy: Option<Nullable<i32>>,

    #[serde(rename = "power")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub power: Option<Nullable<i32>>,

    #[serde(rename = "pp")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pp: Option<Nullable<i32>>,

    #[serde(rename = "effect_chance")]
    pub effect_chance: i32,

    #[serde(rename = "effect_entries")]
          #[validate(nested)]
    pub effect_entries: Vec<models::MoveChangeEffectEntriesInner>,

    #[serde(rename = "type")]
          #[validate(nested)]
    pub r_type: models::TypeSummary,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::VersionGroupSummary,

}



impl MoveChange {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect_chance: i32, effect_entries: Vec<models::MoveChangeEffectEntriesInner>, r_type: models::TypeSummary, version_group: models::VersionGroupSummary, ) -> MoveChange {
        MoveChange {
 accuracy: None,
 power: None,
 pp: None,
 effect_chance,
 effect_entries,
 r_type,
 version_group,
        }
    }
}

/// Converts the MoveChange value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveChange {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.accuracy.as_ref().map(|accuracy| {
                [
                    "accuracy".to_string(),
                    accuracy.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.power.as_ref().map(|power| {
                [
                    "power".to_string(),
                    power.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.pp.as_ref().map(|pp| {
                [
                    "pp".to_string(),
                    pp.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("effect_chance".to_string()),
            Some(self.effect_chance.to_string()),

            // Skipping effect_entries in query parameter serialization

            // Skipping type in query parameter serialization

            // Skipping version_group in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveChange value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveChange {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub accuracy: Vec<i32>,
            pub power: Vec<i32>,
            pub pp: Vec<i32>,
            pub effect_chance: Vec<i32>,
            pub effect_entries: Vec<Vec<models::MoveChangeEffectEntriesInner>>,
            pub r_type: Vec<models::TypeSummary>,
            pub version_group: Vec<models::VersionGroupSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveChange".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "accuracy" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveChange".to_string()),
                    "power" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveChange".to_string()),
                    "pp" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveChange".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "effect_chance" => intermediate_rep.effect_chance.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "effect_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveChange".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<models::TypeSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::VersionGroupSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveChange".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveChange {
            accuracy: std::result::Result::Err("Nullable types not supported in MoveChange".to_string())?,
            power: std::result::Result::Err("Nullable types not supported in MoveChange".to_string())?,
            pp: std::result::Result::Err("Nullable types not supported in MoveChange".to_string())?,
            effect_chance: intermediate_rep.effect_chance.into_iter().next().ok_or_else(|| "effect_chance missing in MoveChange".to_string())?,
            effect_entries: intermediate_rep.effect_entries.into_iter().next().ok_or_else(|| "effect_entries missing in MoveChange".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MoveChange".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in MoveChange".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveChange> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveChange>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveChange>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveChange - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveChange> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveChange as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveChange - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveChangeEffectEntriesInner {
    #[serde(rename = "effect")]
          #[validate(custom(function = "check_xss_string"))]
    pub effect: String,

    #[serde(rename = "short_effect")]
          #[validate(custom(function = "check_xss_string"))]
    pub short_effect: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::AbilityDetailPokemonInnerPokemon,

}



impl MoveChangeEffectEntriesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect: String, short_effect: String, language: models::AbilityDetailPokemonInnerPokemon, ) -> MoveChangeEffectEntriesInner {
        MoveChangeEffectEntriesInner {
 effect,
 short_effect,
 language,
        }
    }
}

/// Converts the MoveChangeEffectEntriesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveChangeEffectEntriesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("effect".to_string()),
            Some(self.effect.to_string()),


            Some("short_effect".to_string()),
            Some(self.short_effect.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveChangeEffectEntriesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveChangeEffectEntriesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect: Vec<String>,
            pub short_effect: Vec<String>,
            pub language: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveChangeEffectEntriesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "effect" => intermediate_rep.effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "short_effect" => intermediate_rep.short_effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveChangeEffectEntriesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveChangeEffectEntriesInner {
            effect: intermediate_rep.effect.into_iter().next().ok_or_else(|| "effect missing in MoveChangeEffectEntriesInner".to_string())?,
            short_effect: intermediate_rep.short_effect.into_iter().next().ok_or_else(|| "short_effect missing in MoveChangeEffectEntriesInner".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveChangeEffectEntriesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveChangeEffectEntriesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveChangeEffectEntriesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveChangeEffectEntriesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveChangeEffectEntriesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveChangeEffectEntriesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveChangeEffectEntriesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveChangeEffectEntriesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDamageClassDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveDamageClassDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> MoveDamageClassDescription {
        MoveDamageClassDescription {
 description: None,
 language,
        }
    }
}

/// Converts the MoveDamageClassDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDamageClassDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDamageClassDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDamageClassDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDamageClassDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDamageClassDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDamageClassDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveDamageClassDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDamageClassDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDamageClassDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDamageClassDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDamageClassDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDamageClassDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDamageClassDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDamageClassDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDamageClassDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "descriptions")]
          #[validate(nested)]
    pub descriptions: Vec<models::MoveDamageClassDescription>,

    #[serde(rename = "moves")]
          #[validate(nested)]
    pub moves: Vec<models::MoveSummary>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::MoveDamageClassName>,

}



impl MoveDamageClassDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, descriptions: Vec<models::MoveDamageClassDescription>, moves: Vec<models::MoveSummary>, names: Vec<models::MoveDamageClassName>, ) -> MoveDamageClassDetail {
        MoveDamageClassDetail {
 id,
 name,
 descriptions,
 moves,
 names,
        }
    }
}

/// Converts the MoveDamageClassDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDamageClassDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping descriptions in query parameter serialization

            // Skipping moves in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDamageClassDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDamageClassDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub descriptions: Vec<Vec<models::MoveDamageClassDescription>>,
            pub moves: Vec<Vec<models::MoveSummary>>,
            pub names: Vec<Vec<models::MoveDamageClassName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDamageClassDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDamageClassDetail".to_string()),
                    "moves" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDamageClassDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDamageClassDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDamageClassDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDamageClassDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MoveDamageClassDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveDamageClassDetail".to_string())?,
            descriptions: intermediate_rep.descriptions.into_iter().next().ok_or_else(|| "descriptions missing in MoveDamageClassDetail".to_string())?,
            moves: intermediate_rep.moves.into_iter().next().ok_or_else(|| "moves missing in MoveDamageClassDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in MoveDamageClassDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDamageClassDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDamageClassDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDamageClassDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDamageClassDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDamageClassDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDamageClassDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDamageClassDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDamageClassName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveDamageClassName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> MoveDamageClassName {
        MoveDamageClassName {
 name,
 language,
        }
    }
}

/// Converts the MoveDamageClassName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDamageClassName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDamageClassName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDamageClassName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDamageClassName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDamageClassName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDamageClassName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveDamageClassName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveDamageClassName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDamageClassName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDamageClassName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDamageClassName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDamageClassName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDamageClassName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDamageClassName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDamageClassName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDamageClassSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MoveDamageClassSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> MoveDamageClassSummary {
        MoveDamageClassSummary {
 name,
 url,
        }
    }
}

/// Converts the MoveDamageClassSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDamageClassSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDamageClassSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDamageClassSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDamageClassSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDamageClassSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDamageClassSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveDamageClassSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MoveDamageClassSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDamageClassSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDamageClassSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDamageClassSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDamageClassSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDamageClassSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDamageClassSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDamageClassSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "accuracy")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub accuracy: Option<Nullable<i32>>,

    #[serde(rename = "effect_chance")]
    pub effect_chance: i32,

    #[serde(rename = "pp")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pp: Option<Nullable<i32>>,

    #[serde(rename = "priority")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub priority: Option<Nullable<i32>>,

    #[serde(rename = "power")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub power: Option<Nullable<i32>>,

    #[serde(rename = "contest_combos")]
          #[validate(nested)]
    pub contest_combos: models::MoveDetailContestCombos,

    #[serde(rename = "contest_type")]
          #[validate(nested)]
    pub contest_type: models::ContestTypeSummary,

    #[serde(rename = "contest_effect")]
          #[validate(nested)]
    pub contest_effect: models::ContestEffectSummary,

    #[serde(rename = "damage_class")]
          #[validate(nested)]
    pub damage_class: models::MoveDamageClassSummary,

    #[serde(rename = "effect_entries")]
          #[validate(nested)]
    pub effect_entries: Vec<models::MoveChangeEffectEntriesInner>,

    #[serde(rename = "effect_changes")]
          #[validate(nested)]
    pub effect_changes: Vec<models::MoveDetailEffectChangesInner>,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::GenerationSummary,

    #[serde(rename = "meta")]
          #[validate(nested)]
    pub meta: models::MoveMeta,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::MoveName>,

    #[serde(rename = "past_values")]
          #[validate(nested)]
    pub past_values: Vec<models::MoveChange>,

    #[serde(rename = "stat_changes")]
          #[validate(nested)]
    pub stat_changes: Vec<models::MoveDetailStatChangesInner>,

    #[serde(rename = "super_contest_effect")]
          #[validate(nested)]
    pub super_contest_effect: models::SuperContestEffectSummary,

    #[serde(rename = "target")]
          #[validate(nested)]
    pub target: models::MoveTargetSummary,

    #[serde(rename = "type")]
          #[validate(nested)]
    pub r_type: models::TypeSummary,

    #[serde(rename = "machines")]
          #[validate(nested)]
    pub machines: Vec<models::MoveDetailMachinesInner>,

    #[serde(rename = "flavor_text_entries")]
          #[validate(nested)]
    pub flavor_text_entries: Vec<models::MoveFlavorText>,

    #[serde(rename = "learned_by_pokemon")]
          #[validate(nested)]
    pub learned_by_pokemon: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl MoveDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, effect_chance: i32, contest_combos: models::MoveDetailContestCombos, contest_type: models::ContestTypeSummary, contest_effect: models::ContestEffectSummary, damage_class: models::MoveDamageClassSummary, effect_entries: Vec<models::MoveChangeEffectEntriesInner>, effect_changes: Vec<models::MoveDetailEffectChangesInner>, generation: models::GenerationSummary, meta: models::MoveMeta, names: Vec<models::MoveName>, past_values: Vec<models::MoveChange>, stat_changes: Vec<models::MoveDetailStatChangesInner>, super_contest_effect: models::SuperContestEffectSummary, target: models::MoveTargetSummary, r_type: models::TypeSummary, machines: Vec<models::MoveDetailMachinesInner>, flavor_text_entries: Vec<models::MoveFlavorText>, learned_by_pokemon: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> MoveDetail {
        MoveDetail {
 id,
 name,
 accuracy: None,
 effect_chance,
 pp: None,
 priority: None,
 power: None,
 contest_combos,
 contest_type,
 contest_effect,
 damage_class,
 effect_entries,
 effect_changes,
 generation,
 meta,
 names,
 past_values,
 stat_changes,
 super_contest_effect,
 target,
 r_type,
 machines,
 flavor_text_entries,
 learned_by_pokemon,
        }
    }
}

/// Converts the MoveDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.accuracy.as_ref().map(|accuracy| {
                [
                    "accuracy".to_string(),
                    accuracy.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            Some("effect_chance".to_string()),
            Some(self.effect_chance.to_string()),


            self.pp.as_ref().map(|pp| {
                [
                    "pp".to_string(),
                    pp.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.priority.as_ref().map(|priority| {
                [
                    "priority".to_string(),
                    priority.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.power.as_ref().map(|power| {
                [
                    "power".to_string(),
                    power.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping contest_combos in query parameter serialization

            // Skipping contest_type in query parameter serialization

            // Skipping contest_effect in query parameter serialization

            // Skipping damage_class in query parameter serialization

            // Skipping effect_entries in query parameter serialization

            // Skipping effect_changes in query parameter serialization

            // Skipping generation in query parameter serialization

            // Skipping meta in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping past_values in query parameter serialization

            // Skipping stat_changes in query parameter serialization

            // Skipping super_contest_effect in query parameter serialization

            // Skipping target in query parameter serialization

            // Skipping type in query parameter serialization

            // Skipping machines in query parameter serialization

            // Skipping flavor_text_entries in query parameter serialization

            // Skipping learned_by_pokemon in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub accuracy: Vec<i32>,
            pub effect_chance: Vec<i32>,
            pub pp: Vec<i32>,
            pub priority: Vec<i32>,
            pub power: Vec<i32>,
            pub contest_combos: Vec<models::MoveDetailContestCombos>,
            pub contest_type: Vec<models::ContestTypeSummary>,
            pub contest_effect: Vec<models::ContestEffectSummary>,
            pub damage_class: Vec<models::MoveDamageClassSummary>,
            pub effect_entries: Vec<Vec<models::MoveChangeEffectEntriesInner>>,
            pub effect_changes: Vec<Vec<models::MoveDetailEffectChangesInner>>,
            pub generation: Vec<models::GenerationSummary>,
            pub meta: Vec<models::MoveMeta>,
            pub names: Vec<Vec<models::MoveName>>,
            pub past_values: Vec<Vec<models::MoveChange>>,
            pub stat_changes: Vec<Vec<models::MoveDetailStatChangesInner>>,
            pub super_contest_effect: Vec<models::SuperContestEffectSummary>,
            pub target: Vec<models::MoveTargetSummary>,
            pub r_type: Vec<models::TypeSummary>,
            pub machines: Vec<Vec<models::MoveDetailMachinesInner>>,
            pub flavor_text_entries: Vec<Vec<models::MoveFlavorText>>,
            pub learned_by_pokemon: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "accuracy" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "effect_chance" => intermediate_rep.effect_chance.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pp" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveDetail".to_string()),
                    "priority" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveDetail".to_string()),
                    "power" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "contest_combos" => intermediate_rep.contest_combos.push(<models::MoveDetailContestCombos as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contest_type" => intermediate_rep.contest_type.push(<models::ContestTypeSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "contest_effect" => intermediate_rep.contest_effect.push(<models::ContestEffectSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "damage_class" => intermediate_rep.damage_class.push(<models::MoveDamageClassSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "effect_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetail".to_string()),
                    "effect_changes" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "meta" => intermediate_rep.meta.push(<models::MoveMeta as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetail".to_string()),
                    "past_values" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetail".to_string()),
                    "stat_changes" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "super_contest_effect" => intermediate_rep.super_contest_effect.push(<models::SuperContestEffectSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "target" => intermediate_rep.target.push(<models::MoveTargetSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<models::TypeSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "machines" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetail".to_string()),
                    "flavor_text_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetail".to_string()),
                    "learned_by_pokemon" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MoveDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveDetail".to_string())?,
            accuracy: std::result::Result::Err("Nullable types not supported in MoveDetail".to_string())?,
            effect_chance: intermediate_rep.effect_chance.into_iter().next().ok_or_else(|| "effect_chance missing in MoveDetail".to_string())?,
            pp: std::result::Result::Err("Nullable types not supported in MoveDetail".to_string())?,
            priority: std::result::Result::Err("Nullable types not supported in MoveDetail".to_string())?,
            power: std::result::Result::Err("Nullable types not supported in MoveDetail".to_string())?,
            contest_combos: intermediate_rep.contest_combos.into_iter().next().ok_or_else(|| "contest_combos missing in MoveDetail".to_string())?,
            contest_type: intermediate_rep.contest_type.into_iter().next().ok_or_else(|| "contest_type missing in MoveDetail".to_string())?,
            contest_effect: intermediate_rep.contest_effect.into_iter().next().ok_or_else(|| "contest_effect missing in MoveDetail".to_string())?,
            damage_class: intermediate_rep.damage_class.into_iter().next().ok_or_else(|| "damage_class missing in MoveDetail".to_string())?,
            effect_entries: intermediate_rep.effect_entries.into_iter().next().ok_or_else(|| "effect_entries missing in MoveDetail".to_string())?,
            effect_changes: intermediate_rep.effect_changes.into_iter().next().ok_or_else(|| "effect_changes missing in MoveDetail".to_string())?,
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in MoveDetail".to_string())?,
            meta: intermediate_rep.meta.into_iter().next().ok_or_else(|| "meta missing in MoveDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in MoveDetail".to_string())?,
            past_values: intermediate_rep.past_values.into_iter().next().ok_or_else(|| "past_values missing in MoveDetail".to_string())?,
            stat_changes: intermediate_rep.stat_changes.into_iter().next().ok_or_else(|| "stat_changes missing in MoveDetail".to_string())?,
            super_contest_effect: intermediate_rep.super_contest_effect.into_iter().next().ok_or_else(|| "super_contest_effect missing in MoveDetail".to_string())?,
            target: intermediate_rep.target.into_iter().next().ok_or_else(|| "target missing in MoveDetail".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in MoveDetail".to_string())?,
            machines: intermediate_rep.machines.into_iter().next().ok_or_else(|| "machines missing in MoveDetail".to_string())?,
            flavor_text_entries: intermediate_rep.flavor_text_entries.into_iter().next().ok_or_else(|| "flavor_text_entries missing in MoveDetail".to_string())?,
            learned_by_pokemon: intermediate_rep.learned_by_pokemon.into_iter().next().ok_or_else(|| "learned_by_pokemon missing in MoveDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDetailContestCombos {
    #[serde(rename = "normal")]
          #[validate(nested)]
    pub normal: models::MoveDetailContestCombosNormal,

    #[serde(rename = "super")]
          #[validate(nested)]
    pub param_super: models::MoveDetailContestCombosNormal,

}



impl MoveDetailContestCombos {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(normal: models::MoveDetailContestCombosNormal, param_super: models::MoveDetailContestCombosNormal, ) -> MoveDetailContestCombos {
        MoveDetailContestCombos {
 normal,
 param_super,
        }
    }
}

/// Converts the MoveDetailContestCombos value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDetailContestCombos {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping normal in query parameter serialization

            // Skipping super in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDetailContestCombos value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDetailContestCombos {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub normal: Vec<models::MoveDetailContestCombosNormal>,
            pub param_super: Vec<models::MoveDetailContestCombosNormal>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDetailContestCombos".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "normal" => intermediate_rep.normal.push(<models::MoveDetailContestCombosNormal as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "super" => intermediate_rep.param_super.push(<models::MoveDetailContestCombosNormal as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDetailContestCombos".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDetailContestCombos {
            normal: intermediate_rep.normal.into_iter().next().ok_or_else(|| "normal missing in MoveDetailContestCombos".to_string())?,
            param_super: intermediate_rep.param_super.into_iter().next().ok_or_else(|| "super missing in MoveDetailContestCombos".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDetailContestCombos> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDetailContestCombos>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDetailContestCombos>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDetailContestCombos - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDetailContestCombos> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDetailContestCombos as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDetailContestCombos - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDetailContestCombosNormal {
    #[serde(rename = "use_before")]
          #[validate(nested)]
    pub use_before: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "use_after")]
          #[validate(nested)]
    pub use_after: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl MoveDetailContestCombosNormal {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(use_before: Vec<models::AbilityDetailPokemonInnerPokemon>, use_after: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> MoveDetailContestCombosNormal {
        MoveDetailContestCombosNormal {
 use_before,
 use_after,
        }
    }
}

/// Converts the MoveDetailContestCombosNormal value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDetailContestCombosNormal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping use_before in query parameter serialization

            // Skipping use_after in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDetailContestCombosNormal value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDetailContestCombosNormal {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub use_before: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub use_after: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDetailContestCombosNormal".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "use_before" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetailContestCombosNormal".to_string()),
                    "use_after" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetailContestCombosNormal".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDetailContestCombosNormal".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDetailContestCombosNormal {
            use_before: intermediate_rep.use_before.into_iter().next().ok_or_else(|| "use_before missing in MoveDetailContestCombosNormal".to_string())?,
            use_after: intermediate_rep.use_after.into_iter().next().ok_or_else(|| "use_after missing in MoveDetailContestCombosNormal".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDetailContestCombosNormal> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDetailContestCombosNormal>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDetailContestCombosNormal>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDetailContestCombosNormal - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDetailContestCombosNormal> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDetailContestCombosNormal as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDetailContestCombosNormal - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDetailEffectChangesInner {
    #[serde(rename = "effect_entries")]
          #[validate(nested)]
    pub effect_entries: Vec<models::MoveDetailEffectChangesInnerEffectEntriesInner>,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::AbilityDetailPokemonInnerPokemon,

}



impl MoveDetailEffectChangesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect_entries: Vec<models::MoveDetailEffectChangesInnerEffectEntriesInner>, version_group: models::AbilityDetailPokemonInnerPokemon, ) -> MoveDetailEffectChangesInner {
        MoveDetailEffectChangesInner {
 effect_entries,
 version_group,
        }
    }
}

/// Converts the MoveDetailEffectChangesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDetailEffectChangesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping effect_entries in query parameter serialization

            // Skipping version_group in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDetailEffectChangesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDetailEffectChangesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect_entries: Vec<Vec<models::MoveDetailEffectChangesInnerEffectEntriesInner>>,
            pub version_group: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDetailEffectChangesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "effect_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveDetailEffectChangesInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDetailEffectChangesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDetailEffectChangesInner {
            effect_entries: intermediate_rep.effect_entries.into_iter().next().ok_or_else(|| "effect_entries missing in MoveDetailEffectChangesInner".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in MoveDetailEffectChangesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDetailEffectChangesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDetailEffectChangesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDetailEffectChangesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDetailEffectChangesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDetailEffectChangesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDetailEffectChangesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDetailEffectChangesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDetailEffectChangesInnerEffectEntriesInner {
    #[serde(rename = "effect")]
          #[validate(custom(function = "check_xss_string"))]
    pub effect: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::AbilityDetailPokemonInnerPokemon,

}



impl MoveDetailEffectChangesInnerEffectEntriesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(effect: String, language: models::AbilityDetailPokemonInnerPokemon, ) -> MoveDetailEffectChangesInnerEffectEntriesInner {
        MoveDetailEffectChangesInnerEffectEntriesInner {
 effect,
 language,
        }
    }
}

/// Converts the MoveDetailEffectChangesInnerEffectEntriesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDetailEffectChangesInnerEffectEntriesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("effect".to_string()),
            Some(self.effect.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDetailEffectChangesInnerEffectEntriesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDetailEffectChangesInnerEffectEntriesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub effect: Vec<String>,
            pub language: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDetailEffectChangesInnerEffectEntriesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "effect" => intermediate_rep.effect.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDetailEffectChangesInnerEffectEntriesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDetailEffectChangesInnerEffectEntriesInner {
            effect: intermediate_rep.effect.into_iter().next().ok_or_else(|| "effect missing in MoveDetailEffectChangesInnerEffectEntriesInner".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveDetailEffectChangesInnerEffectEntriesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDetailEffectChangesInnerEffectEntriesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDetailEffectChangesInnerEffectEntriesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDetailEffectChangesInnerEffectEntriesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDetailEffectChangesInnerEffectEntriesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDetailEffectChangesInnerEffectEntriesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDetailEffectChangesInnerEffectEntriesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDetailEffectChangesInnerEffectEntriesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDetailMachinesInner {
    #[serde(rename = "machine")]
          #[validate(nested)]
    pub machine: models::MoveDetailMachinesInnerMachine,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::AbilityDetailPokemonInnerPokemon,

}



impl MoveDetailMachinesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(machine: models::MoveDetailMachinesInnerMachine, version_group: models::AbilityDetailPokemonInnerPokemon, ) -> MoveDetailMachinesInner {
        MoveDetailMachinesInner {
 machine,
 version_group,
        }
    }
}

/// Converts the MoveDetailMachinesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDetailMachinesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping machine in query parameter serialization

            // Skipping version_group in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDetailMachinesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDetailMachinesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub machine: Vec<models::MoveDetailMachinesInnerMachine>,
            pub version_group: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDetailMachinesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "machine" => intermediate_rep.machine.push(<models::MoveDetailMachinesInnerMachine as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDetailMachinesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDetailMachinesInner {
            machine: intermediate_rep.machine.into_iter().next().ok_or_else(|| "machine missing in MoveDetailMachinesInner".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in MoveDetailMachinesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDetailMachinesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDetailMachinesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDetailMachinesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDetailMachinesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDetailMachinesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDetailMachinesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDetailMachinesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDetailMachinesInnerMachine {
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MoveDetailMachinesInnerMachine {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> MoveDetailMachinesInnerMachine {
        MoveDetailMachinesInnerMachine {
 url,
        }
    }
}

/// Converts the MoveDetailMachinesInnerMachine value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDetailMachinesInnerMachine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDetailMachinesInnerMachine value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDetailMachinesInnerMachine {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDetailMachinesInnerMachine".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDetailMachinesInnerMachine".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDetailMachinesInnerMachine {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MoveDetailMachinesInnerMachine".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDetailMachinesInnerMachine> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDetailMachinesInnerMachine>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDetailMachinesInnerMachine>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDetailMachinesInnerMachine - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDetailMachinesInnerMachine> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDetailMachinesInnerMachine as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDetailMachinesInnerMachine - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveDetailStatChangesInner {
    #[serde(rename = "change")]
    pub change: i32,

    #[serde(rename = "stat")]
          #[validate(nested)]
    pub stat: models::AbilityDetailPokemonInnerPokemon,

}



impl MoveDetailStatChangesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(change: i32, stat: models::AbilityDetailPokemonInnerPokemon, ) -> MoveDetailStatChangesInner {
        MoveDetailStatChangesInner {
 change,
 stat,
        }
    }
}

/// Converts the MoveDetailStatChangesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveDetailStatChangesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("change".to_string()),
            Some(self.change.to_string()),

            // Skipping stat in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveDetailStatChangesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveDetailStatChangesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub change: Vec<i32>,
            pub stat: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveDetailStatChangesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "change" => intermediate_rep.change.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stat" => intermediate_rep.stat.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveDetailStatChangesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveDetailStatChangesInner {
            change: intermediate_rep.change.into_iter().next().ok_or_else(|| "change missing in MoveDetailStatChangesInner".to_string())?,
            stat: intermediate_rep.stat.into_iter().next().ok_or_else(|| "stat missing in MoveDetailStatChangesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveDetailStatChangesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveDetailStatChangesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveDetailStatChangesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveDetailStatChangesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveDetailStatChangesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveDetailStatChangesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveDetailStatChangesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveFlavorText {
    #[serde(rename = "flavor_text")]
          #[validate(custom(function = "check_xss_string"))]
    pub flavor_text: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::VersionGroupSummary,

}



impl MoveFlavorText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(flavor_text: String, language: models::LanguageSummary, version_group: models::VersionGroupSummary, ) -> MoveFlavorText {
        MoveFlavorText {
 flavor_text,
 language,
 version_group,
        }
    }
}

/// Converts the MoveFlavorText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveFlavorText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("flavor_text".to_string()),
            Some(self.flavor_text.to_string()),

            // Skipping language in query parameter serialization

            // Skipping version_group in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveFlavorText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveFlavorText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub flavor_text: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
            pub version_group: Vec<models::VersionGroupSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveFlavorText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "flavor_text" => intermediate_rep.flavor_text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::VersionGroupSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveFlavorText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveFlavorText {
            flavor_text: intermediate_rep.flavor_text.into_iter().next().ok_or_else(|| "flavor_text missing in MoveFlavorText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveFlavorText".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in MoveFlavorText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveFlavorText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveFlavorText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveFlavorText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveFlavorText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveFlavorText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveFlavorText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveFlavorText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveLearnMethodDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveLearnMethodDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> MoveLearnMethodDescription {
        MoveLearnMethodDescription {
 description: None,
 language,
        }
    }
}

/// Converts the MoveLearnMethodDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveLearnMethodDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveLearnMethodDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveLearnMethodDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveLearnMethodDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveLearnMethodDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveLearnMethodDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveLearnMethodDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveLearnMethodDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveLearnMethodDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveLearnMethodDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveLearnMethodDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveLearnMethodDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveLearnMethodDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveLearnMethodDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveLearnMethodDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::MoveLearnMethodName>,

    #[serde(rename = "descriptions")]
          #[validate(nested)]
    pub descriptions: Vec<models::MoveLearnMethodDescription>,

    #[serde(rename = "version_groups")]
          #[validate(nested)]
    pub version_groups: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl MoveLearnMethodDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::MoveLearnMethodName>, descriptions: Vec<models::MoveLearnMethodDescription>, version_groups: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> MoveLearnMethodDetail {
        MoveLearnMethodDetail {
 id,
 name,
 names,
 descriptions,
 version_groups,
        }
    }
}

/// Converts the MoveLearnMethodDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveLearnMethodDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping names in query parameter serialization

            // Skipping descriptions in query parameter serialization

            // Skipping version_groups in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveLearnMethodDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveLearnMethodDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub names: Vec<Vec<models::MoveLearnMethodName>>,
            pub descriptions: Vec<Vec<models::MoveLearnMethodDescription>>,
            pub version_groups: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveLearnMethodDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveLearnMethodDetail".to_string()),
                    "descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveLearnMethodDetail".to_string()),
                    "version_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveLearnMethodDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveLearnMethodDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveLearnMethodDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MoveLearnMethodDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveLearnMethodDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in MoveLearnMethodDetail".to_string())?,
            descriptions: intermediate_rep.descriptions.into_iter().next().ok_or_else(|| "descriptions missing in MoveLearnMethodDetail".to_string())?,
            version_groups: intermediate_rep.version_groups.into_iter().next().ok_or_else(|| "version_groups missing in MoveLearnMethodDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveLearnMethodDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveLearnMethodDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveLearnMethodDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveLearnMethodDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveLearnMethodDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveLearnMethodDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveLearnMethodDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveLearnMethodName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveLearnMethodName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> MoveLearnMethodName {
        MoveLearnMethodName {
 name,
 language,
        }
    }
}

/// Converts the MoveLearnMethodName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveLearnMethodName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveLearnMethodName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveLearnMethodName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveLearnMethodName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveLearnMethodName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveLearnMethodName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveLearnMethodName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveLearnMethodName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveLearnMethodName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveLearnMethodName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveLearnMethodName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveLearnMethodName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveLearnMethodName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveLearnMethodName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveLearnMethodName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveLearnMethodSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MoveLearnMethodSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> MoveLearnMethodSummary {
        MoveLearnMethodSummary {
 name,
 url,
        }
    }
}

/// Converts the MoveLearnMethodSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveLearnMethodSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveLearnMethodSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveLearnMethodSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveLearnMethodSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveLearnMethodSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveLearnMethodSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveLearnMethodSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MoveLearnMethodSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveLearnMethodSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveLearnMethodSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveLearnMethodSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveLearnMethodSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveLearnMethodSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveLearnMethodSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveLearnMethodSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveMeta {
    #[serde(rename = "ailment")]
          #[validate(nested)]
    pub ailment: models::MoveMetaAilmentSummary,

    #[serde(rename = "category")]
          #[validate(nested)]
    pub category: models::MoveMetaCategorySummary,

    #[serde(rename = "min_hits")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_hits: Option<Nullable<i32>>,

    #[serde(rename = "max_hits")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_hits: Option<Nullable<i32>>,

    #[serde(rename = "min_turns")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub min_turns: Option<Nullable<i32>>,

    #[serde(rename = "max_turns")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub max_turns: Option<Nullable<i32>>,

    #[serde(rename = "drain")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub drain: Option<Nullable<i32>>,

    #[serde(rename = "healing")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub healing: Option<Nullable<i32>>,

    #[serde(rename = "crit_rate")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub crit_rate: Option<Nullable<i32>>,

    #[serde(rename = "ailment_chance")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub ailment_chance: Option<Nullable<i32>>,

    #[serde(rename = "flinch_chance")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub flinch_chance: Option<Nullable<i32>>,

    #[serde(rename = "stat_chance")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub stat_chance: Option<Nullable<i32>>,

}



impl MoveMeta {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ailment: models::MoveMetaAilmentSummary, category: models::MoveMetaCategorySummary, ) -> MoveMeta {
        MoveMeta {
 ailment,
 category,
 min_hits: None,
 max_hits: None,
 min_turns: None,
 max_turns: None,
 drain: None,
 healing: None,
 crit_rate: None,
 ailment_chance: None,
 flinch_chance: None,
 stat_chance: None,
        }
    }
}

/// Converts the MoveMeta value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveMeta {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ailment in query parameter serialization

            // Skipping category in query parameter serialization


            self.min_hits.as_ref().map(|min_hits| {
                [
                    "min_hits".to_string(),
                    min_hits.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_hits.as_ref().map(|max_hits| {
                [
                    "max_hits".to_string(),
                    max_hits.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.min_turns.as_ref().map(|min_turns| {
                [
                    "min_turns".to_string(),
                    min_turns.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.max_turns.as_ref().map(|max_turns| {
                [
                    "max_turns".to_string(),
                    max_turns.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.drain.as_ref().map(|drain| {
                [
                    "drain".to_string(),
                    drain.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.healing.as_ref().map(|healing| {
                [
                    "healing".to_string(),
                    healing.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.crit_rate.as_ref().map(|crit_rate| {
                [
                    "crit_rate".to_string(),
                    crit_rate.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.ailment_chance.as_ref().map(|ailment_chance| {
                [
                    "ailment_chance".to_string(),
                    ailment_chance.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.flinch_chance.as_ref().map(|flinch_chance| {
                [
                    "flinch_chance".to_string(),
                    flinch_chance.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.stat_chance.as_ref().map(|stat_chance| {
                [
                    "stat_chance".to_string(),
                    stat_chance.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveMeta value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveMeta {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ailment: Vec<models::MoveMetaAilmentSummary>,
            pub category: Vec<models::MoveMetaCategorySummary>,
            pub min_hits: Vec<i32>,
            pub max_hits: Vec<i32>,
            pub min_turns: Vec<i32>,
            pub max_turns: Vec<i32>,
            pub drain: Vec<i32>,
            pub healing: Vec<i32>,
            pub crit_rate: Vec<i32>,
            pub ailment_chance: Vec<i32>,
            pub flinch_chance: Vec<i32>,
            pub stat_chance: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveMeta".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ailment" => intermediate_rep.ailment.push(<models::MoveMetaAilmentSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "category" => intermediate_rep.category.push(<models::MoveMetaCategorySummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "min_hits" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "max_hits" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "min_turns" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "max_turns" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "drain" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "healing" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "crit_rate" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "ailment_chance" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "flinch_chance" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    "stat_chance" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in MoveMeta".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveMeta".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveMeta {
            ailment: intermediate_rep.ailment.into_iter().next().ok_or_else(|| "ailment missing in MoveMeta".to_string())?,
            category: intermediate_rep.category.into_iter().next().ok_or_else(|| "category missing in MoveMeta".to_string())?,
            min_hits: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            max_hits: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            min_turns: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            max_turns: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            drain: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            healing: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            crit_rate: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            ailment_chance: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            flinch_chance: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
            stat_chance: std::result::Result::Err("Nullable types not supported in MoveMeta".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveMeta> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveMeta>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveMeta>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveMeta - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveMeta> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveMeta as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveMeta - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveMetaAilmentDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "moves")]
          #[validate(nested)]
    pub moves: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::MoveMetaAilmentName>,

}



impl MoveMetaAilmentDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, moves: Vec<models::AbilityDetailPokemonInnerPokemon>, names: Vec<models::MoveMetaAilmentName>, ) -> MoveMetaAilmentDetail {
        MoveMetaAilmentDetail {
 id,
 name,
 moves,
 names,
        }
    }
}

/// Converts the MoveMetaAilmentDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveMetaAilmentDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping moves in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveMetaAilmentDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveMetaAilmentDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub moves: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub names: Vec<Vec<models::MoveMetaAilmentName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveMetaAilmentDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "moves" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveMetaAilmentDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveMetaAilmentDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveMetaAilmentDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveMetaAilmentDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MoveMetaAilmentDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveMetaAilmentDetail".to_string())?,
            moves: intermediate_rep.moves.into_iter().next().ok_or_else(|| "moves missing in MoveMetaAilmentDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in MoveMetaAilmentDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveMetaAilmentDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveMetaAilmentDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveMetaAilmentDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveMetaAilmentDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveMetaAilmentDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveMetaAilmentDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveMetaAilmentDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveMetaAilmentName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveMetaAilmentName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> MoveMetaAilmentName {
        MoveMetaAilmentName {
 name,
 language,
        }
    }
}

/// Converts the MoveMetaAilmentName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveMetaAilmentName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveMetaAilmentName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveMetaAilmentName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveMetaAilmentName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveMetaAilmentName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveMetaAilmentName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveMetaAilmentName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveMetaAilmentName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveMetaAilmentName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveMetaAilmentName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveMetaAilmentName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveMetaAilmentName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveMetaAilmentName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveMetaAilmentName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveMetaAilmentName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveMetaAilmentSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MoveMetaAilmentSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> MoveMetaAilmentSummary {
        MoveMetaAilmentSummary {
 name,
 url,
        }
    }
}

/// Converts the MoveMetaAilmentSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveMetaAilmentSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveMetaAilmentSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveMetaAilmentSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveMetaAilmentSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveMetaAilmentSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveMetaAilmentSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveMetaAilmentSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MoveMetaAilmentSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveMetaAilmentSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveMetaAilmentSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveMetaAilmentSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveMetaAilmentSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveMetaAilmentSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveMetaAilmentSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveMetaAilmentSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveMetaCategoryDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveMetaCategoryDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> MoveMetaCategoryDescription {
        MoveMetaCategoryDescription {
 description: None,
 language,
        }
    }
}

/// Converts the MoveMetaCategoryDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveMetaCategoryDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveMetaCategoryDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveMetaCategoryDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveMetaCategoryDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveMetaCategoryDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveMetaCategoryDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveMetaCategoryDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveMetaCategoryDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveMetaCategoryDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveMetaCategoryDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveMetaCategoryDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveMetaCategoryDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveMetaCategoryDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveMetaCategoryDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveMetaCategoryDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "descriptions")]
          #[validate(nested)]
    pub descriptions: Vec<models::MoveMetaCategoryDescription>,

    #[serde(rename = "moves")]
          #[validate(nested)]
    pub moves: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl MoveMetaCategoryDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, descriptions: Vec<models::MoveMetaCategoryDescription>, moves: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> MoveMetaCategoryDetail {
        MoveMetaCategoryDetail {
 id,
 name,
 descriptions,
 moves,
        }
    }
}

/// Converts the MoveMetaCategoryDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveMetaCategoryDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping descriptions in query parameter serialization

            // Skipping moves in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveMetaCategoryDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveMetaCategoryDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub descriptions: Vec<Vec<models::MoveMetaCategoryDescription>>,
            pub moves: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveMetaCategoryDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveMetaCategoryDetail".to_string()),
                    "moves" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveMetaCategoryDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveMetaCategoryDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveMetaCategoryDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MoveMetaCategoryDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveMetaCategoryDetail".to_string())?,
            descriptions: intermediate_rep.descriptions.into_iter().next().ok_or_else(|| "descriptions missing in MoveMetaCategoryDetail".to_string())?,
            moves: intermediate_rep.moves.into_iter().next().ok_or_else(|| "moves missing in MoveMetaCategoryDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveMetaCategoryDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveMetaCategoryDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveMetaCategoryDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveMetaCategoryDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveMetaCategoryDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveMetaCategoryDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveMetaCategoryDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveMetaCategorySummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MoveMetaCategorySummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> MoveMetaCategorySummary {
        MoveMetaCategorySummary {
 name,
 url,
        }
    }
}

/// Converts the MoveMetaCategorySummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveMetaCategorySummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveMetaCategorySummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveMetaCategorySummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveMetaCategorySummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveMetaCategorySummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveMetaCategorySummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveMetaCategorySummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MoveMetaCategorySummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveMetaCategorySummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveMetaCategorySummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveMetaCategorySummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveMetaCategorySummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveMetaCategorySummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveMetaCategorySummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveMetaCategorySummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> MoveName {
        MoveName {
 name,
 language,
        }
    }
}

/// Converts the MoveName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MoveSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> MoveSummary {
        MoveSummary {
 name,
 url,
        }
    }
}

/// Converts the MoveSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MoveSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveTargetDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveTargetDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> MoveTargetDescription {
        MoveTargetDescription {
 description: None,
 language,
        }
    }
}

/// Converts the MoveTargetDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveTargetDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveTargetDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveTargetDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveTargetDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveTargetDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveTargetDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveTargetDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveTargetDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveTargetDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveTargetDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveTargetDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveTargetDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveTargetDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveTargetDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveTargetDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "descriptions")]
          #[validate(nested)]
    pub descriptions: Vec<models::MoveTargetDescription>,

    #[serde(rename = "moves")]
          #[validate(nested)]
    pub moves: Vec<models::MoveSummary>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::MoveTargetName>,

}



impl MoveTargetDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, descriptions: Vec<models::MoveTargetDescription>, moves: Vec<models::MoveSummary>, names: Vec<models::MoveTargetName>, ) -> MoveTargetDetail {
        MoveTargetDetail {
 id,
 name,
 descriptions,
 moves,
 names,
        }
    }
}

/// Converts the MoveTargetDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveTargetDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping descriptions in query parameter serialization

            // Skipping moves in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveTargetDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveTargetDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub descriptions: Vec<Vec<models::MoveTargetDescription>>,
            pub moves: Vec<Vec<models::MoveSummary>>,
            pub names: Vec<Vec<models::MoveTargetName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveTargetDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveTargetDetail".to_string()),
                    "moves" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveTargetDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in MoveTargetDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveTargetDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveTargetDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in MoveTargetDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveTargetDetail".to_string())?,
            descriptions: intermediate_rep.descriptions.into_iter().next().ok_or_else(|| "descriptions missing in MoveTargetDetail".to_string())?,
            moves: intermediate_rep.moves.into_iter().next().ok_or_else(|| "moves missing in MoveTargetDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in MoveTargetDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveTargetDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveTargetDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveTargetDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveTargetDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveTargetDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveTargetDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveTargetDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveTargetName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl MoveTargetName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> MoveTargetName {
        MoveTargetName {
 name,
 language,
        }
    }
}

/// Converts the MoveTargetName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveTargetName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveTargetName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveTargetName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveTargetName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveTargetName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveTargetName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveTargetName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in MoveTargetName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveTargetName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveTargetName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveTargetName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveTargetName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveTargetName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveTargetName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveTargetName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct MoveTargetSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl MoveTargetSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> MoveTargetSummary {
        MoveTargetSummary {
 name,
 url,
        }
    }
}

/// Converts the MoveTargetSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for MoveTargetSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a MoveTargetSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for MoveTargetSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing MoveTargetSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing MoveTargetSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(MoveTargetSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in MoveTargetSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in MoveTargetSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<MoveTargetSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<MoveTargetSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<MoveTargetSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for MoveTargetSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<MoveTargetSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <MoveTargetSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into MoveTargetSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NatureBattleStylePreference {
    #[serde(rename = "low_hp_preference")]
    pub low_hp_preference: i32,

    #[serde(rename = "high_hp_preference")]
    pub high_hp_preference: i32,

    #[serde(rename = "move_battle_style")]
          #[validate(nested)]
    pub move_battle_style: models::MoveBattleStyleSummary,

}



impl NatureBattleStylePreference {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(low_hp_preference: i32, high_hp_preference: i32, move_battle_style: models::MoveBattleStyleSummary, ) -> NatureBattleStylePreference {
        NatureBattleStylePreference {
 low_hp_preference,
 high_hp_preference,
 move_battle_style,
        }
    }
}

/// Converts the NatureBattleStylePreference value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NatureBattleStylePreference {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("low_hp_preference".to_string()),
            Some(self.low_hp_preference.to_string()),


            Some("high_hp_preference".to_string()),
            Some(self.high_hp_preference.to_string()),

            // Skipping move_battle_style in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NatureBattleStylePreference value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NatureBattleStylePreference {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub low_hp_preference: Vec<i32>,
            pub high_hp_preference: Vec<i32>,
            pub move_battle_style: Vec<models::MoveBattleStyleSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NatureBattleStylePreference".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "low_hp_preference" => intermediate_rep.low_hp_preference.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "high_hp_preference" => intermediate_rep.high_hp_preference.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "move_battle_style" => intermediate_rep.move_battle_style.push(<models::MoveBattleStyleSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NatureBattleStylePreference".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NatureBattleStylePreference {
            low_hp_preference: intermediate_rep.low_hp_preference.into_iter().next().ok_or_else(|| "low_hp_preference missing in NatureBattleStylePreference".to_string())?,
            high_hp_preference: intermediate_rep.high_hp_preference.into_iter().next().ok_or_else(|| "high_hp_preference missing in NatureBattleStylePreference".to_string())?,
            move_battle_style: intermediate_rep.move_battle_style.into_iter().next().ok_or_else(|| "move_battle_style missing in NatureBattleStylePreference".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NatureBattleStylePreference> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NatureBattleStylePreference>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NatureBattleStylePreference>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for NatureBattleStylePreference - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NatureBattleStylePreference> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NatureBattleStylePreference as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into NatureBattleStylePreference - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NatureDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "decreased_stat")]
          #[validate(nested)]
    pub decreased_stat: models::StatSummary,

    #[serde(rename = "increased_stat")]
          #[validate(nested)]
    pub increased_stat: models::StatSummary,

    #[serde(rename = "likes_flavor")]
          #[validate(nested)]
    pub likes_flavor: models::BerryFlavorSummary,

    #[serde(rename = "hates_flavor")]
          #[validate(nested)]
    pub hates_flavor: models::BerryFlavorSummary,

    #[serde(rename = "berries")]
          #[validate(nested)]
    pub berries: Vec<models::BerrySummary>,

    #[serde(rename = "pokeathlon_stat_changes")]
          #[validate(nested)]
    pub pokeathlon_stat_changes: Vec<models::NatureDetailPokeathlonStatChangesInner>,

    #[serde(rename = "move_battle_style_preferences")]
          #[validate(nested)]
    pub move_battle_style_preferences: Vec<models::NatureBattleStylePreference>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::NatureName>,

}



impl NatureDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, decreased_stat: models::StatSummary, increased_stat: models::StatSummary, likes_flavor: models::BerryFlavorSummary, hates_flavor: models::BerryFlavorSummary, berries: Vec<models::BerrySummary>, pokeathlon_stat_changes: Vec<models::NatureDetailPokeathlonStatChangesInner>, move_battle_style_preferences: Vec<models::NatureBattleStylePreference>, names: Vec<models::NatureName>, ) -> NatureDetail {
        NatureDetail {
 id,
 name,
 decreased_stat,
 increased_stat,
 likes_flavor,
 hates_flavor,
 berries,
 pokeathlon_stat_changes,
 move_battle_style_preferences,
 names,
        }
    }
}

/// Converts the NatureDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NatureDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping decreased_stat in query parameter serialization

            // Skipping increased_stat in query parameter serialization

            // Skipping likes_flavor in query parameter serialization

            // Skipping hates_flavor in query parameter serialization

            // Skipping berries in query parameter serialization

            // Skipping pokeathlon_stat_changes in query parameter serialization

            // Skipping move_battle_style_preferences in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NatureDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NatureDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub decreased_stat: Vec<models::StatSummary>,
            pub increased_stat: Vec<models::StatSummary>,
            pub likes_flavor: Vec<models::BerryFlavorSummary>,
            pub hates_flavor: Vec<models::BerryFlavorSummary>,
            pub berries: Vec<Vec<models::BerrySummary>>,
            pub pokeathlon_stat_changes: Vec<Vec<models::NatureDetailPokeathlonStatChangesInner>>,
            pub move_battle_style_preferences: Vec<Vec<models::NatureBattleStylePreference>>,
            pub names: Vec<Vec<models::NatureName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NatureDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "decreased_stat" => intermediate_rep.decreased_stat.push(<models::StatSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "increased_stat" => intermediate_rep.increased_stat.push(<models::StatSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "likes_flavor" => intermediate_rep.likes_flavor.push(<models::BerryFlavorSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "hates_flavor" => intermediate_rep.hates_flavor.push(<models::BerryFlavorSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "berries" => return std::result::Result::Err("Parsing a container in this style is not supported in NatureDetail".to_string()),
                    "pokeathlon_stat_changes" => return std::result::Result::Err("Parsing a container in this style is not supported in NatureDetail".to_string()),
                    "move_battle_style_preferences" => return std::result::Result::Err("Parsing a container in this style is not supported in NatureDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in NatureDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing NatureDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NatureDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in NatureDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in NatureDetail".to_string())?,
            decreased_stat: intermediate_rep.decreased_stat.into_iter().next().ok_or_else(|| "decreased_stat missing in NatureDetail".to_string())?,
            increased_stat: intermediate_rep.increased_stat.into_iter().next().ok_or_else(|| "increased_stat missing in NatureDetail".to_string())?,
            likes_flavor: intermediate_rep.likes_flavor.into_iter().next().ok_or_else(|| "likes_flavor missing in NatureDetail".to_string())?,
            hates_flavor: intermediate_rep.hates_flavor.into_iter().next().ok_or_else(|| "hates_flavor missing in NatureDetail".to_string())?,
            berries: intermediate_rep.berries.into_iter().next().ok_or_else(|| "berries missing in NatureDetail".to_string())?,
            pokeathlon_stat_changes: intermediate_rep.pokeathlon_stat_changes.into_iter().next().ok_or_else(|| "pokeathlon_stat_changes missing in NatureDetail".to_string())?,
            move_battle_style_preferences: intermediate_rep.move_battle_style_preferences.into_iter().next().ok_or_else(|| "move_battle_style_preferences missing in NatureDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in NatureDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NatureDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NatureDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NatureDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for NatureDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NatureDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NatureDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into NatureDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NatureDetailPokeathlonStatChangesInner {
    #[serde(rename = "max_change")]
    pub max_change: i32,

    #[serde(rename = "pokeathlon_stat")]
          #[validate(nested)]
    pub pokeathlon_stat: models::AbilityDetailPokemonInnerPokemon,

}



impl NatureDetailPokeathlonStatChangesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(max_change: i32, pokeathlon_stat: models::AbilityDetailPokemonInnerPokemon, ) -> NatureDetailPokeathlonStatChangesInner {
        NatureDetailPokeathlonStatChangesInner {
 max_change,
 pokeathlon_stat,
        }
    }
}

/// Converts the NatureDetailPokeathlonStatChangesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NatureDetailPokeathlonStatChangesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("max_change".to_string()),
            Some(self.max_change.to_string()),

            // Skipping pokeathlon_stat in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NatureDetailPokeathlonStatChangesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NatureDetailPokeathlonStatChangesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_change: Vec<i32>,
            pub pokeathlon_stat: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NatureDetailPokeathlonStatChangesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "max_change" => intermediate_rep.max_change.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokeathlon_stat" => intermediate_rep.pokeathlon_stat.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NatureDetailPokeathlonStatChangesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NatureDetailPokeathlonStatChangesInner {
            max_change: intermediate_rep.max_change.into_iter().next().ok_or_else(|| "max_change missing in NatureDetailPokeathlonStatChangesInner".to_string())?,
            pokeathlon_stat: intermediate_rep.pokeathlon_stat.into_iter().next().ok_or_else(|| "pokeathlon_stat missing in NatureDetailPokeathlonStatChangesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NatureDetailPokeathlonStatChangesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NatureDetailPokeathlonStatChangesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NatureDetailPokeathlonStatChangesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for NatureDetailPokeathlonStatChangesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NatureDetailPokeathlonStatChangesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NatureDetailPokeathlonStatChangesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into NatureDetailPokeathlonStatChangesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NatureName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl NatureName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> NatureName {
        NatureName {
 name,
 language,
        }
    }
}

/// Converts the NatureName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NatureName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NatureName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NatureName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NatureName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NatureName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NatureName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in NatureName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in NatureName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NatureName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NatureName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NatureName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for NatureName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NatureName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NatureName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into NatureName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct NatureSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl NatureSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> NatureSummary {
        NatureSummary {
 name,
 url,
        }
    }
}

/// Converts the NatureSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for NatureSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a NatureSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for NatureSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing NatureSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing NatureSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(NatureSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in NatureSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in NatureSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<NatureSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<NatureSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<NatureSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for NatureSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<NatureSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <NatureSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into NatureSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedAbilitySummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::AbilitySummary>>,

}



impl PaginatedAbilitySummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedAbilitySummaryList {
        PaginatedAbilitySummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedAbilitySummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedAbilitySummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedAbilitySummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedAbilitySummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::AbilitySummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedAbilitySummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedAbilitySummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedAbilitySummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedAbilitySummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedAbilitySummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedAbilitySummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedAbilitySummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedAbilitySummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedAbilitySummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedAbilitySummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedAbilitySummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedBerryFirmnessSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::BerryFirmnessSummary>>,

}



impl PaginatedBerryFirmnessSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedBerryFirmnessSummaryList {
        PaginatedBerryFirmnessSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedBerryFirmnessSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedBerryFirmnessSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedBerryFirmnessSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedBerryFirmnessSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::BerryFirmnessSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedBerryFirmnessSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedBerryFirmnessSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedBerryFirmnessSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedBerryFirmnessSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedBerryFirmnessSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedBerryFirmnessSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedBerryFirmnessSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedBerryFirmnessSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedBerryFirmnessSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedBerryFirmnessSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedBerryFirmnessSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedBerryFlavorSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::BerryFlavorSummary>>,

}



impl PaginatedBerryFlavorSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedBerryFlavorSummaryList {
        PaginatedBerryFlavorSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedBerryFlavorSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedBerryFlavorSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedBerryFlavorSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedBerryFlavorSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::BerryFlavorSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedBerryFlavorSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedBerryFlavorSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedBerryFlavorSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedBerryFlavorSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedBerryFlavorSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedBerryFlavorSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedBerryFlavorSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedBerryFlavorSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedBerryFlavorSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedBerryFlavorSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedBerryFlavorSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedBerrySummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::BerrySummary>>,

}



impl PaginatedBerrySummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedBerrySummaryList {
        PaginatedBerrySummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedBerrySummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedBerrySummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedBerrySummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedBerrySummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::BerrySummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedBerrySummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedBerrySummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedBerrySummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedBerrySummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedBerrySummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedBerrySummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedBerrySummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedBerrySummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedBerrySummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedBerrySummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedBerrySummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedCharacteristicSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::CharacteristicSummary>>,

}



impl PaginatedCharacteristicSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedCharacteristicSummaryList {
        PaginatedCharacteristicSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedCharacteristicSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedCharacteristicSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedCharacteristicSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedCharacteristicSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::CharacteristicSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedCharacteristicSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedCharacteristicSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedCharacteristicSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedCharacteristicSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedCharacteristicSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedCharacteristicSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedCharacteristicSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedCharacteristicSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedCharacteristicSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedCharacteristicSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedCharacteristicSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedContestEffectSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::ContestEffectSummary>>,

}



impl PaginatedContestEffectSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedContestEffectSummaryList {
        PaginatedContestEffectSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedContestEffectSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedContestEffectSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedContestEffectSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedContestEffectSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::ContestEffectSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedContestEffectSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedContestEffectSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedContestEffectSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedContestEffectSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedContestEffectSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedContestEffectSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedContestEffectSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedContestEffectSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedContestEffectSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedContestEffectSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedContestEffectSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedContestTypeSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::ContestTypeSummary>>,

}



impl PaginatedContestTypeSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedContestTypeSummaryList {
        PaginatedContestTypeSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedContestTypeSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedContestTypeSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedContestTypeSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedContestTypeSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::ContestTypeSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedContestTypeSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedContestTypeSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedContestTypeSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedContestTypeSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedContestTypeSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedContestTypeSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedContestTypeSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedContestTypeSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedContestTypeSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedContestTypeSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedContestTypeSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedEggGroupSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::EggGroupSummary>>,

}



impl PaginatedEggGroupSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedEggGroupSummaryList {
        PaginatedEggGroupSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedEggGroupSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedEggGroupSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedEggGroupSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedEggGroupSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::EggGroupSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedEggGroupSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedEggGroupSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedEggGroupSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedEggGroupSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedEggGroupSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedEggGroupSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedEggGroupSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedEggGroupSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedEggGroupSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedEggGroupSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedEggGroupSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedEncounterConditionSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::EncounterConditionSummary>>,

}



impl PaginatedEncounterConditionSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedEncounterConditionSummaryList {
        PaginatedEncounterConditionSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedEncounterConditionSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedEncounterConditionSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedEncounterConditionSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedEncounterConditionSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::EncounterConditionSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedEncounterConditionSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedEncounterConditionSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedEncounterConditionSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedEncounterConditionSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedEncounterConditionSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedEncounterConditionSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedEncounterConditionSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedEncounterConditionSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedEncounterConditionSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedEncounterConditionSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedEncounterConditionSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedEncounterConditionValueSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::EncounterConditionValueSummary>>,

}



impl PaginatedEncounterConditionValueSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedEncounterConditionValueSummaryList {
        PaginatedEncounterConditionValueSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedEncounterConditionValueSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedEncounterConditionValueSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedEncounterConditionValueSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedEncounterConditionValueSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::EncounterConditionValueSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedEncounterConditionValueSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedEncounterConditionValueSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedEncounterConditionValueSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedEncounterConditionValueSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedEncounterConditionValueSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedEncounterConditionValueSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedEncounterConditionValueSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedEncounterConditionValueSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedEncounterConditionValueSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedEncounterConditionValueSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedEncounterConditionValueSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedEncounterMethodSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::EncounterMethodSummary>>,

}



impl PaginatedEncounterMethodSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedEncounterMethodSummaryList {
        PaginatedEncounterMethodSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedEncounterMethodSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedEncounterMethodSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedEncounterMethodSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedEncounterMethodSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::EncounterMethodSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedEncounterMethodSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedEncounterMethodSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedEncounterMethodSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedEncounterMethodSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedEncounterMethodSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedEncounterMethodSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedEncounterMethodSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedEncounterMethodSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedEncounterMethodSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedEncounterMethodSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedEncounterMethodSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedEvolutionChainSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::EvolutionChainSummary>>,

}



impl PaginatedEvolutionChainSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedEvolutionChainSummaryList {
        PaginatedEvolutionChainSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedEvolutionChainSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedEvolutionChainSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedEvolutionChainSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedEvolutionChainSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::EvolutionChainSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedEvolutionChainSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedEvolutionChainSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedEvolutionChainSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedEvolutionChainSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedEvolutionChainSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedEvolutionChainSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedEvolutionChainSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedEvolutionChainSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedEvolutionChainSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedEvolutionChainSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedEvolutionChainSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedEvolutionTriggerSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::EvolutionTriggerSummary>>,

}



impl PaginatedEvolutionTriggerSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedEvolutionTriggerSummaryList {
        PaginatedEvolutionTriggerSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedEvolutionTriggerSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedEvolutionTriggerSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedEvolutionTriggerSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedEvolutionTriggerSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::EvolutionTriggerSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedEvolutionTriggerSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedEvolutionTriggerSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedEvolutionTriggerSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedEvolutionTriggerSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedEvolutionTriggerSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedEvolutionTriggerSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedEvolutionTriggerSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedEvolutionTriggerSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedEvolutionTriggerSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedEvolutionTriggerSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedEvolutionTriggerSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedGenderSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::GenderSummary>>,

}



impl PaginatedGenderSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedGenderSummaryList {
        PaginatedGenderSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedGenderSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedGenderSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedGenderSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedGenderSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::GenderSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedGenderSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedGenderSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedGenderSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedGenderSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedGenderSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedGenderSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedGenderSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedGenderSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedGenderSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedGenderSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedGenderSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedGenerationSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::GenerationSummary>>,

}



impl PaginatedGenerationSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedGenerationSummaryList {
        PaginatedGenerationSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedGenerationSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedGenerationSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedGenerationSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedGenerationSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::GenerationSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedGenerationSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedGenerationSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedGenerationSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedGenerationSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedGenerationSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedGenerationSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedGenerationSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedGenerationSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedGenerationSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedGenerationSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedGenerationSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedGrowthRateSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::GrowthRateSummary>>,

}



impl PaginatedGrowthRateSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedGrowthRateSummaryList {
        PaginatedGrowthRateSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedGrowthRateSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedGrowthRateSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedGrowthRateSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedGrowthRateSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::GrowthRateSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedGrowthRateSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedGrowthRateSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedGrowthRateSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedGrowthRateSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedGrowthRateSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedGrowthRateSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedGrowthRateSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedGrowthRateSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedGrowthRateSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedGrowthRateSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedGrowthRateSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedItemAttributeSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::ItemAttributeSummary>>,

}



impl PaginatedItemAttributeSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedItemAttributeSummaryList {
        PaginatedItemAttributeSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedItemAttributeSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedItemAttributeSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedItemAttributeSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedItemAttributeSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::ItemAttributeSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedItemAttributeSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedItemAttributeSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedItemAttributeSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedItemAttributeSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedItemAttributeSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedItemAttributeSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedItemAttributeSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedItemAttributeSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedItemAttributeSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedItemAttributeSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedItemAttributeSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedItemCategorySummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::ItemCategorySummary>>,

}



impl PaginatedItemCategorySummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedItemCategorySummaryList {
        PaginatedItemCategorySummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedItemCategorySummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedItemCategorySummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedItemCategorySummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedItemCategorySummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::ItemCategorySummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedItemCategorySummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedItemCategorySummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedItemCategorySummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedItemCategorySummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedItemCategorySummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedItemCategorySummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedItemCategorySummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedItemCategorySummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedItemCategorySummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedItemCategorySummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedItemCategorySummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedItemFlingEffectSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::ItemFlingEffectSummary>>,

}



impl PaginatedItemFlingEffectSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedItemFlingEffectSummaryList {
        PaginatedItemFlingEffectSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedItemFlingEffectSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedItemFlingEffectSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedItemFlingEffectSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedItemFlingEffectSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::ItemFlingEffectSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedItemFlingEffectSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedItemFlingEffectSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedItemFlingEffectSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedItemFlingEffectSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedItemFlingEffectSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedItemFlingEffectSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedItemFlingEffectSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedItemFlingEffectSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedItemFlingEffectSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedItemFlingEffectSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedItemFlingEffectSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedItemPocketSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::ItemPocketSummary>>,

}



impl PaginatedItemPocketSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedItemPocketSummaryList {
        PaginatedItemPocketSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedItemPocketSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedItemPocketSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedItemPocketSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedItemPocketSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::ItemPocketSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedItemPocketSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedItemPocketSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedItemPocketSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedItemPocketSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedItemPocketSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedItemPocketSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedItemPocketSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedItemPocketSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedItemPocketSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedItemPocketSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedItemPocketSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedItemSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::ItemSummary>>,

}



impl PaginatedItemSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedItemSummaryList {
        PaginatedItemSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedItemSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedItemSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedItemSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedItemSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::ItemSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedItemSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedItemSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedItemSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedItemSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedItemSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedItemSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedItemSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedItemSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedItemSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedItemSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedItemSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedLanguageSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::LanguageSummary>>,

}



impl PaginatedLanguageSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedLanguageSummaryList {
        PaginatedLanguageSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedLanguageSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedLanguageSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedLanguageSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedLanguageSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::LanguageSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedLanguageSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedLanguageSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedLanguageSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedLanguageSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedLanguageSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedLanguageSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedLanguageSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedLanguageSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedLanguageSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedLanguageSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedLanguageSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedLocationAreaSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::LocationAreaSummary>>,

}



impl PaginatedLocationAreaSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedLocationAreaSummaryList {
        PaginatedLocationAreaSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedLocationAreaSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedLocationAreaSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedLocationAreaSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedLocationAreaSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::LocationAreaSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedLocationAreaSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedLocationAreaSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedLocationAreaSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedLocationAreaSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedLocationAreaSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedLocationAreaSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedLocationAreaSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedLocationAreaSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedLocationAreaSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedLocationAreaSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedLocationAreaSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedLocationSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::LocationSummary>>,

}



impl PaginatedLocationSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedLocationSummaryList {
        PaginatedLocationSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedLocationSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedLocationSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedLocationSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedLocationSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::LocationSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedLocationSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedLocationSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedLocationSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedLocationSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedLocationSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedLocationSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedLocationSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedLocationSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedLocationSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedLocationSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedLocationSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedMachineSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::MachineSummary>>,

}



impl PaginatedMachineSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedMachineSummaryList {
        PaginatedMachineSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedMachineSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedMachineSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedMachineSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedMachineSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::MachineSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedMachineSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedMachineSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedMachineSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedMachineSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedMachineSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedMachineSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedMachineSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedMachineSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedMachineSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedMachineSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedMachineSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedMoveBattleStyleSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::MoveBattleStyleSummary>>,

}



impl PaginatedMoveBattleStyleSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedMoveBattleStyleSummaryList {
        PaginatedMoveBattleStyleSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedMoveBattleStyleSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedMoveBattleStyleSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedMoveBattleStyleSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedMoveBattleStyleSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::MoveBattleStyleSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedMoveBattleStyleSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedMoveBattleStyleSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedMoveBattleStyleSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedMoveBattleStyleSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedMoveBattleStyleSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedMoveBattleStyleSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedMoveBattleStyleSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedMoveBattleStyleSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedMoveBattleStyleSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedMoveBattleStyleSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedMoveBattleStyleSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedMoveDamageClassSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::MoveDamageClassSummary>>,

}



impl PaginatedMoveDamageClassSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedMoveDamageClassSummaryList {
        PaginatedMoveDamageClassSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedMoveDamageClassSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedMoveDamageClassSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedMoveDamageClassSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedMoveDamageClassSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::MoveDamageClassSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedMoveDamageClassSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedMoveDamageClassSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedMoveDamageClassSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedMoveDamageClassSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedMoveDamageClassSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedMoveDamageClassSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedMoveDamageClassSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedMoveDamageClassSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedMoveDamageClassSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedMoveDamageClassSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedMoveDamageClassSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedMoveLearnMethodSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::MoveLearnMethodSummary>>,

}



impl PaginatedMoveLearnMethodSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedMoveLearnMethodSummaryList {
        PaginatedMoveLearnMethodSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedMoveLearnMethodSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedMoveLearnMethodSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedMoveLearnMethodSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedMoveLearnMethodSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::MoveLearnMethodSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedMoveLearnMethodSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedMoveLearnMethodSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedMoveLearnMethodSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedMoveLearnMethodSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedMoveLearnMethodSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedMoveLearnMethodSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedMoveLearnMethodSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedMoveLearnMethodSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedMoveLearnMethodSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedMoveLearnMethodSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedMoveLearnMethodSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedMoveMetaAilmentSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::MoveMetaAilmentSummary>>,

}



impl PaginatedMoveMetaAilmentSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedMoveMetaAilmentSummaryList {
        PaginatedMoveMetaAilmentSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedMoveMetaAilmentSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedMoveMetaAilmentSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedMoveMetaAilmentSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedMoveMetaAilmentSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::MoveMetaAilmentSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedMoveMetaAilmentSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedMoveMetaAilmentSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedMoveMetaAilmentSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedMoveMetaAilmentSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedMoveMetaAilmentSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedMoveMetaAilmentSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedMoveMetaAilmentSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedMoveMetaAilmentSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedMoveMetaAilmentSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedMoveMetaAilmentSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedMoveMetaAilmentSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedMoveMetaCategorySummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::MoveMetaCategorySummary>>,

}



impl PaginatedMoveMetaCategorySummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedMoveMetaCategorySummaryList {
        PaginatedMoveMetaCategorySummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedMoveMetaCategorySummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedMoveMetaCategorySummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedMoveMetaCategorySummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedMoveMetaCategorySummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::MoveMetaCategorySummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedMoveMetaCategorySummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedMoveMetaCategorySummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedMoveMetaCategorySummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedMoveMetaCategorySummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedMoveMetaCategorySummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedMoveMetaCategorySummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedMoveMetaCategorySummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedMoveMetaCategorySummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedMoveMetaCategorySummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedMoveMetaCategorySummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedMoveMetaCategorySummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedMoveSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::MoveSummary>>,

}



impl PaginatedMoveSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedMoveSummaryList {
        PaginatedMoveSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedMoveSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedMoveSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedMoveSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedMoveSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::MoveSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedMoveSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedMoveSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedMoveSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedMoveSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedMoveSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedMoveSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedMoveSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedMoveSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedMoveSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedMoveSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedMoveSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedMoveTargetSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::MoveTargetSummary>>,

}



impl PaginatedMoveTargetSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedMoveTargetSummaryList {
        PaginatedMoveTargetSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedMoveTargetSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedMoveTargetSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedMoveTargetSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedMoveTargetSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::MoveTargetSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedMoveTargetSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedMoveTargetSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedMoveTargetSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedMoveTargetSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedMoveTargetSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedMoveTargetSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedMoveTargetSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedMoveTargetSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedMoveTargetSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedMoveTargetSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedMoveTargetSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedNatureSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::NatureSummary>>,

}



impl PaginatedNatureSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedNatureSummaryList {
        PaginatedNatureSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedNatureSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedNatureSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedNatureSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedNatureSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::NatureSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedNatureSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedNatureSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedNatureSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedNatureSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedNatureSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedNatureSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedNatureSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedNatureSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedNatureSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedNatureSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedNatureSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPalParkAreaSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PalParkAreaSummary>>,

}



impl PaginatedPalParkAreaSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPalParkAreaSummaryList {
        PaginatedPalParkAreaSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPalParkAreaSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPalParkAreaSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPalParkAreaSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPalParkAreaSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PalParkAreaSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPalParkAreaSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPalParkAreaSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPalParkAreaSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPalParkAreaSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPalParkAreaSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPalParkAreaSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPalParkAreaSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPalParkAreaSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPalParkAreaSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPalParkAreaSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPalParkAreaSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPokeathlonStatSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PokeathlonStatSummary>>,

}



impl PaginatedPokeathlonStatSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPokeathlonStatSummaryList {
        PaginatedPokeathlonStatSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPokeathlonStatSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPokeathlonStatSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPokeathlonStatSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPokeathlonStatSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PokeathlonStatSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPokeathlonStatSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPokeathlonStatSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPokeathlonStatSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPokeathlonStatSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPokeathlonStatSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPokeathlonStatSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPokeathlonStatSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPokeathlonStatSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPokeathlonStatSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPokeathlonStatSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPokeathlonStatSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPokedexSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PokedexSummary>>,

}



impl PaginatedPokedexSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPokedexSummaryList {
        PaginatedPokedexSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPokedexSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPokedexSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPokedexSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPokedexSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PokedexSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPokedexSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPokedexSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPokedexSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPokedexSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPokedexSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPokedexSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPokedexSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPokedexSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPokedexSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPokedexSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPokedexSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPokemonColorSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PokemonColorSummary>>,

}



impl PaginatedPokemonColorSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPokemonColorSummaryList {
        PaginatedPokemonColorSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPokemonColorSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPokemonColorSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPokemonColorSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPokemonColorSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PokemonColorSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPokemonColorSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPokemonColorSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPokemonColorSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPokemonColorSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPokemonColorSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPokemonColorSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPokemonColorSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPokemonColorSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPokemonColorSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPokemonColorSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPokemonColorSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPokemonFormSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PokemonFormSummary>>,

}



impl PaginatedPokemonFormSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPokemonFormSummaryList {
        PaginatedPokemonFormSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPokemonFormSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPokemonFormSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPokemonFormSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPokemonFormSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PokemonFormSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPokemonFormSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPokemonFormSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPokemonFormSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPokemonFormSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPokemonFormSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPokemonFormSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPokemonFormSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPokemonFormSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPokemonFormSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPokemonFormSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPokemonFormSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPokemonHabitatSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PokemonHabitatSummary>>,

}



impl PaginatedPokemonHabitatSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPokemonHabitatSummaryList {
        PaginatedPokemonHabitatSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPokemonHabitatSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPokemonHabitatSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPokemonHabitatSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPokemonHabitatSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PokemonHabitatSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPokemonHabitatSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPokemonHabitatSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPokemonHabitatSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPokemonHabitatSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPokemonHabitatSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPokemonHabitatSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPokemonHabitatSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPokemonHabitatSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPokemonHabitatSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPokemonHabitatSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPokemonHabitatSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPokemonShapeSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PokemonShapeSummary>>,

}



impl PaginatedPokemonShapeSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPokemonShapeSummaryList {
        PaginatedPokemonShapeSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPokemonShapeSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPokemonShapeSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPokemonShapeSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPokemonShapeSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PokemonShapeSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPokemonShapeSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPokemonShapeSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPokemonShapeSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPokemonShapeSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPokemonShapeSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPokemonShapeSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPokemonShapeSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPokemonShapeSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPokemonShapeSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPokemonShapeSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPokemonShapeSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPokemonSpeciesSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PokemonSpeciesSummary>>,

}



impl PaginatedPokemonSpeciesSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPokemonSpeciesSummaryList {
        PaginatedPokemonSpeciesSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPokemonSpeciesSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPokemonSpeciesSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPokemonSpeciesSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPokemonSpeciesSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PokemonSpeciesSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPokemonSpeciesSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPokemonSpeciesSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPokemonSpeciesSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPokemonSpeciesSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPokemonSpeciesSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPokemonSpeciesSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPokemonSpeciesSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPokemonSpeciesSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPokemonSpeciesSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPokemonSpeciesSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPokemonSpeciesSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedPokemonSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::PokemonSummary>>,

}



impl PaginatedPokemonSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedPokemonSummaryList {
        PaginatedPokemonSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedPokemonSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedPokemonSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedPokemonSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedPokemonSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::PokemonSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedPokemonSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedPokemonSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedPokemonSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedPokemonSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedPokemonSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedPokemonSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedPokemonSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedPokemonSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedPokemonSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedPokemonSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedPokemonSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedRegionSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::RegionSummary>>,

}



impl PaginatedRegionSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedRegionSummaryList {
        PaginatedRegionSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedRegionSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedRegionSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedRegionSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedRegionSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::RegionSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedRegionSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedRegionSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedRegionSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedRegionSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedRegionSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedRegionSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedRegionSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedRegionSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedRegionSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedRegionSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedRegionSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedStatSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::StatSummary>>,

}



impl PaginatedStatSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedStatSummaryList {
        PaginatedStatSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedStatSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedStatSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedStatSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedStatSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::StatSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedStatSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedStatSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedStatSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedStatSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedStatSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedStatSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedStatSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedStatSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedStatSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedStatSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedStatSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedSuperContestEffectSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::SuperContestEffectSummary>>,

}



impl PaginatedSuperContestEffectSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedSuperContestEffectSummaryList {
        PaginatedSuperContestEffectSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedSuperContestEffectSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedSuperContestEffectSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedSuperContestEffectSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedSuperContestEffectSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::SuperContestEffectSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedSuperContestEffectSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedSuperContestEffectSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedSuperContestEffectSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedSuperContestEffectSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedSuperContestEffectSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedSuperContestEffectSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedSuperContestEffectSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedSuperContestEffectSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedSuperContestEffectSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedSuperContestEffectSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedSuperContestEffectSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedTypeSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::TypeSummary>>,

}



impl PaginatedTypeSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedTypeSummaryList {
        PaginatedTypeSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedTypeSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedTypeSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedTypeSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedTypeSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::TypeSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedTypeSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedTypeSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedTypeSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedTypeSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedTypeSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedTypeSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedTypeSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedTypeSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedTypeSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedTypeSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedTypeSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedVersionGroupSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::VersionGroupSummary>>,

}



impl PaginatedVersionGroupSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedVersionGroupSummaryList {
        PaginatedVersionGroupSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedVersionGroupSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedVersionGroupSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedVersionGroupSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedVersionGroupSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::VersionGroupSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedVersionGroupSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedVersionGroupSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedVersionGroupSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedVersionGroupSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedVersionGroupSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedVersionGroupSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedVersionGroupSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedVersionGroupSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedVersionGroupSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedVersionGroupSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedVersionGroupSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PaginatedVersionSummaryList {
    #[serde(rename = "count")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub count: Option<i32>,

    #[serde(rename = "next")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub next: Option<String>,

    #[serde(rename = "previous")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub previous: Option<String>,

    #[serde(rename = "results")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub results: Option<Vec<models::VersionSummary>>,

}



impl PaginatedVersionSummaryList {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PaginatedVersionSummaryList {
        PaginatedVersionSummaryList {
 count: None,
 next: None,
 previous: None,
 results: None,
        }
    }
}

/// Converts the PaginatedVersionSummaryList value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PaginatedVersionSummaryList {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.count.as_ref().map(|count| {
                [
                    "count".to_string(),
                    count.to_string(),
                ].join(",")
            }),


            self.next.as_ref().map(|next| {
                [
                    "next".to_string(),
                    next.to_string(),
                ].join(",")
            }),


            self.previous.as_ref().map(|previous| {
                [
                    "previous".to_string(),
                    previous.to_string(),
                ].join(",")
            }),

            // Skipping results in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PaginatedVersionSummaryList value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PaginatedVersionSummaryList {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub count: Vec<i32>,
            pub next: Vec<String>,
            pub previous: Vec<String>,
            pub results: Vec<Vec<models::VersionSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PaginatedVersionSummaryList".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "count" => intermediate_rep.count.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "next" => intermediate_rep.next.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "previous" => intermediate_rep.previous.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "results" => return std::result::Result::Err("Parsing a container in this style is not supported in PaginatedVersionSummaryList".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PaginatedVersionSummaryList".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PaginatedVersionSummaryList {
            count: intermediate_rep.count.into_iter().next(),
            next: intermediate_rep.next.into_iter().next(),
            previous: intermediate_rep.previous.into_iter().next(),
            results: intermediate_rep.results.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PaginatedVersionSummaryList> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PaginatedVersionSummaryList>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PaginatedVersionSummaryList>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PaginatedVersionSummaryList - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PaginatedVersionSummaryList> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PaginatedVersionSummaryList as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PaginatedVersionSummaryList - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PalParkAreaDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::PalParkAreaName>,

    #[serde(rename = "pokemon_encounters")]
          #[validate(nested)]
    pub pokemon_encounters: Vec<models::PalParkAreaDetailPokemonEncountersInner>,

}



impl PalParkAreaDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::PalParkAreaName>, pokemon_encounters: Vec<models::PalParkAreaDetailPokemonEncountersInner>, ) -> PalParkAreaDetail {
        PalParkAreaDetail {
 id,
 name,
 names,
 pokemon_encounters,
        }
    }
}

/// Converts the PalParkAreaDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PalParkAreaDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping names in query parameter serialization

            // Skipping pokemon_encounters in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PalParkAreaDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PalParkAreaDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub names: Vec<Vec<models::PalParkAreaName>>,
            pub pokemon_encounters: Vec<Vec<models::PalParkAreaDetailPokemonEncountersInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PalParkAreaDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in PalParkAreaDetail".to_string()),
                    "pokemon_encounters" => return std::result::Result::Err("Parsing a container in this style is not supported in PalParkAreaDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PalParkAreaDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PalParkAreaDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PalParkAreaDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PalParkAreaDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in PalParkAreaDetail".to_string())?,
            pokemon_encounters: intermediate_rep.pokemon_encounters.into_iter().next().ok_or_else(|| "pokemon_encounters missing in PalParkAreaDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PalParkAreaDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PalParkAreaDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PalParkAreaDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PalParkAreaDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PalParkAreaDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PalParkAreaDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PalParkAreaDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PalParkAreaDetailPokemonEncountersInner {
    #[serde(rename = "base_score")]
    pub base_score: i32,

    #[serde(rename = "pokemon-species")]
          #[validate(nested)]
    pub pokemon_species: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "rate")]
    pub rate: i32,

}



impl PalParkAreaDetailPokemonEncountersInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(base_score: i32, pokemon_species: models::AbilityDetailPokemonInnerPokemon, rate: i32, ) -> PalParkAreaDetailPokemonEncountersInner {
        PalParkAreaDetailPokemonEncountersInner {
 base_score,
 pokemon_species,
 rate,
        }
    }
}

/// Converts the PalParkAreaDetailPokemonEncountersInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PalParkAreaDetailPokemonEncountersInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("base_score".to_string()),
            Some(self.base_score.to_string()),

            // Skipping pokemon-species in query parameter serialization


            Some("rate".to_string()),
            Some(self.rate.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PalParkAreaDetailPokemonEncountersInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PalParkAreaDetailPokemonEncountersInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub base_score: Vec<i32>,
            pub pokemon_species: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub rate: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PalParkAreaDetailPokemonEncountersInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "base_score" => intermediate_rep.base_score.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokemon-species" => intermediate_rep.pokemon_species.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rate" => intermediate_rep.rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PalParkAreaDetailPokemonEncountersInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PalParkAreaDetailPokemonEncountersInner {
            base_score: intermediate_rep.base_score.into_iter().next().ok_or_else(|| "base_score missing in PalParkAreaDetailPokemonEncountersInner".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon-species missing in PalParkAreaDetailPokemonEncountersInner".to_string())?,
            rate: intermediate_rep.rate.into_iter().next().ok_or_else(|| "rate missing in PalParkAreaDetailPokemonEncountersInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PalParkAreaDetailPokemonEncountersInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PalParkAreaDetailPokemonEncountersInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PalParkAreaDetailPokemonEncountersInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PalParkAreaDetailPokemonEncountersInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PalParkAreaDetailPokemonEncountersInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PalParkAreaDetailPokemonEncountersInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PalParkAreaDetailPokemonEncountersInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PalParkAreaName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl PalParkAreaName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> PalParkAreaName {
        PalParkAreaName {
 name,
 language,
        }
    }
}

/// Converts the PalParkAreaName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PalParkAreaName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PalParkAreaName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PalParkAreaName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PalParkAreaName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PalParkAreaName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PalParkAreaName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PalParkAreaName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PalParkAreaName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PalParkAreaName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PalParkAreaName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PalParkAreaName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PalParkAreaName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PalParkAreaName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PalParkAreaName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PalParkAreaName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PalParkAreaSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PalParkAreaSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PalParkAreaSummary {
        PalParkAreaSummary {
 name,
 url,
        }
    }
}

/// Converts the PalParkAreaSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PalParkAreaSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PalParkAreaSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PalParkAreaSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PalParkAreaSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PalParkAreaSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PalParkAreaSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PalParkAreaSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PalParkAreaSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PalParkAreaSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PalParkAreaSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PalParkAreaSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PalParkAreaSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PalParkAreaSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PalParkAreaSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PalParkAreaSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokeathlonStatDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "affecting_natures")]
          #[validate(nested)]
    pub affecting_natures: models::PokeathlonStatDetailAffectingNatures,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::PokeathlonStatName>,

}



impl PokeathlonStatDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, affecting_natures: models::PokeathlonStatDetailAffectingNatures, names: Vec<models::PokeathlonStatName>, ) -> PokeathlonStatDetail {
        PokeathlonStatDetail {
 id,
 name,
 affecting_natures,
 names,
        }
    }
}

/// Converts the PokeathlonStatDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokeathlonStatDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping affecting_natures in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokeathlonStatDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokeathlonStatDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub affecting_natures: Vec<models::PokeathlonStatDetailAffectingNatures>,
            pub names: Vec<Vec<models::PokeathlonStatName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokeathlonStatDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "affecting_natures" => intermediate_rep.affecting_natures.push(<models::PokeathlonStatDetailAffectingNatures as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokeathlonStatDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokeathlonStatDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokeathlonStatDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PokeathlonStatDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokeathlonStatDetail".to_string())?,
            affecting_natures: intermediate_rep.affecting_natures.into_iter().next().ok_or_else(|| "affecting_natures missing in PokeathlonStatDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in PokeathlonStatDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokeathlonStatDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokeathlonStatDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokeathlonStatDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokeathlonStatDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokeathlonStatDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokeathlonStatDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokeathlonStatDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokeathlonStatDetailAffectingNatures {
    #[serde(rename = "decrease")]
          #[validate(nested)]
    pub decrease: Vec<models::PokeathlonStatDetailAffectingNaturesDecreaseInner>,

    #[serde(rename = "increase")]
          #[validate(nested)]
    pub increase: Vec<models::PokeathlonStatDetailAffectingNaturesIncreaseInner>,

}



impl PokeathlonStatDetailAffectingNatures {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(decrease: Vec<models::PokeathlonStatDetailAffectingNaturesDecreaseInner>, increase: Vec<models::PokeathlonStatDetailAffectingNaturesIncreaseInner>, ) -> PokeathlonStatDetailAffectingNatures {
        PokeathlonStatDetailAffectingNatures {
 decrease,
 increase,
        }
    }
}

/// Converts the PokeathlonStatDetailAffectingNatures value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokeathlonStatDetailAffectingNatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping decrease in query parameter serialization

            // Skipping increase in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokeathlonStatDetailAffectingNatures value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokeathlonStatDetailAffectingNatures {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub decrease: Vec<Vec<models::PokeathlonStatDetailAffectingNaturesDecreaseInner>>,
            pub increase: Vec<Vec<models::PokeathlonStatDetailAffectingNaturesIncreaseInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokeathlonStatDetailAffectingNatures".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "decrease" => return std::result::Result::Err("Parsing a container in this style is not supported in PokeathlonStatDetailAffectingNatures".to_string()),
                    "increase" => return std::result::Result::Err("Parsing a container in this style is not supported in PokeathlonStatDetailAffectingNatures".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokeathlonStatDetailAffectingNatures".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokeathlonStatDetailAffectingNatures {
            decrease: intermediate_rep.decrease.into_iter().next().ok_or_else(|| "decrease missing in PokeathlonStatDetailAffectingNatures".to_string())?,
            increase: intermediate_rep.increase.into_iter().next().ok_or_else(|| "increase missing in PokeathlonStatDetailAffectingNatures".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokeathlonStatDetailAffectingNatures> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokeathlonStatDetailAffectingNatures>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokeathlonStatDetailAffectingNatures>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokeathlonStatDetailAffectingNatures - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokeathlonStatDetailAffectingNatures> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokeathlonStatDetailAffectingNatures as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokeathlonStatDetailAffectingNatures - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokeathlonStatDetailAffectingNaturesDecreaseInner {
    #[serde(rename = "max_change")]
    #[validate(
            range(max = -1i32),
    )]
    pub max_change: i32,

    #[serde(rename = "nature")]
          #[validate(nested)]
    pub nature: models::AbilityDetailPokemonInnerPokemon,

}



impl PokeathlonStatDetailAffectingNaturesDecreaseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(max_change: i32, nature: models::AbilityDetailPokemonInnerPokemon, ) -> PokeathlonStatDetailAffectingNaturesDecreaseInner {
        PokeathlonStatDetailAffectingNaturesDecreaseInner {
 max_change,
 nature,
        }
    }
}

/// Converts the PokeathlonStatDetailAffectingNaturesDecreaseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokeathlonStatDetailAffectingNaturesDecreaseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("max_change".to_string()),
            Some(self.max_change.to_string()),

            // Skipping nature in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokeathlonStatDetailAffectingNaturesDecreaseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokeathlonStatDetailAffectingNaturesDecreaseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_change: Vec<i32>,
            pub nature: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokeathlonStatDetailAffectingNaturesDecreaseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "max_change" => intermediate_rep.max_change.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nature" => intermediate_rep.nature.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokeathlonStatDetailAffectingNaturesDecreaseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokeathlonStatDetailAffectingNaturesDecreaseInner {
            max_change: intermediate_rep.max_change.into_iter().next().ok_or_else(|| "max_change missing in PokeathlonStatDetailAffectingNaturesDecreaseInner".to_string())?,
            nature: intermediate_rep.nature.into_iter().next().ok_or_else(|| "nature missing in PokeathlonStatDetailAffectingNaturesDecreaseInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokeathlonStatDetailAffectingNaturesDecreaseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokeathlonStatDetailAffectingNaturesDecreaseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokeathlonStatDetailAffectingNaturesDecreaseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokeathlonStatDetailAffectingNaturesDecreaseInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokeathlonStatDetailAffectingNaturesDecreaseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokeathlonStatDetailAffectingNaturesDecreaseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokeathlonStatDetailAffectingNaturesDecreaseInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokeathlonStatDetailAffectingNaturesIncreaseInner {
    #[serde(rename = "max_change")]
    #[validate(
            range(min = 1u32),
    )]
    pub max_change: u32,

    #[serde(rename = "nature")]
          #[validate(nested)]
    pub nature: models::AbilityDetailPokemonInnerPokemon,

}



impl PokeathlonStatDetailAffectingNaturesIncreaseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(max_change: u32, nature: models::AbilityDetailPokemonInnerPokemon, ) -> PokeathlonStatDetailAffectingNaturesIncreaseInner {
        PokeathlonStatDetailAffectingNaturesIncreaseInner {
 max_change,
 nature,
        }
    }
}

/// Converts the PokeathlonStatDetailAffectingNaturesIncreaseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokeathlonStatDetailAffectingNaturesIncreaseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("max_change".to_string()),
            Some(self.max_change.to_string()),

            // Skipping nature in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokeathlonStatDetailAffectingNaturesIncreaseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokeathlonStatDetailAffectingNaturesIncreaseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub max_change: Vec<u32>,
            pub nature: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokeathlonStatDetailAffectingNaturesIncreaseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "max_change" => intermediate_rep.max_change.push(<u32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "nature" => intermediate_rep.nature.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokeathlonStatDetailAffectingNaturesIncreaseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokeathlonStatDetailAffectingNaturesIncreaseInner {
            max_change: intermediate_rep.max_change.into_iter().next().ok_or_else(|| "max_change missing in PokeathlonStatDetailAffectingNaturesIncreaseInner".to_string())?,
            nature: intermediate_rep.nature.into_iter().next().ok_or_else(|| "nature missing in PokeathlonStatDetailAffectingNaturesIncreaseInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokeathlonStatDetailAffectingNaturesIncreaseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokeathlonStatDetailAffectingNaturesIncreaseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokeathlonStatDetailAffectingNaturesIncreaseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokeathlonStatDetailAffectingNaturesIncreaseInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokeathlonStatDetailAffectingNaturesIncreaseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokeathlonStatDetailAffectingNaturesIncreaseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokeathlonStatDetailAffectingNaturesIncreaseInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokeathlonStatName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl PokeathlonStatName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> PokeathlonStatName {
        PokeathlonStatName {
 name,
 language,
        }
    }
}

/// Converts the PokeathlonStatName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokeathlonStatName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokeathlonStatName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokeathlonStatName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokeathlonStatName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokeathlonStatName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokeathlonStatName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokeathlonStatName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokeathlonStatName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokeathlonStatName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokeathlonStatName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokeathlonStatName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokeathlonStatName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokeathlonStatName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokeathlonStatName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokeathlonStatName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokeathlonStatSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokeathlonStatSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokeathlonStatSummary {
        PokeathlonStatSummary {
 name,
 url,
        }
    }
}

/// Converts the PokeathlonStatSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokeathlonStatSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokeathlonStatSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokeathlonStatSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokeathlonStatSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokeathlonStatSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokeathlonStatSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokeathlonStatSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokeathlonStatSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokeathlonStatSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokeathlonStatSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokeathlonStatSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokeathlonStatSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokeathlonStatSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokeathlonStatSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokeathlonStatSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokedexDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl PokedexDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> PokedexDescription {
        PokedexDescription {
 description: None,
 language,
        }
    }
}

/// Converts the PokedexDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokedexDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokedexDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokedexDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokedexDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokedexDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokedexDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokedexDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokedexDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokedexDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokedexDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokedexDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokedexDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokedexDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokedexDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokedexDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "is_main_series")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_main_series: Option<bool>,

    #[serde(rename = "descriptions")]
          #[validate(nested)]
    pub descriptions: Vec<models::PokedexDescription>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::PokedexName>,

    #[serde(rename = "pokemon_entries")]
          #[validate(nested)]
    pub pokemon_entries: Vec<models::PokedexDetailPokemonEntriesInner>,

    #[serde(rename = "region")]
          #[validate(nested)]
    pub region: models::RegionSummary,

    #[serde(rename = "version_groups")]
          #[validate(nested)]
    pub version_groups: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl PokedexDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, descriptions: Vec<models::PokedexDescription>, names: Vec<models::PokedexName>, pokemon_entries: Vec<models::PokedexDetailPokemonEntriesInner>, region: models::RegionSummary, version_groups: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> PokedexDetail {
        PokedexDetail {
 id,
 name,
 is_main_series: None,
 descriptions,
 names,
 pokemon_entries,
 region,
 version_groups,
        }
    }
}

/// Converts the PokedexDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokedexDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.is_main_series.as_ref().map(|is_main_series| {
                [
                    "is_main_series".to_string(),
                    is_main_series.to_string(),
                ].join(",")
            }),

            // Skipping descriptions in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping pokemon_entries in query parameter serialization

            // Skipping region in query parameter serialization

            // Skipping version_groups in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokedexDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokedexDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub is_main_series: Vec<bool>,
            pub descriptions: Vec<Vec<models::PokedexDescription>>,
            pub names: Vec<Vec<models::PokedexName>>,
            pub pokemon_entries: Vec<Vec<models::PokedexDetailPokemonEntriesInner>>,
            pub region: Vec<models::RegionSummary>,
            pub version_groups: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokedexDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_main_series" => intermediate_rep.is_main_series.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in PokedexDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokedexDetail".to_string()),
                    "pokemon_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in PokedexDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "region" => intermediate_rep.region.push(<models::RegionSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "version_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in PokedexDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokedexDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokedexDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PokedexDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokedexDetail".to_string())?,
            is_main_series: intermediate_rep.is_main_series.into_iter().next(),
            descriptions: intermediate_rep.descriptions.into_iter().next().ok_or_else(|| "descriptions missing in PokedexDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in PokedexDetail".to_string())?,
            pokemon_entries: intermediate_rep.pokemon_entries.into_iter().next().ok_or_else(|| "pokemon_entries missing in PokedexDetail".to_string())?,
            region: intermediate_rep.region.into_iter().next().ok_or_else(|| "region missing in PokedexDetail".to_string())?,
            version_groups: intermediate_rep.version_groups.into_iter().next().ok_or_else(|| "version_groups missing in PokedexDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokedexDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokedexDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokedexDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokedexDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokedexDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokedexDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokedexDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokedexDetailPokemonEntriesInner {
    #[serde(rename = "entry_number")]
    pub entry_number: i32,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: models::AbilityDetailPokemonInnerPokemon,

}



impl PokedexDetailPokemonEntriesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(entry_number: i32, pokemon_species: models::AbilityDetailPokemonInnerPokemon, ) -> PokedexDetailPokemonEntriesInner {
        PokedexDetailPokemonEntriesInner {
 entry_number,
 pokemon_species,
        }
    }
}

/// Converts the PokedexDetailPokemonEntriesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokedexDetailPokemonEntriesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("entry_number".to_string()),
            Some(self.entry_number.to_string()),

            // Skipping pokemon_species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokedexDetailPokemonEntriesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokedexDetailPokemonEntriesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub entry_number: Vec<i32>,
            pub pokemon_species: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokedexDetailPokemonEntriesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "entry_number" => intermediate_rep.entry_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokemon_species" => intermediate_rep.pokemon_species.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokedexDetailPokemonEntriesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokedexDetailPokemonEntriesInner {
            entry_number: intermediate_rep.entry_number.into_iter().next().ok_or_else(|| "entry_number missing in PokedexDetailPokemonEntriesInner".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in PokedexDetailPokemonEntriesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokedexDetailPokemonEntriesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokedexDetailPokemonEntriesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokedexDetailPokemonEntriesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokedexDetailPokemonEntriesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokedexDetailPokemonEntriesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokedexDetailPokemonEntriesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokedexDetailPokemonEntriesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokedexName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl PokedexName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> PokedexName {
        PokedexName {
 name,
 language,
        }
    }
}

/// Converts the PokedexName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokedexName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokedexName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokedexName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokedexName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokedexName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokedexName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokedexName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokedexName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokedexName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokedexName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokedexName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokedexName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokedexName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokedexName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokedexName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokedexSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokedexSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokedexSummary {
        PokedexSummary {
 name,
 url,
        }
    }
}

/// Converts the PokedexSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokedexSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokedexSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokedexSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokedexSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokedexSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokedexSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokedexSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokedexSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokedexSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokedexSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokedexSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokedexSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokedexSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokedexSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokedexSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonColorDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::PokemonColorName>,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: Vec<models::PokemonSpeciesSummary>,

}



impl PokemonColorDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::PokemonColorName>, pokemon_species: Vec<models::PokemonSpeciesSummary>, ) -> PokemonColorDetail {
        PokemonColorDetail {
 id,
 name,
 names,
 pokemon_species,
        }
    }
}

/// Converts the PokemonColorDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonColorDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping names in query parameter serialization

            // Skipping pokemon_species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonColorDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonColorDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub names: Vec<Vec<models::PokemonColorName>>,
            pub pokemon_species: Vec<Vec<models::PokemonSpeciesSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonColorDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonColorDetail".to_string()),
                    "pokemon_species" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonColorDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonColorDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonColorDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PokemonColorDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonColorDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in PokemonColorDetail".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in PokemonColorDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonColorDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonColorDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonColorDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonColorDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonColorDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonColorDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonColorDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonColorName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl PokemonColorName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> PokemonColorName {
        PokemonColorName {
 name,
 language,
        }
    }
}

/// Converts the PokemonColorName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonColorName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonColorName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonColorName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonColorName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonColorName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonColorName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonColorName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokemonColorName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonColorName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonColorName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonColorName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonColorName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonColorName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonColorName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonColorName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonColorSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonColorSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonColorSummary {
        PokemonColorSummary {
 name,
 url,
        }
    }
}

/// Converts the PokemonColorSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonColorSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonColorSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonColorSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonColorSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonColorSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonColorSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonColorSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonColorSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonColorSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonColorSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonColorSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonColorSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonColorSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonColorSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonColorSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "base_experience")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_experience: Option<Nullable<i32>>,

    #[serde(rename = "height")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub height: Option<Nullable<i32>>,

    #[serde(rename = "is_default")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_default: Option<bool>,

    #[serde(rename = "order")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order: Option<Nullable<i32>>,

    #[serde(rename = "weight")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub weight: Option<Nullable<i32>>,

    #[serde(rename = "abilities")]
          #[validate(nested)]
    pub abilities: Vec<models::PokemonDetailAbilitiesInner>,

    #[serde(rename = "past_abilities")]
          #[validate(nested)]
    pub past_abilities: Vec<models::PokemonDetailPastAbilitiesInner>,

    #[serde(rename = "forms")]
          #[validate(nested)]
    pub forms: Vec<models::PokemonFormSummary>,

    #[serde(rename = "game_indices")]
          #[validate(nested)]
    pub game_indices: Vec<models::PokemonGameIndex>,

    #[serde(rename = "held_items")]
          #[validate(nested)]
    pub held_items: models::PokemonDetailHeldItems,

    #[serde(rename = "location_area_encounters")]
          #[validate(custom(function = "check_xss_string"))]
    pub location_area_encounters: String,

    #[serde(rename = "moves")]
          #[validate(nested)]
    pub moves: Vec<models::PokemonDetailMovesInner>,

    #[serde(rename = "species")]
          #[validate(nested)]
    pub species: models::PokemonSpeciesSummary,

    #[serde(rename = "sprites")]
          #[validate(nested)]
    pub sprites: models::PokemonDetailSprites,

    #[serde(rename = "cries")]
          #[validate(nested)]
    pub cries: models::PokemonDetailCries,

    #[serde(rename = "stats")]
          #[validate(nested)]
    pub stats: Vec<models::PokemonStat>,

    #[serde(rename = "types")]
          #[validate(nested)]
    pub types: Vec<models::PokemonDetailTypesInner>,

    #[serde(rename = "past_types")]
          #[validate(nested)]
    pub past_types: Vec<models::PokemonDetailPastTypesInner>,

}



impl PokemonDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, abilities: Vec<models::PokemonDetailAbilitiesInner>, past_abilities: Vec<models::PokemonDetailPastAbilitiesInner>, forms: Vec<models::PokemonFormSummary>, game_indices: Vec<models::PokemonGameIndex>, held_items: models::PokemonDetailHeldItems, location_area_encounters: String, moves: Vec<models::PokemonDetailMovesInner>, species: models::PokemonSpeciesSummary, sprites: models::PokemonDetailSprites, cries: models::PokemonDetailCries, stats: Vec<models::PokemonStat>, types: Vec<models::PokemonDetailTypesInner>, past_types: Vec<models::PokemonDetailPastTypesInner>, ) -> PokemonDetail {
        PokemonDetail {
 id,
 name,
 base_experience: None,
 height: None,
 is_default: None,
 order: None,
 weight: None,
 abilities,
 past_abilities,
 forms,
 game_indices,
 held_items,
 location_area_encounters,
 moves,
 species,
 sprites,
 cries,
 stats,
 types,
 past_types,
        }
    }
}

/// Converts the PokemonDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.base_experience.as_ref().map(|base_experience| {
                [
                    "base_experience".to_string(),
                    base_experience.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.height.as_ref().map(|height| {
                [
                    "height".to_string(),
                    height.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_default.as_ref().map(|is_default| {
                [
                    "is_default".to_string(),
                    is_default.to_string(),
                ].join(",")
            }),


            self.order.as_ref().map(|order| {
                [
                    "order".to_string(),
                    order.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.weight.as_ref().map(|weight| {
                [
                    "weight".to_string(),
                    weight.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping abilities in query parameter serialization

            // Skipping past_abilities in query parameter serialization

            // Skipping forms in query parameter serialization

            // Skipping game_indices in query parameter serialization

            // Skipping held_items in query parameter serialization


            Some("location_area_encounters".to_string()),
            Some(self.location_area_encounters.to_string()),

            // Skipping moves in query parameter serialization

            // Skipping species in query parameter serialization

            // Skipping sprites in query parameter serialization

            // Skipping cries in query parameter serialization

            // Skipping stats in query parameter serialization

            // Skipping types in query parameter serialization

            // Skipping past_types in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub base_experience: Vec<i32>,
            pub height: Vec<i32>,
            pub is_default: Vec<bool>,
            pub order: Vec<i32>,
            pub weight: Vec<i32>,
            pub abilities: Vec<Vec<models::PokemonDetailAbilitiesInner>>,
            pub past_abilities: Vec<Vec<models::PokemonDetailPastAbilitiesInner>>,
            pub forms: Vec<Vec<models::PokemonFormSummary>>,
            pub game_indices: Vec<Vec<models::PokemonGameIndex>>,
            pub held_items: Vec<models::PokemonDetailHeldItems>,
            pub location_area_encounters: Vec<String>,
            pub moves: Vec<Vec<models::PokemonDetailMovesInner>>,
            pub species: Vec<models::PokemonSpeciesSummary>,
            pub sprites: Vec<models::PokemonDetailSprites>,
            pub cries: Vec<models::PokemonDetailCries>,
            pub stats: Vec<Vec<models::PokemonStat>>,
            pub types: Vec<Vec<models::PokemonDetailTypesInner>>,
            pub past_types: Vec<Vec<models::PokemonDetailPastTypesInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "base_experience" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonDetail".to_string()),
                    "height" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_default" => intermediate_rep.is_default.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "order" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonDetail".to_string()),
                    "weight" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonDetail".to_string()),
                    "abilities" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetail".to_string()),
                    "past_abilities" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetail".to_string()),
                    "forms" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetail".to_string()),
                    "game_indices" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "held_items" => intermediate_rep.held_items.push(<models::PokemonDetailHeldItems as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "location_area_encounters" => intermediate_rep.location_area_encounters.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "moves" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "species" => intermediate_rep.species.push(<models::PokemonSpeciesSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sprites" => intermediate_rep.sprites.push(<models::PokemonDetailSprites as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "cries" => intermediate_rep.cries.push(<models::PokemonDetailCries as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "stats" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetail".to_string()),
                    "types" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetail".to_string()),
                    "past_types" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PokemonDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonDetail".to_string())?,
            base_experience: std::result::Result::Err("Nullable types not supported in PokemonDetail".to_string())?,
            height: std::result::Result::Err("Nullable types not supported in PokemonDetail".to_string())?,
            is_default: intermediate_rep.is_default.into_iter().next(),
            order: std::result::Result::Err("Nullable types not supported in PokemonDetail".to_string())?,
            weight: std::result::Result::Err("Nullable types not supported in PokemonDetail".to_string())?,
            abilities: intermediate_rep.abilities.into_iter().next().ok_or_else(|| "abilities missing in PokemonDetail".to_string())?,
            past_abilities: intermediate_rep.past_abilities.into_iter().next().ok_or_else(|| "past_abilities missing in PokemonDetail".to_string())?,
            forms: intermediate_rep.forms.into_iter().next().ok_or_else(|| "forms missing in PokemonDetail".to_string())?,
            game_indices: intermediate_rep.game_indices.into_iter().next().ok_or_else(|| "game_indices missing in PokemonDetail".to_string())?,
            held_items: intermediate_rep.held_items.into_iter().next().ok_or_else(|| "held_items missing in PokemonDetail".to_string())?,
            location_area_encounters: intermediate_rep.location_area_encounters.into_iter().next().ok_or_else(|| "location_area_encounters missing in PokemonDetail".to_string())?,
            moves: intermediate_rep.moves.into_iter().next().ok_or_else(|| "moves missing in PokemonDetail".to_string())?,
            species: intermediate_rep.species.into_iter().next().ok_or_else(|| "species missing in PokemonDetail".to_string())?,
            sprites: intermediate_rep.sprites.into_iter().next().ok_or_else(|| "sprites missing in PokemonDetail".to_string())?,
            cries: intermediate_rep.cries.into_iter().next().ok_or_else(|| "cries missing in PokemonDetail".to_string())?,
            stats: intermediate_rep.stats.into_iter().next().ok_or_else(|| "stats missing in PokemonDetail".to_string())?,
            types: intermediate_rep.types.into_iter().next().ok_or_else(|| "types missing in PokemonDetail".to_string())?,
            past_types: intermediate_rep.past_types.into_iter().next().ok_or_else(|| "past_types missing in PokemonDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailAbilitiesInner {
    #[serde(rename = "ability")]
          #[validate(nested)]
    pub ability: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "is_hidden")]
    pub is_hidden: bool,

    #[serde(rename = "slot")]
    pub slot: i32,

}



impl PokemonDetailAbilitiesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(ability: models::AbilityDetailPokemonInnerPokemon, is_hidden: bool, slot: i32, ) -> PokemonDetailAbilitiesInner {
        PokemonDetailAbilitiesInner {
 ability,
 is_hidden,
 slot,
        }
    }
}

/// Converts the PokemonDetailAbilitiesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailAbilitiesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping ability in query parameter serialization


            Some("is_hidden".to_string()),
            Some(self.is_hidden.to_string()),


            Some("slot".to_string()),
            Some(self.slot.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailAbilitiesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailAbilitiesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub ability: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub is_hidden: Vec<bool>,
            pub slot: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailAbilitiesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "ability" => intermediate_rep.ability.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_hidden" => intermediate_rep.is_hidden.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "slot" => intermediate_rep.slot.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailAbilitiesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailAbilitiesInner {
            ability: intermediate_rep.ability.into_iter().next().ok_or_else(|| "ability missing in PokemonDetailAbilitiesInner".to_string())?,
            is_hidden: intermediate_rep.is_hidden.into_iter().next().ok_or_else(|| "is_hidden missing in PokemonDetailAbilitiesInner".to_string())?,
            slot: intermediate_rep.slot.into_iter().next().ok_or_else(|| "slot missing in PokemonDetailAbilitiesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailAbilitiesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailAbilitiesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailAbilitiesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailAbilitiesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailAbilitiesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailAbilitiesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailAbilitiesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailCries {
    #[serde(rename = "latest")]
          #[validate(custom(function = "check_xss_string"))]
    pub latest: String,

    #[serde(rename = "legacy")]
          #[validate(custom(function = "check_xss_string"))]
    pub legacy: String,

}



impl PokemonDetailCries {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(latest: String, legacy: String, ) -> PokemonDetailCries {
        PokemonDetailCries {
 latest,
 legacy,
        }
    }
}

/// Converts the PokemonDetailCries value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailCries {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("latest".to_string()),
            Some(self.latest.to_string()),


            Some("legacy".to_string()),
            Some(self.legacy.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailCries value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailCries {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub latest: Vec<String>,
            pub legacy: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailCries".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "latest" => intermediate_rep.latest.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "legacy" => intermediate_rep.legacy.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailCries".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailCries {
            latest: intermediate_rep.latest.into_iter().next().ok_or_else(|| "latest missing in PokemonDetailCries".to_string())?,
            legacy: intermediate_rep.legacy.into_iter().next().ok_or_else(|| "legacy missing in PokemonDetailCries".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailCries> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailCries>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailCries>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailCries - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailCries> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailCries as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailCries - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailHeldItems {
    #[serde(rename = "item")]
          #[validate(nested)]
    pub item: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "version_details")]
          #[validate(nested)]
    pub version_details: Vec<models::ItemDetailHeldByPokemonInnerVersionDetailsInner>,

}



impl PokemonDetailHeldItems {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(item: models::AbilityDetailPokemonInnerPokemon, version_details: Vec<models::ItemDetailHeldByPokemonInnerVersionDetailsInner>, ) -> PokemonDetailHeldItems {
        PokemonDetailHeldItems {
 item,
 version_details,
        }
    }
}

/// Converts the PokemonDetailHeldItems value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailHeldItems {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping item in query parameter serialization

            // Skipping version_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailHeldItems value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailHeldItems {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub item: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub version_details: Vec<Vec<models::ItemDetailHeldByPokemonInnerVersionDetailsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailHeldItems".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "item" => intermediate_rep.item.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "version_details" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetailHeldItems".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailHeldItems".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailHeldItems {
            item: intermediate_rep.item.into_iter().next().ok_or_else(|| "item missing in PokemonDetailHeldItems".to_string())?,
            version_details: intermediate_rep.version_details.into_iter().next().ok_or_else(|| "version_details missing in PokemonDetailHeldItems".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailHeldItems> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailHeldItems>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailHeldItems>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailHeldItems - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailHeldItems> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailHeldItems as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailHeldItems - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailMovesInner {
    #[serde(rename = "move")]
          #[validate(nested)]
    pub r_move: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "version_group_details")]
          #[validate(nested)]
    pub version_group_details: Vec<models::PokemonDetailMovesInnerVersionGroupDetailsInner>,

}



impl PokemonDetailMovesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(r_move: models::AbilityDetailPokemonInnerPokemon, version_group_details: Vec<models::PokemonDetailMovesInnerVersionGroupDetailsInner>, ) -> PokemonDetailMovesInner {
        PokemonDetailMovesInner {
 r_move,
 version_group_details,
        }
    }
}

/// Converts the PokemonDetailMovesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailMovesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping move in query parameter serialization

            // Skipping version_group_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailMovesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailMovesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub r_move: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub version_group_details: Vec<Vec<models::PokemonDetailMovesInnerVersionGroupDetailsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailMovesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "move" => intermediate_rep.r_move.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "version_group_details" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetailMovesInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailMovesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailMovesInner {
            r_move: intermediate_rep.r_move.into_iter().next().ok_or_else(|| "move missing in PokemonDetailMovesInner".to_string())?,
            version_group_details: intermediate_rep.version_group_details.into_iter().next().ok_or_else(|| "version_group_details missing in PokemonDetailMovesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailMovesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailMovesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailMovesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailMovesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailMovesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailMovesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailMovesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailMovesInnerVersionGroupDetailsInner {
    #[serde(rename = "level_learned_at")]
    pub level_learned_at: i32,

    #[serde(rename = "move_learn_method")]
          #[validate(nested)]
    pub move_learn_method: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::AbilityDetailPokemonInnerPokemon,

}



impl PokemonDetailMovesInnerVersionGroupDetailsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(level_learned_at: i32, move_learn_method: models::AbilityDetailPokemonInnerPokemon, version_group: models::AbilityDetailPokemonInnerPokemon, ) -> PokemonDetailMovesInnerVersionGroupDetailsInner {
        PokemonDetailMovesInnerVersionGroupDetailsInner {
 level_learned_at,
 move_learn_method,
 version_group,
        }
    }
}

/// Converts the PokemonDetailMovesInnerVersionGroupDetailsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailMovesInnerVersionGroupDetailsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("level_learned_at".to_string()),
            Some(self.level_learned_at.to_string()),

            // Skipping move_learn_method in query parameter serialization

            // Skipping version_group in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailMovesInnerVersionGroupDetailsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailMovesInnerVersionGroupDetailsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub level_learned_at: Vec<i32>,
            pub move_learn_method: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub version_group: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailMovesInnerVersionGroupDetailsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "level_learned_at" => intermediate_rep.level_learned_at.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "move_learn_method" => intermediate_rep.move_learn_method.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailMovesInnerVersionGroupDetailsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailMovesInnerVersionGroupDetailsInner {
            level_learned_at: intermediate_rep.level_learned_at.into_iter().next().ok_or_else(|| "level_learned_at missing in PokemonDetailMovesInnerVersionGroupDetailsInner".to_string())?,
            move_learn_method: intermediate_rep.move_learn_method.into_iter().next().ok_or_else(|| "move_learn_method missing in PokemonDetailMovesInnerVersionGroupDetailsInner".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in PokemonDetailMovesInnerVersionGroupDetailsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailMovesInnerVersionGroupDetailsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailMovesInnerVersionGroupDetailsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailMovesInnerVersionGroupDetailsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailMovesInnerVersionGroupDetailsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailMovesInnerVersionGroupDetailsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailMovesInnerVersionGroupDetailsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailMovesInnerVersionGroupDetailsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailPastAbilitiesInner {
    #[serde(rename = "abilities")]
          #[validate(nested)]
    pub abilities: Vec<models::PokemonDetailAbilitiesInner>,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::AbilityDetailPokemonInnerPokemon,

}



impl PokemonDetailPastAbilitiesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(abilities: Vec<models::PokemonDetailAbilitiesInner>, generation: models::AbilityDetailPokemonInnerPokemon, ) -> PokemonDetailPastAbilitiesInner {
        PokemonDetailPastAbilitiesInner {
 abilities,
 generation,
        }
    }
}

/// Converts the PokemonDetailPastAbilitiesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailPastAbilitiesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping abilities in query parameter serialization

            // Skipping generation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailPastAbilitiesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailPastAbilitiesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub abilities: Vec<Vec<models::PokemonDetailAbilitiesInner>>,
            pub generation: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailPastAbilitiesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "abilities" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetailPastAbilitiesInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailPastAbilitiesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailPastAbilitiesInner {
            abilities: intermediate_rep.abilities.into_iter().next().ok_or_else(|| "abilities missing in PokemonDetailPastAbilitiesInner".to_string())?,
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in PokemonDetailPastAbilitiesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailPastAbilitiesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailPastAbilitiesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailPastAbilitiesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailPastAbilitiesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailPastAbilitiesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailPastAbilitiesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailPastAbilitiesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailPastTypesInner {
    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "types")]
          #[validate(nested)]
    pub types: Vec<models::PokemonDetailTypesInner>,

}



impl PokemonDetailPastTypesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(generation: models::AbilityDetailPokemonInnerPokemon, types: Vec<models::PokemonDetailTypesInner>, ) -> PokemonDetailPastTypesInner {
        PokemonDetailPastTypesInner {
 generation,
 types,
        }
    }
}

/// Converts the PokemonDetailPastTypesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailPastTypesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping generation in query parameter serialization

            // Skipping types in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailPastTypesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailPastTypesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub generation: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub types: Vec<Vec<models::PokemonDetailTypesInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailPastTypesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "types" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonDetailPastTypesInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailPastTypesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailPastTypesInner {
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in PokemonDetailPastTypesInner".to_string())?,
            types: intermediate_rep.types.into_iter().next().ok_or_else(|| "types missing in PokemonDetailPastTypesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailPastTypesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailPastTypesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailPastTypesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailPastTypesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailPastTypesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailPastTypesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailPastTypesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailSprites {
    #[serde(rename = "front_default")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub front_default: Option<String>,

}



impl PokemonDetailSprites {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PokemonDetailSprites {
        PokemonDetailSprites {
 front_default: None,
        }
    }
}

/// Converts the PokemonDetailSprites value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailSprites {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.front_default.as_ref().map(|front_default| {
                [
                    "front_default".to_string(),
                    front_default.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailSprites value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailSprites {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub front_default: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailSprites".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "front_default" => intermediate_rep.front_default.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailSprites".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailSprites {
            front_default: intermediate_rep.front_default.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailSprites> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailSprites>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailSprites>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailSprites - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailSprites> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailSprites as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailSprites - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDetailTypesInner {
    #[serde(rename = "slot")]
    pub slot: i32,

    #[serde(rename = "type")]
          #[validate(nested)]
    pub r_type: models::AbilityDetailPokemonInnerPokemon,

}



impl PokemonDetailTypesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(slot: i32, r_type: models::AbilityDetailPokemonInnerPokemon, ) -> PokemonDetailTypesInner {
        PokemonDetailTypesInner {
 slot,
 r_type,
        }
    }
}

/// Converts the PokemonDetailTypesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDetailTypesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("slot".to_string()),
            Some(self.slot.to_string()),

            // Skipping type in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDetailTypesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDetailTypesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub slot: Vec<i32>,
            pub r_type: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDetailTypesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "slot" => intermediate_rep.slot.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "type" => intermediate_rep.r_type.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDetailTypesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDetailTypesInner {
            slot: intermediate_rep.slot.into_iter().next().ok_or_else(|| "slot missing in PokemonDetailTypesInner".to_string())?,
            r_type: intermediate_rep.r_type.into_iter().next().ok_or_else(|| "type missing in PokemonDetailTypesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDetailTypesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDetailTypesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDetailTypesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDetailTypesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDetailTypesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDetailTypesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDetailTypesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonDexEntry {
    #[serde(rename = "entry_number")]
    pub entry_number: i32,

    #[serde(rename = "pokedex")]
          #[validate(nested)]
    pub pokedex: models::PokedexSummary,

}



impl PokemonDexEntry {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(entry_number: i32, pokedex: models::PokedexSummary, ) -> PokemonDexEntry {
        PokemonDexEntry {
 entry_number,
 pokedex,
        }
    }
}

/// Converts the PokemonDexEntry value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonDexEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("entry_number".to_string()),
            Some(self.entry_number.to_string()),

            // Skipping pokedex in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonDexEntry value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonDexEntry {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub entry_number: Vec<i32>,
            pub pokedex: Vec<models::PokedexSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonDexEntry".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "entry_number" => intermediate_rep.entry_number.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokedex" => intermediate_rep.pokedex.push(<models::PokedexSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonDexEntry".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonDexEntry {
            entry_number: intermediate_rep.entry_number.into_iter().next().ok_or_else(|| "entry_number missing in PokemonDexEntry".to_string())?,
            pokedex: intermediate_rep.pokedex.into_iter().next().ok_or_else(|| "pokedex missing in PokemonDexEntry".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonDexEntry> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonDexEntry>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonDexEntry>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonDexEntry - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonDexEntry> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonDexEntry as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonDexEntry - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonEncountersRetrieve200ResponseInner {
    #[serde(rename = "location_area")]
          #[validate(nested)]
    pub location_area: models::PokemonEncountersRetrieve200ResponseInnerLocationArea,

    #[serde(rename = "version_details")]
          #[validate(nested)]
    pub version_details: Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner>,

}



impl PokemonEncountersRetrieve200ResponseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(location_area: models::PokemonEncountersRetrieve200ResponseInnerLocationArea, version_details: Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner>, ) -> PokemonEncountersRetrieve200ResponseInner {
        PokemonEncountersRetrieve200ResponseInner {
 location_area,
 version_details,
        }
    }
}

/// Converts the PokemonEncountersRetrieve200ResponseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonEncountersRetrieve200ResponseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping location_area in query parameter serialization

            // Skipping version_details in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonEncountersRetrieve200ResponseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonEncountersRetrieve200ResponseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub location_area: Vec<models::PokemonEncountersRetrieve200ResponseInnerLocationArea>,
            pub version_details: Vec<Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonEncountersRetrieve200ResponseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "location_area" => intermediate_rep.location_area.push(<models::PokemonEncountersRetrieve200ResponseInnerLocationArea as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "version_details" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonEncountersRetrieve200ResponseInner".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonEncountersRetrieve200ResponseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonEncountersRetrieve200ResponseInner {
            location_area: intermediate_rep.location_area.into_iter().next().ok_or_else(|| "location_area missing in PokemonEncountersRetrieve200ResponseInner".to_string())?,
            version_details: intermediate_rep.version_details.into_iter().next().ok_or_else(|| "version_details missing in PokemonEncountersRetrieve200ResponseInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonEncountersRetrieve200ResponseInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonEncountersRetrieve200ResponseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonEncountersRetrieve200ResponseInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonEncountersRetrieve200ResponseInnerLocationArea {
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonEncountersRetrieve200ResponseInnerLocationArea {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonEncountersRetrieve200ResponseInnerLocationArea {
        PokemonEncountersRetrieve200ResponseInnerLocationArea {
 name,
 url,
        }
    }
}

/// Converts the PokemonEncountersRetrieve200ResponseInnerLocationArea value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonEncountersRetrieve200ResponseInnerLocationArea {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonEncountersRetrieve200ResponseInnerLocationArea value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonEncountersRetrieve200ResponseInnerLocationArea {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonEncountersRetrieve200ResponseInnerLocationArea".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonEncountersRetrieve200ResponseInnerLocationArea".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonEncountersRetrieve200ResponseInnerLocationArea {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonEncountersRetrieve200ResponseInnerLocationArea".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonEncountersRetrieve200ResponseInnerLocationArea".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerLocationArea> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerLocationArea>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerLocationArea>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonEncountersRetrieve200ResponseInnerLocationArea - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerLocationArea> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonEncountersRetrieve200ResponseInnerLocationArea as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonEncountersRetrieve200ResponseInnerLocationArea - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner {
    #[serde(rename = "encounter_details")]
          #[validate(nested)]
    pub encounter_details: Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner>,

    #[serde(rename = "max_chance")]
    pub max_chance: f64,

    #[serde(rename = "version")]
          #[validate(nested)]
    pub version: models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion,

}



impl PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(encounter_details: Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner>, max_chance: f64, version: models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion, ) -> PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner {
        PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner {
 encounter_details,
 max_chance,
 version,
        }
    }
}

/// Converts the PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping encounter_details in query parameter serialization


            Some("max_chance".to_string()),
            Some(self.max_chance.to_string()),

            // Skipping version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub encounter_details: Vec<Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner>>,
            pub max_chance: Vec<f64>,
            pub version: Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "encounter_details" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "max_chance" => intermediate_rep.max_chance.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner {
            encounter_details: intermediate_rep.encounter_details.into_iter().next().ok_or_else(|| "encounter_details missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner".to_string())?,
            max_chance: intermediate_rep.max_chance.into_iter().next().ok_or_else(|| "max_chance missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner".to_string())?,
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| "version missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonEncountersRetrieve200ResponseInnerVersionDetailsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner {
    #[serde(rename = "chance")]
    pub chance: f64,

    #[serde(rename = "condition_values")]
          #[validate(nested)]
    pub condition_values: Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner>,

    #[serde(rename = "max_level")]
    pub max_level: f64,

    #[serde(rename = "method")]
          #[validate(nested)]
    pub method: models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod,

    #[serde(rename = "min_level")]
    pub min_level: f64,

}



impl PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(chance: f64, condition_values: Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner>, max_level: f64, method: models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod, min_level: f64, ) -> PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner {
        PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner {
 chance,
 condition_values,
 max_level,
 method,
 min_level,
        }
    }
}

/// Converts the PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("chance".to_string()),
            Some(self.chance.to_string()),

            // Skipping condition_values in query parameter serialization


            Some("max_level".to_string()),
            Some(self.max_level.to_string()),

            // Skipping method in query parameter serialization


            Some("min_level".to_string()),
            Some(self.min_level.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub chance: Vec<f64>,
            pub condition_values: Vec<Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner>>,
            pub max_level: Vec<f64>,
            pub method: Vec<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod>,
            pub min_level: Vec<f64>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "chance" => intermediate_rep.chance.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "condition_values" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "max_level" => intermediate_rep.max_level.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "method" => intermediate_rep.method.push(<models::PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "min_level" => intermediate_rep.min_level.push(<f64 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner {
            chance: intermediate_rep.chance.into_iter().next().ok_or_else(|| "chance missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner".to_string())?,
            condition_values: intermediate_rep.condition_values.into_iter().next().ok_or_else(|| "condition_values missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner".to_string())?,
            max_level: intermediate_rep.max_level.into_iter().next().ok_or_else(|| "max_level missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner".to_string())?,
            method: intermediate_rep.method.into_iter().next().ok_or_else(|| "method missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner".to_string())?,
            min_level: intermediate_rep.min_level.into_iter().next().ok_or_else(|| "min_level missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner {
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner {
        PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner {
 name,
 url,
        }
    }
}

/// Converts the PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerConditionValuesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod {
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod {
        PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod {
 name,
 url,
        }
    }
}

/// Converts the PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerEncounterDetailsInnerMethod - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion {
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion {
        PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion {
 name,
 url,
        }
    }
}

/// Converts the PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonEncountersRetrieve200ResponseInnerVersionDetailsInnerVersion - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonFormDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "order")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order: Option<Nullable<i32>>,

    #[serde(rename = "form_order")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub form_order: Option<Nullable<i32>>,

    #[serde(rename = "is_default")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_default: Option<bool>,

    #[serde(rename = "is_battle_only")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_battle_only: Option<bool>,

    #[serde(rename = "is_mega")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_mega: Option<bool>,

    #[serde(rename = "form_name")]
    #[validate(
            length(max = 30),
          custom(function = "check_xss_string"),
    )]
    pub form_name: String,

    #[serde(rename = "pokemon")]
          #[validate(nested)]
    pub pokemon: models::PokemonSummary,

    #[serde(rename = "sprites")]
          #[validate(nested)]
    pub sprites: models::PokemonFormDetailSprites,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::VersionGroupSummary,

    #[serde(rename = "form_names")]
          #[validate(nested)]
    pub form_names: Vec<models::PokemonFormDetailFormNamesInner>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::PokemonFormDetailFormNamesInner>,

    #[serde(rename = "types")]
          #[validate(nested)]
    pub types: Vec<models::PokemonDetailTypesInner>,

}



impl PokemonFormDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, form_name: String, pokemon: models::PokemonSummary, sprites: models::PokemonFormDetailSprites, version_group: models::VersionGroupSummary, form_names: Vec<models::PokemonFormDetailFormNamesInner>, names: Vec<models::PokemonFormDetailFormNamesInner>, types: Vec<models::PokemonDetailTypesInner>, ) -> PokemonFormDetail {
        PokemonFormDetail {
 id,
 name,
 order: None,
 form_order: None,
 is_default: None,
 is_battle_only: None,
 is_mega: None,
 form_name,
 pokemon,
 sprites,
 version_group,
 form_names,
 names,
 types,
        }
    }
}

/// Converts the PokemonFormDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonFormDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.order.as_ref().map(|order| {
                [
                    "order".to_string(),
                    order.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.form_order.as_ref().map(|form_order| {
                [
                    "form_order".to_string(),
                    form_order.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_default.as_ref().map(|is_default| {
                [
                    "is_default".to_string(),
                    is_default.to_string(),
                ].join(",")
            }),


            self.is_battle_only.as_ref().map(|is_battle_only| {
                [
                    "is_battle_only".to_string(),
                    is_battle_only.to_string(),
                ].join(",")
            }),


            self.is_mega.as_ref().map(|is_mega| {
                [
                    "is_mega".to_string(),
                    is_mega.to_string(),
                ].join(",")
            }),


            Some("form_name".to_string()),
            Some(self.form_name.to_string()),

            // Skipping pokemon in query parameter serialization

            // Skipping sprites in query parameter serialization

            // Skipping version_group in query parameter serialization

            // Skipping form_names in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping types in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonFormDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonFormDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub order: Vec<i32>,
            pub form_order: Vec<i32>,
            pub is_default: Vec<bool>,
            pub is_battle_only: Vec<bool>,
            pub is_mega: Vec<bool>,
            pub form_name: Vec<String>,
            pub pokemon: Vec<models::PokemonSummary>,
            pub sprites: Vec<models::PokemonFormDetailSprites>,
            pub version_group: Vec<models::VersionGroupSummary>,
            pub form_names: Vec<Vec<models::PokemonFormDetailFormNamesInner>>,
            pub names: Vec<Vec<models::PokemonFormDetailFormNamesInner>>,
            pub types: Vec<Vec<models::PokemonDetailTypesInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonFormDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "order" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonFormDetail".to_string()),
                    "form_order" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonFormDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_default" => intermediate_rep.is_default.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_battle_only" => intermediate_rep.is_battle_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_mega" => intermediate_rep.is_mega.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "form_name" => intermediate_rep.form_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokemon" => intermediate_rep.pokemon.push(<models::PokemonSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "sprites" => intermediate_rep.sprites.push(<models::PokemonFormDetailSprites as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::VersionGroupSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "form_names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonFormDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonFormDetail".to_string()),
                    "types" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonFormDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonFormDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonFormDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PokemonFormDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonFormDetail".to_string())?,
            order: std::result::Result::Err("Nullable types not supported in PokemonFormDetail".to_string())?,
            form_order: std::result::Result::Err("Nullable types not supported in PokemonFormDetail".to_string())?,
            is_default: intermediate_rep.is_default.into_iter().next(),
            is_battle_only: intermediate_rep.is_battle_only.into_iter().next(),
            is_mega: intermediate_rep.is_mega.into_iter().next(),
            form_name: intermediate_rep.form_name.into_iter().next().ok_or_else(|| "form_name missing in PokemonFormDetail".to_string())?,
            pokemon: intermediate_rep.pokemon.into_iter().next().ok_or_else(|| "pokemon missing in PokemonFormDetail".to_string())?,
            sprites: intermediate_rep.sprites.into_iter().next().ok_or_else(|| "sprites missing in PokemonFormDetail".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in PokemonFormDetail".to_string())?,
            form_names: intermediate_rep.form_names.into_iter().next().ok_or_else(|| "form_names missing in PokemonFormDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in PokemonFormDetail".to_string())?,
            types: intermediate_rep.types.into_iter().next().ok_or_else(|| "types missing in PokemonFormDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonFormDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonFormDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonFormDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonFormDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonFormDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonFormDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonFormDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonFormDetailFormNamesInner {
    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl PokemonFormDetailFormNamesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::AbilityDetailPokemonInnerPokemon, name: String, ) -> PokemonFormDetailFormNamesInner {
        PokemonFormDetailFormNamesInner {
 language,
 name,
        }
    }
}

/// Converts the PokemonFormDetailFormNamesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonFormDetailFormNamesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping language in query parameter serialization


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonFormDetailFormNamesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonFormDetailFormNamesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub language: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonFormDetailFormNamesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonFormDetailFormNamesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonFormDetailFormNamesInner {
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokemonFormDetailFormNamesInner".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonFormDetailFormNamesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonFormDetailFormNamesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonFormDetailFormNamesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonFormDetailFormNamesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonFormDetailFormNamesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonFormDetailFormNamesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonFormDetailFormNamesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonFormDetailFormNamesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonFormDetailSprites {
    #[serde(rename = "default")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub default: Option<String>,

}



impl PokemonFormDetailSprites {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> PokemonFormDetailSprites {
        PokemonFormDetailSprites {
 default: None,
        }
    }
}

/// Converts the PokemonFormDetailSprites value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonFormDetailSprites {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.default.as_ref().map(|default| {
                [
                    "default".to_string(),
                    default.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonFormDetailSprites value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonFormDetailSprites {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub default: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonFormDetailSprites".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "default" => intermediate_rep.default.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonFormDetailSprites".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonFormDetailSprites {
            default: intermediate_rep.default.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonFormDetailSprites> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonFormDetailSprites>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonFormDetailSprites>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonFormDetailSprites - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonFormDetailSprites> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonFormDetailSprites as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonFormDetailSprites - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonFormSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonFormSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonFormSummary {
        PokemonFormSummary {
 name,
 url,
        }
    }
}

/// Converts the PokemonFormSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonFormSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonFormSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonFormSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonFormSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonFormSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonFormSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonFormSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonFormSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonFormSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonFormSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonFormSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonFormSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonFormSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonFormSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonFormSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonGameIndex {
    #[serde(rename = "game_index")]
    pub game_index: i32,

    #[serde(rename = "version")]
          #[validate(nested)]
    pub version: models::VersionSummary,

}



impl PokemonGameIndex {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(game_index: i32, version: models::VersionSummary, ) -> PokemonGameIndex {
        PokemonGameIndex {
 game_index,
 version,
        }
    }
}

/// Converts the PokemonGameIndex value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonGameIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("game_index".to_string()),
            Some(self.game_index.to_string()),

            // Skipping version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonGameIndex value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonGameIndex {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub game_index: Vec<i32>,
            pub version: Vec<models::VersionSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonGameIndex".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "game_index" => intermediate_rep.game_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<models::VersionSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonGameIndex".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonGameIndex {
            game_index: intermediate_rep.game_index.into_iter().next().ok_or_else(|| "game_index missing in PokemonGameIndex".to_string())?,
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| "version missing in PokemonGameIndex".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonGameIndex> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonGameIndex>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonGameIndex>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonGameIndex - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonGameIndex> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonGameIndex as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonGameIndex - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonHabitatDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::PokemonHabitatName>,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: Vec<models::PokemonSpeciesSummary>,

}



impl PokemonHabitatDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::PokemonHabitatName>, pokemon_species: Vec<models::PokemonSpeciesSummary>, ) -> PokemonHabitatDetail {
        PokemonHabitatDetail {
 id,
 name,
 names,
 pokemon_species,
        }
    }
}

/// Converts the PokemonHabitatDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonHabitatDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping names in query parameter serialization

            // Skipping pokemon_species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonHabitatDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonHabitatDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub names: Vec<Vec<models::PokemonHabitatName>>,
            pub pokemon_species: Vec<Vec<models::PokemonSpeciesSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonHabitatDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonHabitatDetail".to_string()),
                    "pokemon_species" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonHabitatDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonHabitatDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonHabitatDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PokemonHabitatDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonHabitatDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in PokemonHabitatDetail".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in PokemonHabitatDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonHabitatDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonHabitatDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonHabitatDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonHabitatDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonHabitatDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonHabitatDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonHabitatDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonHabitatName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl PokemonHabitatName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> PokemonHabitatName {
        PokemonHabitatName {
 name,
 language,
        }
    }
}

/// Converts the PokemonHabitatName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonHabitatName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonHabitatName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonHabitatName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonHabitatName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonHabitatName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonHabitatName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonHabitatName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokemonHabitatName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonHabitatName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonHabitatName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonHabitatName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonHabitatName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonHabitatName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonHabitatName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonHabitatName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonHabitatSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonHabitatSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonHabitatSummary {
        PokemonHabitatSummary {
 name,
 url,
        }
    }
}

/// Converts the PokemonHabitatSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonHabitatSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonHabitatSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonHabitatSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonHabitatSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonHabitatSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonHabitatSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonHabitatSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonHabitatSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonHabitatSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonHabitatSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonHabitatSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonHabitatSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonHabitatSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonHabitatSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonHabitatSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonShapeDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "awesome_names")]
          #[validate(nested)]
    pub awesome_names: Vec<models::PokemonShapeDetailAwesomeNamesInner>,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::PokemonShapeDetailNamesInner>,

    #[serde(rename = "pokemon_species")]
          #[validate(nested)]
    pub pokemon_species: Vec<models::PokemonSpeciesSummary>,

}



impl PokemonShapeDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, awesome_names: Vec<models::PokemonShapeDetailAwesomeNamesInner>, names: Vec<models::PokemonShapeDetailNamesInner>, pokemon_species: Vec<models::PokemonSpeciesSummary>, ) -> PokemonShapeDetail {
        PokemonShapeDetail {
 id,
 name,
 awesome_names,
 names,
 pokemon_species,
        }
    }
}

/// Converts the PokemonShapeDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonShapeDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping awesome_names in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping pokemon_species in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonShapeDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonShapeDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub awesome_names: Vec<Vec<models::PokemonShapeDetailAwesomeNamesInner>>,
            pub names: Vec<Vec<models::PokemonShapeDetailNamesInner>>,
            pub pokemon_species: Vec<Vec<models::PokemonSpeciesSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonShapeDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "awesome_names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonShapeDetail".to_string()),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonShapeDetail".to_string()),
                    "pokemon_species" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonShapeDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonShapeDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonShapeDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PokemonShapeDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonShapeDetail".to_string())?,
            awesome_names: intermediate_rep.awesome_names.into_iter().next().ok_or_else(|| "awesome_names missing in PokemonShapeDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in PokemonShapeDetail".to_string())?,
            pokemon_species: intermediate_rep.pokemon_species.into_iter().next().ok_or_else(|| "pokemon_species missing in PokemonShapeDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonShapeDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonShapeDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonShapeDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonShapeDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonShapeDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonShapeDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonShapeDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonShapeDetailAwesomeNamesInner {
    #[serde(rename = "awesome_name")]
          #[validate(custom(function = "check_xss_string"))]
    pub awesome_name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::AbilityDetailPokemonInnerPokemon,

}



impl PokemonShapeDetailAwesomeNamesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(awesome_name: String, language: models::AbilityDetailPokemonInnerPokemon, ) -> PokemonShapeDetailAwesomeNamesInner {
        PokemonShapeDetailAwesomeNamesInner {
 awesome_name,
 language,
        }
    }
}

/// Converts the PokemonShapeDetailAwesomeNamesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonShapeDetailAwesomeNamesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("awesome_name".to_string()),
            Some(self.awesome_name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonShapeDetailAwesomeNamesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonShapeDetailAwesomeNamesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub awesome_name: Vec<String>,
            pub language: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonShapeDetailAwesomeNamesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "awesome_name" => intermediate_rep.awesome_name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonShapeDetailAwesomeNamesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonShapeDetailAwesomeNamesInner {
            awesome_name: intermediate_rep.awesome_name.into_iter().next().ok_or_else(|| "awesome_name missing in PokemonShapeDetailAwesomeNamesInner".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokemonShapeDetailAwesomeNamesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonShapeDetailAwesomeNamesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonShapeDetailAwesomeNamesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonShapeDetailAwesomeNamesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonShapeDetailAwesomeNamesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonShapeDetailAwesomeNamesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonShapeDetailAwesomeNamesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonShapeDetailAwesomeNamesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonShapeDetailNamesInner {
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    pub name: String,

}



impl PokemonShapeDetailNamesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, name: String, ) -> PokemonShapeDetailNamesInner {
        PokemonShapeDetailNamesInner {
 url,
 name,
        }
    }
}

/// Converts the PokemonShapeDetailNamesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonShapeDetailNamesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonShapeDetailNamesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonShapeDetailNamesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
            pub name: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonShapeDetailNamesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonShapeDetailNamesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonShapeDetailNamesInner {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonShapeDetailNamesInner".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonShapeDetailNamesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonShapeDetailNamesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonShapeDetailNamesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonShapeDetailNamesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonShapeDetailNamesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonShapeDetailNamesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonShapeDetailNamesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonShapeDetailNamesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonShapeSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonShapeSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonShapeSummary {
        PokemonShapeSummary {
 name,
 url,
        }
    }
}

/// Converts the PokemonShapeSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonShapeSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonShapeSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonShapeSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonShapeSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonShapeSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonShapeSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonShapeSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonShapeSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonShapeSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonShapeSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonShapeSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonShapeSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonShapeSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonShapeSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonShapeSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonSpeciesDescription {
    #[serde(rename = "description")]
    #[validate(
            length(max = 1000),
          custom(function = "check_xss_string"),
    )]
    #[serde(skip_serializing_if="Option::is_none")]
    pub description: Option<String>,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl PokemonSpeciesDescription {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(language: models::LanguageSummary, ) -> PokemonSpeciesDescription {
        PokemonSpeciesDescription {
 description: None,
 language,
        }
    }
}

/// Converts the PokemonSpeciesDescription value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonSpeciesDescription {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.description.as_ref().map(|description| {
                [
                    "description".to_string(),
                    description.to_string(),
                ].join(",")
            }),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonSpeciesDescription value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonSpeciesDescription {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub description: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonSpeciesDescription".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "description" => intermediate_rep.description.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonSpeciesDescription".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonSpeciesDescription {
            description: intermediate_rep.description.into_iter().next(),
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokemonSpeciesDescription".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonSpeciesDescription> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonSpeciesDescription>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonSpeciesDescription>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonSpeciesDescription - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonSpeciesDescription> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonSpeciesDescription as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonSpeciesDescription - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonSpeciesDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "order")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order: Option<Nullable<i32>>,

    #[serde(rename = "gender_rate")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub gender_rate: Option<Nullable<i32>>,

    #[serde(rename = "capture_rate")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub capture_rate: Option<Nullable<i32>>,

    #[serde(rename = "base_happiness")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub base_happiness: Option<Nullable<i32>>,

    #[serde(rename = "is_baby")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_baby: Option<bool>,

    #[serde(rename = "is_legendary")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_legendary: Option<bool>,

    #[serde(rename = "is_mythical")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_mythical: Option<bool>,

    #[serde(rename = "hatch_counter")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub hatch_counter: Option<Nullable<i32>>,

    #[serde(rename = "has_gender_differences")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub has_gender_differences: Option<bool>,

    #[serde(rename = "forms_switchable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub forms_switchable: Option<bool>,

    #[serde(rename = "growth_rate")]
          #[validate(nested)]
    pub growth_rate: models::GrowthRateSummary,

    #[serde(rename = "pokedex_numbers")]
          #[validate(nested)]
    pub pokedex_numbers: Vec<models::PokemonDexEntry>,

    #[serde(rename = "egg_groups")]
          #[validate(nested)]
    pub egg_groups: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "color")]
          #[validate(nested)]
    pub color: models::PokemonColorSummary,

    #[serde(rename = "shape")]
          #[validate(nested)]
    pub shape: models::PokemonShapeSummary,

    #[serde(rename = "evolves_from_species")]
          #[validate(nested)]
    pub evolves_from_species: models::PokemonSpeciesSummary,

    #[serde(rename = "evolution_chain")]
          #[validate(nested)]
    pub evolution_chain: models::EvolutionChainSummary,

    #[serde(rename = "habitat")]
          #[validate(nested)]
    pub habitat: models::PokemonHabitatSummary,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::GenerationSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::PokemonFormDetailFormNamesInner>,

    #[serde(rename = "pal_park_encounters")]
          #[validate(nested)]
    pub pal_park_encounters: Vec<models::PokemonSpeciesDetailPalParkEncountersInner>,

    #[serde(rename = "form_descriptions")]
          #[validate(nested)]
    pub form_descriptions: Vec<models::PokemonSpeciesDescription>,

    #[serde(rename = "flavor_text_entries")]
          #[validate(nested)]
    pub flavor_text_entries: Vec<models::PokemonSpeciesFlavorText>,

    #[serde(rename = "genera")]
          #[validate(nested)]
    pub genera: Vec<models::PokemonSpeciesDetailGeneraInner>,

    #[serde(rename = "varieties")]
          #[validate(nested)]
    pub varieties: Vec<models::PokemonSpeciesDetailVarietiesInner>,

}



impl PokemonSpeciesDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, growth_rate: models::GrowthRateSummary, pokedex_numbers: Vec<models::PokemonDexEntry>, egg_groups: Vec<models::AbilityDetailPokemonInnerPokemon>, color: models::PokemonColorSummary, shape: models::PokemonShapeSummary, evolves_from_species: models::PokemonSpeciesSummary, evolution_chain: models::EvolutionChainSummary, habitat: models::PokemonHabitatSummary, generation: models::GenerationSummary, names: Vec<models::PokemonFormDetailFormNamesInner>, pal_park_encounters: Vec<models::PokemonSpeciesDetailPalParkEncountersInner>, form_descriptions: Vec<models::PokemonSpeciesDescription>, flavor_text_entries: Vec<models::PokemonSpeciesFlavorText>, genera: Vec<models::PokemonSpeciesDetailGeneraInner>, varieties: Vec<models::PokemonSpeciesDetailVarietiesInner>, ) -> PokemonSpeciesDetail {
        PokemonSpeciesDetail {
 id,
 name,
 order: None,
 gender_rate: None,
 capture_rate: None,
 base_happiness: None,
 is_baby: None,
 is_legendary: None,
 is_mythical: None,
 hatch_counter: None,
 has_gender_differences: None,
 forms_switchable: None,
 growth_rate,
 pokedex_numbers,
 egg_groups,
 color,
 shape,
 evolves_from_species,
 evolution_chain,
 habitat,
 generation,
 names,
 pal_park_encounters,
 form_descriptions,
 flavor_text_entries,
 genera,
 varieties,
        }
    }
}

/// Converts the PokemonSpeciesDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonSpeciesDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.order.as_ref().map(|order| {
                [
                    "order".to_string(),
                    order.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.gender_rate.as_ref().map(|gender_rate| {
                [
                    "gender_rate".to_string(),
                    gender_rate.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.capture_rate.as_ref().map(|capture_rate| {
                [
                    "capture_rate".to_string(),
                    capture_rate.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.base_happiness.as_ref().map(|base_happiness| {
                [
                    "base_happiness".to_string(),
                    base_happiness.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.is_baby.as_ref().map(|is_baby| {
                [
                    "is_baby".to_string(),
                    is_baby.to_string(),
                ].join(",")
            }),


            self.is_legendary.as_ref().map(|is_legendary| {
                [
                    "is_legendary".to_string(),
                    is_legendary.to_string(),
                ].join(",")
            }),


            self.is_mythical.as_ref().map(|is_mythical| {
                [
                    "is_mythical".to_string(),
                    is_mythical.to_string(),
                ].join(",")
            }),


            self.hatch_counter.as_ref().map(|hatch_counter| {
                [
                    "hatch_counter".to_string(),
                    hatch_counter.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),


            self.has_gender_differences.as_ref().map(|has_gender_differences| {
                [
                    "has_gender_differences".to_string(),
                    has_gender_differences.to_string(),
                ].join(",")
            }),


            self.forms_switchable.as_ref().map(|forms_switchable| {
                [
                    "forms_switchable".to_string(),
                    forms_switchable.to_string(),
                ].join(",")
            }),

            // Skipping growth_rate in query parameter serialization

            // Skipping pokedex_numbers in query parameter serialization

            // Skipping egg_groups in query parameter serialization

            // Skipping color in query parameter serialization

            // Skipping shape in query parameter serialization

            // Skipping evolves_from_species in query parameter serialization

            // Skipping evolution_chain in query parameter serialization

            // Skipping habitat in query parameter serialization

            // Skipping generation in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping pal_park_encounters in query parameter serialization

            // Skipping form_descriptions in query parameter serialization

            // Skipping flavor_text_entries in query parameter serialization

            // Skipping genera in query parameter serialization

            // Skipping varieties in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonSpeciesDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonSpeciesDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub order: Vec<i32>,
            pub gender_rate: Vec<i32>,
            pub capture_rate: Vec<i32>,
            pub base_happiness: Vec<i32>,
            pub is_baby: Vec<bool>,
            pub is_legendary: Vec<bool>,
            pub is_mythical: Vec<bool>,
            pub hatch_counter: Vec<i32>,
            pub has_gender_differences: Vec<bool>,
            pub forms_switchable: Vec<bool>,
            pub growth_rate: Vec<models::GrowthRateSummary>,
            pub pokedex_numbers: Vec<Vec<models::PokemonDexEntry>>,
            pub egg_groups: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub color: Vec<models::PokemonColorSummary>,
            pub shape: Vec<models::PokemonShapeSummary>,
            pub evolves_from_species: Vec<models::PokemonSpeciesSummary>,
            pub evolution_chain: Vec<models::EvolutionChainSummary>,
            pub habitat: Vec<models::PokemonHabitatSummary>,
            pub generation: Vec<models::GenerationSummary>,
            pub names: Vec<Vec<models::PokemonFormDetailFormNamesInner>>,
            pub pal_park_encounters: Vec<Vec<models::PokemonSpeciesDetailPalParkEncountersInner>>,
            pub form_descriptions: Vec<Vec<models::PokemonSpeciesDescription>>,
            pub flavor_text_entries: Vec<Vec<models::PokemonSpeciesFlavorText>>,
            pub genera: Vec<Vec<models::PokemonSpeciesDetailGeneraInner>>,
            pub varieties: Vec<Vec<models::PokemonSpeciesDetailVarietiesInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonSpeciesDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "order" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "gender_rate" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "capture_rate" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "base_happiness" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonSpeciesDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "is_baby" => intermediate_rep.is_baby.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_legendary" => intermediate_rep.is_legendary.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_mythical" => intermediate_rep.is_mythical.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "hatch_counter" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in PokemonSpeciesDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "has_gender_differences" => intermediate_rep.has_gender_differences.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "forms_switchable" => intermediate_rep.forms_switchable.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "growth_rate" => intermediate_rep.growth_rate.push(<models::GrowthRateSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "pokedex_numbers" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "egg_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonSpeciesDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "color" => intermediate_rep.color.push(<models::PokemonColorSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "shape" => intermediate_rep.shape.push(<models::PokemonShapeSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "evolves_from_species" => intermediate_rep.evolves_from_species.push(<models::PokemonSpeciesSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "evolution_chain" => intermediate_rep.evolution_chain.push(<models::EvolutionChainSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "habitat" => intermediate_rep.habitat.push(<models::PokemonHabitatSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "pal_park_encounters" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "form_descriptions" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "flavor_text_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "genera" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonSpeciesDetail".to_string()),
                    "varieties" => return std::result::Result::Err("Parsing a container in this style is not supported in PokemonSpeciesDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonSpeciesDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonSpeciesDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in PokemonSpeciesDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonSpeciesDetail".to_string())?,
            order: std::result::Result::Err("Nullable types not supported in PokemonSpeciesDetail".to_string())?,
            gender_rate: std::result::Result::Err("Nullable types not supported in PokemonSpeciesDetail".to_string())?,
            capture_rate: std::result::Result::Err("Nullable types not supported in PokemonSpeciesDetail".to_string())?,
            base_happiness: std::result::Result::Err("Nullable types not supported in PokemonSpeciesDetail".to_string())?,
            is_baby: intermediate_rep.is_baby.into_iter().next(),
            is_legendary: intermediate_rep.is_legendary.into_iter().next(),
            is_mythical: intermediate_rep.is_mythical.into_iter().next(),
            hatch_counter: std::result::Result::Err("Nullable types not supported in PokemonSpeciesDetail".to_string())?,
            has_gender_differences: intermediate_rep.has_gender_differences.into_iter().next(),
            forms_switchable: intermediate_rep.forms_switchable.into_iter().next(),
            growth_rate: intermediate_rep.growth_rate.into_iter().next().ok_or_else(|| "growth_rate missing in PokemonSpeciesDetail".to_string())?,
            pokedex_numbers: intermediate_rep.pokedex_numbers.into_iter().next().ok_or_else(|| "pokedex_numbers missing in PokemonSpeciesDetail".to_string())?,
            egg_groups: intermediate_rep.egg_groups.into_iter().next().ok_or_else(|| "egg_groups missing in PokemonSpeciesDetail".to_string())?,
            color: intermediate_rep.color.into_iter().next().ok_or_else(|| "color missing in PokemonSpeciesDetail".to_string())?,
            shape: intermediate_rep.shape.into_iter().next().ok_or_else(|| "shape missing in PokemonSpeciesDetail".to_string())?,
            evolves_from_species: intermediate_rep.evolves_from_species.into_iter().next().ok_or_else(|| "evolves_from_species missing in PokemonSpeciesDetail".to_string())?,
            evolution_chain: intermediate_rep.evolution_chain.into_iter().next().ok_or_else(|| "evolution_chain missing in PokemonSpeciesDetail".to_string())?,
            habitat: intermediate_rep.habitat.into_iter().next().ok_or_else(|| "habitat missing in PokemonSpeciesDetail".to_string())?,
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in PokemonSpeciesDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in PokemonSpeciesDetail".to_string())?,
            pal_park_encounters: intermediate_rep.pal_park_encounters.into_iter().next().ok_or_else(|| "pal_park_encounters missing in PokemonSpeciesDetail".to_string())?,
            form_descriptions: intermediate_rep.form_descriptions.into_iter().next().ok_or_else(|| "form_descriptions missing in PokemonSpeciesDetail".to_string())?,
            flavor_text_entries: intermediate_rep.flavor_text_entries.into_iter().next().ok_or_else(|| "flavor_text_entries missing in PokemonSpeciesDetail".to_string())?,
            genera: intermediate_rep.genera.into_iter().next().ok_or_else(|| "genera missing in PokemonSpeciesDetail".to_string())?,
            varieties: intermediate_rep.varieties.into_iter().next().ok_or_else(|| "varieties missing in PokemonSpeciesDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonSpeciesDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonSpeciesDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonSpeciesDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonSpeciesDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonSpeciesDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonSpeciesDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonSpeciesDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonSpeciesDetailGeneraInner {
    #[serde(rename = "genus")]
          #[validate(custom(function = "check_xss_string"))]
    pub genus: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::AbilityDetailPokemonInnerPokemon,

}



impl PokemonSpeciesDetailGeneraInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(genus: String, language: models::AbilityDetailPokemonInnerPokemon, ) -> PokemonSpeciesDetailGeneraInner {
        PokemonSpeciesDetailGeneraInner {
 genus,
 language,
        }
    }
}

/// Converts the PokemonSpeciesDetailGeneraInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonSpeciesDetailGeneraInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("genus".to_string()),
            Some(self.genus.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonSpeciesDetailGeneraInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonSpeciesDetailGeneraInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub genus: Vec<String>,
            pub language: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonSpeciesDetailGeneraInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "genus" => intermediate_rep.genus.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonSpeciesDetailGeneraInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonSpeciesDetailGeneraInner {
            genus: intermediate_rep.genus.into_iter().next().ok_or_else(|| "genus missing in PokemonSpeciesDetailGeneraInner".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokemonSpeciesDetailGeneraInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonSpeciesDetailGeneraInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonSpeciesDetailGeneraInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonSpeciesDetailGeneraInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonSpeciesDetailGeneraInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonSpeciesDetailGeneraInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonSpeciesDetailGeneraInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonSpeciesDetailGeneraInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonSpeciesDetailPalParkEncountersInner {
    #[serde(rename = "area")]
          #[validate(nested)]
    pub area: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "base_score")]
    pub base_score: i32,

    #[serde(rename = "rate")]
    pub rate: i32,

}



impl PokemonSpeciesDetailPalParkEncountersInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(area: models::AbilityDetailPokemonInnerPokemon, base_score: i32, rate: i32, ) -> PokemonSpeciesDetailPalParkEncountersInner {
        PokemonSpeciesDetailPalParkEncountersInner {
 area,
 base_score,
 rate,
        }
    }
}

/// Converts the PokemonSpeciesDetailPalParkEncountersInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonSpeciesDetailPalParkEncountersInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping area in query parameter serialization


            Some("base_score".to_string()),
            Some(self.base_score.to_string()),


            Some("rate".to_string()),
            Some(self.rate.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonSpeciesDetailPalParkEncountersInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonSpeciesDetailPalParkEncountersInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub area: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub base_score: Vec<i32>,
            pub rate: Vec<i32>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonSpeciesDetailPalParkEncountersInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "area" => intermediate_rep.area.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "base_score" => intermediate_rep.base_score.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "rate" => intermediate_rep.rate.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonSpeciesDetailPalParkEncountersInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonSpeciesDetailPalParkEncountersInner {
            area: intermediate_rep.area.into_iter().next().ok_or_else(|| "area missing in PokemonSpeciesDetailPalParkEncountersInner".to_string())?,
            base_score: intermediate_rep.base_score.into_iter().next().ok_or_else(|| "base_score missing in PokemonSpeciesDetailPalParkEncountersInner".to_string())?,
            rate: intermediate_rep.rate.into_iter().next().ok_or_else(|| "rate missing in PokemonSpeciesDetailPalParkEncountersInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonSpeciesDetailPalParkEncountersInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonSpeciesDetailPalParkEncountersInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonSpeciesDetailPalParkEncountersInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonSpeciesDetailPalParkEncountersInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonSpeciesDetailPalParkEncountersInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonSpeciesDetailPalParkEncountersInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonSpeciesDetailPalParkEncountersInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonSpeciesDetailVarietiesInner {
    #[serde(rename = "is_default")]
    pub is_default: bool,

    #[serde(rename = "pokemon")]
          #[validate(nested)]
    pub pokemon: models::AbilityDetailPokemonInnerPokemon,

}



impl PokemonSpeciesDetailVarietiesInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(is_default: bool, pokemon: models::AbilityDetailPokemonInnerPokemon, ) -> PokemonSpeciesDetailVarietiesInner {
        PokemonSpeciesDetailVarietiesInner {
 is_default,
 pokemon,
        }
    }
}

/// Converts the PokemonSpeciesDetailVarietiesInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonSpeciesDetailVarietiesInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("is_default".to_string()),
            Some(self.is_default.to_string()),

            // Skipping pokemon in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonSpeciesDetailVarietiesInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonSpeciesDetailVarietiesInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub is_default: Vec<bool>,
            pub pokemon: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonSpeciesDetailVarietiesInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "is_default" => intermediate_rep.is_default.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokemon" => intermediate_rep.pokemon.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonSpeciesDetailVarietiesInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonSpeciesDetailVarietiesInner {
            is_default: intermediate_rep.is_default.into_iter().next().ok_or_else(|| "is_default missing in PokemonSpeciesDetailVarietiesInner".to_string())?,
            pokemon: intermediate_rep.pokemon.into_iter().next().ok_or_else(|| "pokemon missing in PokemonSpeciesDetailVarietiesInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonSpeciesDetailVarietiesInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonSpeciesDetailVarietiesInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonSpeciesDetailVarietiesInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonSpeciesDetailVarietiesInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonSpeciesDetailVarietiesInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonSpeciesDetailVarietiesInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonSpeciesDetailVarietiesInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonSpeciesFlavorText {
    #[serde(rename = "flavor_text")]
          #[validate(custom(function = "check_xss_string"))]
    pub flavor_text: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

    #[serde(rename = "version")]
          #[validate(nested)]
    pub version: models::VersionSummary,

}



impl PokemonSpeciesFlavorText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(flavor_text: String, language: models::LanguageSummary, version: models::VersionSummary, ) -> PokemonSpeciesFlavorText {
        PokemonSpeciesFlavorText {
 flavor_text,
 language,
 version,
        }
    }
}

/// Converts the PokemonSpeciesFlavorText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonSpeciesFlavorText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("flavor_text".to_string()),
            Some(self.flavor_text.to_string()),

            // Skipping language in query parameter serialization

            // Skipping version in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonSpeciesFlavorText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonSpeciesFlavorText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub flavor_text: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
            pub version: Vec<models::VersionSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonSpeciesFlavorText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "flavor_text" => intermediate_rep.flavor_text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "version" => intermediate_rep.version.push(<models::VersionSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonSpeciesFlavorText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonSpeciesFlavorText {
            flavor_text: intermediate_rep.flavor_text.into_iter().next().ok_or_else(|| "flavor_text missing in PokemonSpeciesFlavorText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in PokemonSpeciesFlavorText".to_string())?,
            version: intermediate_rep.version.into_iter().next().ok_or_else(|| "version missing in PokemonSpeciesFlavorText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonSpeciesFlavorText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonSpeciesFlavorText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonSpeciesFlavorText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonSpeciesFlavorText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonSpeciesFlavorText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonSpeciesFlavorText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonSpeciesFlavorText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonSpeciesSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonSpeciesSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonSpeciesSummary {
        PokemonSpeciesSummary {
 name,
 url,
        }
    }
}

/// Converts the PokemonSpeciesSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonSpeciesSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonSpeciesSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonSpeciesSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonSpeciesSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonSpeciesSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonSpeciesSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonSpeciesSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonSpeciesSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonSpeciesSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonSpeciesSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonSpeciesSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonSpeciesSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonSpeciesSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonSpeciesSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonSpeciesSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonStat {
    #[serde(rename = "base_stat")]
    pub base_stat: i32,

    #[serde(rename = "effort")]
    pub effort: i32,

    #[serde(rename = "stat")]
          #[validate(nested)]
    pub stat: models::StatSummary,

}



impl PokemonStat {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(base_stat: i32, effort: i32, stat: models::StatSummary, ) -> PokemonStat {
        PokemonStat {
 base_stat,
 effort,
 stat,
        }
    }
}

/// Converts the PokemonStat value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonStat {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("base_stat".to_string()),
            Some(self.base_stat.to_string()),


            Some("effort".to_string()),
            Some(self.effort.to_string()),

            // Skipping stat in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonStat value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonStat {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub base_stat: Vec<i32>,
            pub effort: Vec<i32>,
            pub stat: Vec<models::StatSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonStat".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "base_stat" => intermediate_rep.base_stat.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "effort" => intermediate_rep.effort.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "stat" => intermediate_rep.stat.push(<models::StatSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonStat".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonStat {
            base_stat: intermediate_rep.base_stat.into_iter().next().ok_or_else(|| "base_stat missing in PokemonStat".to_string())?,
            effort: intermediate_rep.effort.into_iter().next().ok_or_else(|| "effort missing in PokemonStat".to_string())?,
            stat: intermediate_rep.stat.into_iter().next().ok_or_else(|| "stat missing in PokemonStat".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonStat> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonStat>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonStat>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonStat - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonStat> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonStat as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonStat - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct PokemonSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl PokemonSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> PokemonSummary {
        PokemonSummary {
 name,
 url,
        }
    }
}

/// Converts the PokemonSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for PokemonSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a PokemonSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for PokemonSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing PokemonSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing PokemonSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(PokemonSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in PokemonSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in PokemonSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<PokemonSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<PokemonSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<PokemonSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for PokemonSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<PokemonSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <PokemonSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into PokemonSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RegionDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "locations")]
          #[validate(nested)]
    pub locations: Vec<models::LocationSummary>,

    #[serde(rename = "main_generation")]
          #[validate(nested)]
    pub main_generation: models::GenerationSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::RegionName>,

    #[serde(rename = "pokedexes")]
          #[validate(nested)]
    pub pokedexes: Vec<models::PokedexSummary>,

    #[serde(rename = "version_groups")]
          #[validate(nested)]
    pub version_groups: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl RegionDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, locations: Vec<models::LocationSummary>, main_generation: models::GenerationSummary, names: Vec<models::RegionName>, pokedexes: Vec<models::PokedexSummary>, version_groups: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> RegionDetail {
        RegionDetail {
 id,
 name,
 locations,
 main_generation,
 names,
 pokedexes,
 version_groups,
        }
    }
}

/// Converts the RegionDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RegionDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping locations in query parameter serialization

            // Skipping main_generation in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping pokedexes in query parameter serialization

            // Skipping version_groups in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RegionDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RegionDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub locations: Vec<Vec<models::LocationSummary>>,
            pub main_generation: Vec<models::GenerationSummary>,
            pub names: Vec<Vec<models::RegionName>>,
            pub pokedexes: Vec<Vec<models::PokedexSummary>>,
            pub version_groups: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RegionDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "locations" => return std::result::Result::Err("Parsing a container in this style is not supported in RegionDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "main_generation" => intermediate_rep.main_generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in RegionDetail".to_string()),
                    "pokedexes" => return std::result::Result::Err("Parsing a container in this style is not supported in RegionDetail".to_string()),
                    "version_groups" => return std::result::Result::Err("Parsing a container in this style is not supported in RegionDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing RegionDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RegionDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in RegionDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in RegionDetail".to_string())?,
            locations: intermediate_rep.locations.into_iter().next().ok_or_else(|| "locations missing in RegionDetail".to_string())?,
            main_generation: intermediate_rep.main_generation.into_iter().next().ok_or_else(|| "main_generation missing in RegionDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in RegionDetail".to_string())?,
            pokedexes: intermediate_rep.pokedexes.into_iter().next().ok_or_else(|| "pokedexes missing in RegionDetail".to_string())?,
            version_groups: intermediate_rep.version_groups.into_iter().next().ok_or_else(|| "version_groups missing in RegionDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RegionDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RegionDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RegionDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RegionDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RegionDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RegionDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RegionDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RegionName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl RegionName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> RegionName {
        RegionName {
 name,
 language,
        }
    }
}

/// Converts the RegionName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RegionName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RegionName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RegionName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RegionName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RegionName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RegionName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in RegionName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in RegionName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RegionName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RegionName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RegionName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RegionName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RegionName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RegionName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RegionName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct RegionSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl RegionSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> RegionSummary {
        RegionSummary {
 name,
 url,
        }
    }
}

/// Converts the RegionSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for RegionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a RegionSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for RegionSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing RegionSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing RegionSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(RegionSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in RegionSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in RegionSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<RegionSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<RegionSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<RegionSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for RegionSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<RegionSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <RegionSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into RegionSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StatDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "game_index")]
    pub game_index: i32,

    #[serde(rename = "is_battle_only")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub is_battle_only: Option<bool>,

    #[serde(rename = "affecting_moves")]
          #[validate(nested)]
    pub affecting_moves: models::StatDetailAffectingMoves,

    #[serde(rename = "affecting_natures")]
          #[validate(nested)]
    pub affecting_natures: models::StatDetailAffectingNatures,

    #[serde(rename = "characteristics")]
          #[validate(nested)]
    pub characteristics: Vec<models::CharacteristicSummary>,

    #[serde(rename = "move_damage_class")]
          #[validate(nested)]
    pub move_damage_class: models::MoveDamageClassSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::StatName>,

}



impl StatDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, game_index: i32, affecting_moves: models::StatDetailAffectingMoves, affecting_natures: models::StatDetailAffectingNatures, characteristics: Vec<models::CharacteristicSummary>, move_damage_class: models::MoveDamageClassSummary, names: Vec<models::StatName>, ) -> StatDetail {
        StatDetail {
 id,
 name,
 game_index,
 is_battle_only: None,
 affecting_moves,
 affecting_natures,
 characteristics,
 move_damage_class,
 names,
        }
    }
}

/// Converts the StatDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StatDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("game_index".to_string()),
            Some(self.game_index.to_string()),


            self.is_battle_only.as_ref().map(|is_battle_only| {
                [
                    "is_battle_only".to_string(),
                    is_battle_only.to_string(),
                ].join(",")
            }),

            // Skipping affecting_moves in query parameter serialization

            // Skipping affecting_natures in query parameter serialization

            // Skipping characteristics in query parameter serialization

            // Skipping move_damage_class in query parameter serialization

            // Skipping names in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StatDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StatDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub game_index: Vec<i32>,
            pub is_battle_only: Vec<bool>,
            pub affecting_moves: Vec<models::StatDetailAffectingMoves>,
            pub affecting_natures: Vec<models::StatDetailAffectingNatures>,
            pub characteristics: Vec<Vec<models::CharacteristicSummary>>,
            pub move_damage_class: Vec<models::MoveDamageClassSummary>,
            pub names: Vec<Vec<models::StatName>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StatDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "game_index" => intermediate_rep.game_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "is_battle_only" => intermediate_rep.is_battle_only.push(<bool as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "affecting_moves" => intermediate_rep.affecting_moves.push(<models::StatDetailAffectingMoves as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "affecting_natures" => intermediate_rep.affecting_natures.push(<models::StatDetailAffectingNatures as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "characteristics" => return std::result::Result::Err("Parsing a container in this style is not supported in StatDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "move_damage_class" => intermediate_rep.move_damage_class.push(<models::MoveDamageClassSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in StatDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing StatDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StatDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in StatDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in StatDetail".to_string())?,
            game_index: intermediate_rep.game_index.into_iter().next().ok_or_else(|| "game_index missing in StatDetail".to_string())?,
            is_battle_only: intermediate_rep.is_battle_only.into_iter().next(),
            affecting_moves: intermediate_rep.affecting_moves.into_iter().next().ok_or_else(|| "affecting_moves missing in StatDetail".to_string())?,
            affecting_natures: intermediate_rep.affecting_natures.into_iter().next().ok_or_else(|| "affecting_natures missing in StatDetail".to_string())?,
            characteristics: intermediate_rep.characteristics.into_iter().next().ok_or_else(|| "characteristics missing in StatDetail".to_string())?,
            move_damage_class: intermediate_rep.move_damage_class.into_iter().next().ok_or_else(|| "move_damage_class missing in StatDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in StatDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StatDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StatDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StatDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StatDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StatDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StatDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StatDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StatDetailAffectingMoves {
    #[serde(rename = "increase")]
          #[validate(nested)]
    pub increase: Vec<models::StatDetailAffectingMovesIncreaseInner>,

    #[serde(rename = "decrease")]
          #[validate(nested)]
    pub decrease: Vec<models::StatDetailAffectingMovesIncreaseInner>,

}



impl StatDetailAffectingMoves {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(increase: Vec<models::StatDetailAffectingMovesIncreaseInner>, decrease: Vec<models::StatDetailAffectingMovesIncreaseInner>, ) -> StatDetailAffectingMoves {
        StatDetailAffectingMoves {
 increase,
 decrease,
        }
    }
}

/// Converts the StatDetailAffectingMoves value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StatDetailAffectingMoves {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping increase in query parameter serialization

            // Skipping decrease in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StatDetailAffectingMoves value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StatDetailAffectingMoves {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub increase: Vec<Vec<models::StatDetailAffectingMovesIncreaseInner>>,
            pub decrease: Vec<Vec<models::StatDetailAffectingMovesIncreaseInner>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StatDetailAffectingMoves".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "increase" => return std::result::Result::Err("Parsing a container in this style is not supported in StatDetailAffectingMoves".to_string()),
                    "decrease" => return std::result::Result::Err("Parsing a container in this style is not supported in StatDetailAffectingMoves".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing StatDetailAffectingMoves".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StatDetailAffectingMoves {
            increase: intermediate_rep.increase.into_iter().next().ok_or_else(|| "increase missing in StatDetailAffectingMoves".to_string())?,
            decrease: intermediate_rep.decrease.into_iter().next().ok_or_else(|| "decrease missing in StatDetailAffectingMoves".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StatDetailAffectingMoves> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StatDetailAffectingMoves>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StatDetailAffectingMoves>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StatDetailAffectingMoves - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StatDetailAffectingMoves> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StatDetailAffectingMoves as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StatDetailAffectingMoves - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StatDetailAffectingMovesIncreaseInner {
    #[serde(rename = "change")]
    pub change: i32,

    #[serde(rename = "move")]
          #[validate(nested)]
    pub r_move: models::AbilityDetailPokemonInnerPokemon,

}



impl StatDetailAffectingMovesIncreaseInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(change: i32, r_move: models::AbilityDetailPokemonInnerPokemon, ) -> StatDetailAffectingMovesIncreaseInner {
        StatDetailAffectingMovesIncreaseInner {
 change,
 r_move,
        }
    }
}

/// Converts the StatDetailAffectingMovesIncreaseInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StatDetailAffectingMovesIncreaseInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("change".to_string()),
            Some(self.change.to_string()),

            // Skipping move in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StatDetailAffectingMovesIncreaseInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StatDetailAffectingMovesIncreaseInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub change: Vec<i32>,
            pub r_move: Vec<models::AbilityDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StatDetailAffectingMovesIncreaseInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "change" => intermediate_rep.change.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "move" => intermediate_rep.r_move.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StatDetailAffectingMovesIncreaseInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StatDetailAffectingMovesIncreaseInner {
            change: intermediate_rep.change.into_iter().next().ok_or_else(|| "change missing in StatDetailAffectingMovesIncreaseInner".to_string())?,
            r_move: intermediate_rep.r_move.into_iter().next().ok_or_else(|| "move missing in StatDetailAffectingMovesIncreaseInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StatDetailAffectingMovesIncreaseInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StatDetailAffectingMovesIncreaseInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StatDetailAffectingMovesIncreaseInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StatDetailAffectingMovesIncreaseInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StatDetailAffectingMovesIncreaseInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StatDetailAffectingMovesIncreaseInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StatDetailAffectingMovesIncreaseInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StatDetailAffectingNatures {
    #[serde(rename = "increase")]
          #[validate(nested)]
    pub increase: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "decrease")]
          #[validate(nested)]
    pub decrease: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl StatDetailAffectingNatures {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(increase: Vec<models::AbilityDetailPokemonInnerPokemon>, decrease: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> StatDetailAffectingNatures {
        StatDetailAffectingNatures {
 increase,
 decrease,
        }
    }
}

/// Converts the StatDetailAffectingNatures value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StatDetailAffectingNatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping increase in query parameter serialization

            // Skipping decrease in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StatDetailAffectingNatures value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StatDetailAffectingNatures {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub increase: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub decrease: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StatDetailAffectingNatures".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "increase" => return std::result::Result::Err("Parsing a container in this style is not supported in StatDetailAffectingNatures".to_string()),
                    "decrease" => return std::result::Result::Err("Parsing a container in this style is not supported in StatDetailAffectingNatures".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing StatDetailAffectingNatures".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StatDetailAffectingNatures {
            increase: intermediate_rep.increase.into_iter().next().ok_or_else(|| "increase missing in StatDetailAffectingNatures".to_string())?,
            decrease: intermediate_rep.decrease.into_iter().next().ok_or_else(|| "decrease missing in StatDetailAffectingNatures".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StatDetailAffectingNatures> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StatDetailAffectingNatures>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StatDetailAffectingNatures>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StatDetailAffectingNatures - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StatDetailAffectingNatures> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StatDetailAffectingNatures as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StatDetailAffectingNatures - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StatName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl StatName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> StatName {
        StatName {
 name,
 language,
        }
    }
}

/// Converts the StatName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StatName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StatName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StatName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StatName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StatName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StatName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in StatName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in StatName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StatName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StatName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StatName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StatName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StatName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StatName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StatName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct StatSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl StatSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> StatSummary {
        StatSummary {
 name,
 url,
        }
    }
}

/// Converts the StatSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for StatSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a StatSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for StatSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing StatSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing StatSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(StatSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in StatSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in StatSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<StatSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<StatSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<StatSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for StatSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<StatSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <StatSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into StatSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuperContestEffectDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "appeal")]
    pub appeal: i32,

    #[serde(rename = "flavor_text_entries")]
          #[validate(nested)]
    pub flavor_text_entries: Vec<models::SuperContestEffectFlavorText>,

    #[serde(rename = "moves")]
          #[validate(nested)]
    pub moves: Vec<models::MoveSummary>,

}



impl SuperContestEffectDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, appeal: i32, flavor_text_entries: Vec<models::SuperContestEffectFlavorText>, moves: Vec<models::MoveSummary>, ) -> SuperContestEffectDetail {
        SuperContestEffectDetail {
 id,
 appeal,
 flavor_text_entries,
 moves,
        }
    }
}

/// Converts the SuperContestEffectDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SuperContestEffectDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("appeal".to_string()),
            Some(self.appeal.to_string()),

            // Skipping flavor_text_entries in query parameter serialization

            // Skipping moves in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuperContestEffectDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuperContestEffectDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub appeal: Vec<i32>,
            pub flavor_text_entries: Vec<Vec<models::SuperContestEffectFlavorText>>,
            pub moves: Vec<Vec<models::MoveSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuperContestEffectDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "appeal" => intermediate_rep.appeal.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "flavor_text_entries" => return std::result::Result::Err("Parsing a container in this style is not supported in SuperContestEffectDetail".to_string()),
                    "moves" => return std::result::Result::Err("Parsing a container in this style is not supported in SuperContestEffectDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuperContestEffectDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuperContestEffectDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in SuperContestEffectDetail".to_string())?,
            appeal: intermediate_rep.appeal.into_iter().next().ok_or_else(|| "appeal missing in SuperContestEffectDetail".to_string())?,
            flavor_text_entries: intermediate_rep.flavor_text_entries.into_iter().next().ok_or_else(|| "flavor_text_entries missing in SuperContestEffectDetail".to_string())?,
            moves: intermediate_rep.moves.into_iter().next().ok_or_else(|| "moves missing in SuperContestEffectDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuperContestEffectDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SuperContestEffectDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuperContestEffectDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for SuperContestEffectDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SuperContestEffectDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuperContestEffectDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into SuperContestEffectDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuperContestEffectFlavorText {
    #[serde(rename = "flavor_text")]
    #[validate(
            length(max = 500),
          custom(function = "check_xss_string"),
    )]
    pub flavor_text: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl SuperContestEffectFlavorText {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(flavor_text: String, language: models::LanguageSummary, ) -> SuperContestEffectFlavorText {
        SuperContestEffectFlavorText {
 flavor_text,
 language,
        }
    }
}

/// Converts the SuperContestEffectFlavorText value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SuperContestEffectFlavorText {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("flavor_text".to_string()),
            Some(self.flavor_text.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuperContestEffectFlavorText value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuperContestEffectFlavorText {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub flavor_text: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuperContestEffectFlavorText".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "flavor_text" => intermediate_rep.flavor_text.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuperContestEffectFlavorText".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuperContestEffectFlavorText {
            flavor_text: intermediate_rep.flavor_text.into_iter().next().ok_or_else(|| "flavor_text missing in SuperContestEffectFlavorText".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in SuperContestEffectFlavorText".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuperContestEffectFlavorText> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SuperContestEffectFlavorText>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuperContestEffectFlavorText>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for SuperContestEffectFlavorText - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SuperContestEffectFlavorText> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuperContestEffectFlavorText as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into SuperContestEffectFlavorText - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct SuperContestEffectSummary {
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl SuperContestEffectSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(url: String, ) -> SuperContestEffectSummary {
        SuperContestEffectSummary {
 url,
        }
    }
}

/// Converts the SuperContestEffectSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for SuperContestEffectSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a SuperContestEffectSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for SuperContestEffectSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing SuperContestEffectSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing SuperContestEffectSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(SuperContestEffectSummary {
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in SuperContestEffectSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<SuperContestEffectSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<SuperContestEffectSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<SuperContestEffectSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for SuperContestEffectSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<SuperContestEffectSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <SuperContestEffectSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into SuperContestEffectSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Serializer for the Type resource
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "damage_relations")]
          #[validate(nested)]
    pub damage_relations: models::TypeDetailDamageRelations,

    #[serde(rename = "past_damage_relations")]
          #[validate(nested)]
    pub past_damage_relations: Vec<models::TypeDetailPastDamageRelationsInner>,

    #[serde(rename = "game_indices")]
          #[validate(nested)]
    pub game_indices: Vec<models::TypeGameIndex>,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::GenerationSummary,

    #[serde(rename = "move_damage_class")]
          #[validate(nested)]
    pub move_damage_class: models::MoveDamageClassSummary,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::AbilityName>,

    #[serde(rename = "pokemon")]
          #[validate(nested)]
    pub pokemon: Vec<models::TypeDetailPokemonInner>,

    #[serde(rename = "moves")]
          #[validate(nested)]
    pub moves: Vec<models::MoveSummary>,

    #[serde(rename = "sprites")]
          #[validate(custom(function = "check_xss_map"))]
    pub sprites: std::collections::HashMap<String, std::collections::HashMap<String, models::TypeDetailSpritesValueValue>>,

}



impl TypeDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, damage_relations: models::TypeDetailDamageRelations, past_damage_relations: Vec<models::TypeDetailPastDamageRelationsInner>, game_indices: Vec<models::TypeGameIndex>, generation: models::GenerationSummary, move_damage_class: models::MoveDamageClassSummary, names: Vec<models::AbilityName>, pokemon: Vec<models::TypeDetailPokemonInner>, moves: Vec<models::MoveSummary>, sprites: std::collections::HashMap<String, std::collections::HashMap<String, models::TypeDetailSpritesValueValue>>, ) -> TypeDetail {
        TypeDetail {
 id,
 name,
 damage_relations,
 past_damage_relations,
 game_indices,
 generation,
 move_damage_class,
 names,
 pokemon,
 moves,
 sprites,
        }
    }
}

/// Converts the TypeDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping damage_relations in query parameter serialization

            // Skipping past_damage_relations in query parameter serialization

            // Skipping game_indices in query parameter serialization

            // Skipping generation in query parameter serialization

            // Skipping move_damage_class in query parameter serialization

            // Skipping names in query parameter serialization

            // Skipping pokemon in query parameter serialization

            // Skipping moves in query parameter serialization

            // Skipping sprites in query parameter serialization
            // Skipping sprites in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub damage_relations: Vec<models::TypeDetailDamageRelations>,
            pub past_damage_relations: Vec<Vec<models::TypeDetailPastDamageRelationsInner>>,
            pub game_indices: Vec<Vec<models::TypeGameIndex>>,
            pub generation: Vec<models::GenerationSummary>,
            pub move_damage_class: Vec<models::MoveDamageClassSummary>,
            pub names: Vec<Vec<models::AbilityName>>,
            pub pokemon: Vec<Vec<models::TypeDetailPokemonInner>>,
            pub moves: Vec<Vec<models::MoveSummary>>,
            pub sprites: Vec<std::collections::HashMap<String, std::collections::HashMap<String, models::TypeDetailSpritesValueValue>>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "damage_relations" => intermediate_rep.damage_relations.push(<models::TypeDetailDamageRelations as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "past_damage_relations" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetail".to_string()),
                    "game_indices" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "move_damage_class" => intermediate_rep.move_damage_class.push(<models::MoveDamageClassSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetail".to_string()),
                    "pokemon" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetail".to_string()),
                    "moves" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetail".to_string()),
                    "sprites" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in TypeDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in TypeDetail".to_string())?,
            damage_relations: intermediate_rep.damage_relations.into_iter().next().ok_or_else(|| "damage_relations missing in TypeDetail".to_string())?,
            past_damage_relations: intermediate_rep.past_damage_relations.into_iter().next().ok_or_else(|| "past_damage_relations missing in TypeDetail".to_string())?,
            game_indices: intermediate_rep.game_indices.into_iter().next().ok_or_else(|| "game_indices missing in TypeDetail".to_string())?,
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in TypeDetail".to_string())?,
            move_damage_class: intermediate_rep.move_damage_class.into_iter().next().ok_or_else(|| "move_damage_class missing in TypeDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in TypeDetail".to_string())?,
            pokemon: intermediate_rep.pokemon.into_iter().next().ok_or_else(|| "pokemon missing in TypeDetail".to_string())?,
            moves: intermediate_rep.moves.into_iter().next().ok_or_else(|| "moves missing in TypeDetail".to_string())?,
            sprites: intermediate_rep.sprites.into_iter().next().ok_or_else(|| "sprites missing in TypeDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeDetailDamageRelations {
    #[serde(rename = "no_damage_to")]
          #[validate(nested)]
    pub no_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "half_damage_to")]
          #[validate(nested)]
    pub half_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "double_damage_to")]
          #[validate(nested)]
    pub double_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "no_damage_from")]
          #[validate(nested)]
    pub no_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "half_damage_from")]
          #[validate(nested)]
    pub half_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "double_damage_from")]
          #[validate(nested)]
    pub double_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl TypeDetailDamageRelations {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(no_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>, half_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>, double_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>, no_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>, half_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>, double_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> TypeDetailDamageRelations {
        TypeDetailDamageRelations {
 no_damage_to,
 half_damage_to,
 double_damage_to,
 no_damage_from,
 half_damage_from,
 double_damage_from,
        }
    }
}

/// Converts the TypeDetailDamageRelations value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeDetailDamageRelations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping no_damage_to in query parameter serialization

            // Skipping half_damage_to in query parameter serialization

            // Skipping double_damage_to in query parameter serialization

            // Skipping no_damage_from in query parameter serialization

            // Skipping half_damage_from in query parameter serialization

            // Skipping double_damage_from in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeDetailDamageRelations value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeDetailDamageRelations {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub no_damage_to: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub half_damage_to: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub double_damage_to: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub no_damage_from: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub half_damage_from: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub double_damage_from: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeDetailDamageRelations".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "no_damage_to" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailDamageRelations".to_string()),
                    "half_damage_to" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailDamageRelations".to_string()),
                    "double_damage_to" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailDamageRelations".to_string()),
                    "no_damage_from" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailDamageRelations".to_string()),
                    "half_damage_from" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailDamageRelations".to_string()),
                    "double_damage_from" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailDamageRelations".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeDetailDamageRelations".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeDetailDamageRelations {
            no_damage_to: intermediate_rep.no_damage_to.into_iter().next().ok_or_else(|| "no_damage_to missing in TypeDetailDamageRelations".to_string())?,
            half_damage_to: intermediate_rep.half_damage_to.into_iter().next().ok_or_else(|| "half_damage_to missing in TypeDetailDamageRelations".to_string())?,
            double_damage_to: intermediate_rep.double_damage_to.into_iter().next().ok_or_else(|| "double_damage_to missing in TypeDetailDamageRelations".to_string())?,
            no_damage_from: intermediate_rep.no_damage_from.into_iter().next().ok_or_else(|| "no_damage_from missing in TypeDetailDamageRelations".to_string())?,
            half_damage_from: intermediate_rep.half_damage_from.into_iter().next().ok_or_else(|| "half_damage_from missing in TypeDetailDamageRelations".to_string())?,
            double_damage_from: intermediate_rep.double_damage_from.into_iter().next().ok_or_else(|| "double_damage_from missing in TypeDetailDamageRelations".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeDetailDamageRelations> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeDetailDamageRelations>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeDetailDamageRelations>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeDetailDamageRelations - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeDetailDamageRelations> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeDetailDamageRelations as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeDetailDamageRelations - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeDetailPastDamageRelationsInner {
    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::AbilityDetailPokemonInnerPokemon,

    #[serde(rename = "damage_relations")]
          #[validate(nested)]
    pub damage_relations: models::TypeDetailPastDamageRelationsInnerDamageRelations,

}



impl TypeDetailPastDamageRelationsInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(generation: models::AbilityDetailPokemonInnerPokemon, damage_relations: models::TypeDetailPastDamageRelationsInnerDamageRelations, ) -> TypeDetailPastDamageRelationsInner {
        TypeDetailPastDamageRelationsInner {
 generation,
 damage_relations,
        }
    }
}

/// Converts the TypeDetailPastDamageRelationsInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeDetailPastDamageRelationsInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping generation in query parameter serialization

            // Skipping damage_relations in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeDetailPastDamageRelationsInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeDetailPastDamageRelationsInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub generation: Vec<models::AbilityDetailPokemonInnerPokemon>,
            pub damage_relations: Vec<models::TypeDetailPastDamageRelationsInnerDamageRelations>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeDetailPastDamageRelationsInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::AbilityDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "damage_relations" => intermediate_rep.damage_relations.push(<models::TypeDetailPastDamageRelationsInnerDamageRelations as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeDetailPastDamageRelationsInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeDetailPastDamageRelationsInner {
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in TypeDetailPastDamageRelationsInner".to_string())?,
            damage_relations: intermediate_rep.damage_relations.into_iter().next().ok_or_else(|| "damage_relations missing in TypeDetailPastDamageRelationsInner".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeDetailPastDamageRelationsInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeDetailPastDamageRelationsInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeDetailPastDamageRelationsInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeDetailPastDamageRelationsInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeDetailPastDamageRelationsInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeDetailPastDamageRelationsInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeDetailPastDamageRelationsInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeDetailPastDamageRelationsInnerDamageRelations {
    #[serde(rename = "no_damage_to")]
          #[validate(nested)]
    pub no_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "half_damage_to")]
          #[validate(nested)]
    pub half_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "double_damage_to")]
          #[validate(nested)]
    pub double_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "no_damage_from")]
          #[validate(nested)]
    pub no_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "half_damage_from")]
          #[validate(nested)]
    pub half_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "double_damage_from")]
          #[validate(nested)]
    pub double_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>,

}



impl TypeDetailPastDamageRelationsInnerDamageRelations {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(no_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>, half_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>, double_damage_to: Vec<models::AbilityDetailPokemonInnerPokemon>, no_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>, half_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>, double_damage_from: Vec<models::AbilityDetailPokemonInnerPokemon>, ) -> TypeDetailPastDamageRelationsInnerDamageRelations {
        TypeDetailPastDamageRelationsInnerDamageRelations {
 no_damage_to,
 half_damage_to,
 double_damage_to,
 no_damage_from,
 half_damage_from,
 double_damage_from,
        }
    }
}

/// Converts the TypeDetailPastDamageRelationsInnerDamageRelations value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeDetailPastDamageRelationsInnerDamageRelations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![
            // Skipping no_damage_to in query parameter serialization

            // Skipping half_damage_to in query parameter serialization

            // Skipping double_damage_to in query parameter serialization

            // Skipping no_damage_from in query parameter serialization

            // Skipping half_damage_from in query parameter serialization

            // Skipping double_damage_from in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeDetailPastDamageRelationsInnerDamageRelations value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeDetailPastDamageRelationsInnerDamageRelations {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub no_damage_to: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub half_damage_to: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub double_damage_to: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub no_damage_from: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub half_damage_from: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub double_damage_from: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeDetailPastDamageRelationsInnerDamageRelations".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    "no_damage_to" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailPastDamageRelationsInnerDamageRelations".to_string()),
                    "half_damage_to" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailPastDamageRelationsInnerDamageRelations".to_string()),
                    "double_damage_to" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailPastDamageRelationsInnerDamageRelations".to_string()),
                    "no_damage_from" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailPastDamageRelationsInnerDamageRelations".to_string()),
                    "half_damage_from" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailPastDamageRelationsInnerDamageRelations".to_string()),
                    "double_damage_from" => return std::result::Result::Err("Parsing a container in this style is not supported in TypeDetailPastDamageRelationsInnerDamageRelations".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeDetailPastDamageRelationsInnerDamageRelations".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeDetailPastDamageRelationsInnerDamageRelations {
            no_damage_to: intermediate_rep.no_damage_to.into_iter().next().ok_or_else(|| "no_damage_to missing in TypeDetailPastDamageRelationsInnerDamageRelations".to_string())?,
            half_damage_to: intermediate_rep.half_damage_to.into_iter().next().ok_or_else(|| "half_damage_to missing in TypeDetailPastDamageRelationsInnerDamageRelations".to_string())?,
            double_damage_to: intermediate_rep.double_damage_to.into_iter().next().ok_or_else(|| "double_damage_to missing in TypeDetailPastDamageRelationsInnerDamageRelations".to_string())?,
            no_damage_from: intermediate_rep.no_damage_from.into_iter().next().ok_or_else(|| "no_damage_from missing in TypeDetailPastDamageRelationsInnerDamageRelations".to_string())?,
            half_damage_from: intermediate_rep.half_damage_from.into_iter().next().ok_or_else(|| "half_damage_from missing in TypeDetailPastDamageRelationsInnerDamageRelations".to_string())?,
            double_damage_from: intermediate_rep.double_damage_from.into_iter().next().ok_or_else(|| "double_damage_from missing in TypeDetailPastDamageRelationsInnerDamageRelations".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeDetailPastDamageRelationsInnerDamageRelations> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeDetailPastDamageRelationsInnerDamageRelations>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeDetailPastDamageRelationsInnerDamageRelations>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeDetailPastDamageRelationsInnerDamageRelations - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeDetailPastDamageRelationsInnerDamageRelations> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeDetailPastDamageRelationsInnerDamageRelations as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeDetailPastDamageRelationsInnerDamageRelations - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeDetailPokemonInner {
    #[serde(rename = "slot")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub slot: Option<i32>,

    #[serde(rename = "pokemon")]
          #[validate(nested)]
    #[serde(skip_serializing_if="Option::is_none")]
    pub pokemon: Option<models::TypeDetailPokemonInnerPokemon>,

}



impl TypeDetailPokemonInner {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TypeDetailPokemonInner {
        TypeDetailPokemonInner {
 slot: None,
 pokemon: None,
        }
    }
}

/// Converts the TypeDetailPokemonInner value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeDetailPokemonInner {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.slot.as_ref().map(|slot| {
                [
                    "slot".to_string(),
                    slot.to_string(),
                ].join(",")
            }),

            // Skipping pokemon in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeDetailPokemonInner value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeDetailPokemonInner {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub slot: Vec<i32>,
            pub pokemon: Vec<models::TypeDetailPokemonInnerPokemon>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeDetailPokemonInner".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "slot" => intermediate_rep.slot.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "pokemon" => intermediate_rep.pokemon.push(<models::TypeDetailPokemonInnerPokemon as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeDetailPokemonInner".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeDetailPokemonInner {
            slot: intermediate_rep.slot.into_iter().next(),
            pokemon: intermediate_rep.pokemon.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeDetailPokemonInner> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeDetailPokemonInner>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeDetailPokemonInner>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeDetailPokemonInner - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeDetailPokemonInner> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeDetailPokemonInner as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeDetailPokemonInner - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeDetailPokemonInnerPokemon {
    /// The name of the pokemon
    #[serde(rename = "name")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name: Option<String>,

    /// The URL to get more information about the pokemon
    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub url: Option<String>,

}



impl TypeDetailPokemonInnerPokemon {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TypeDetailPokemonInnerPokemon {
        TypeDetailPokemonInnerPokemon {
 name: None,
 url: None,
        }
    }
}

/// Converts the TypeDetailPokemonInnerPokemon value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeDetailPokemonInnerPokemon {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name.as_ref().map(|name| {
                [
                    "name".to_string(),
                    name.to_string(),
                ].join(",")
            }),


            self.url.as_ref().map(|url| {
                [
                    "url".to_string(),
                    url.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeDetailPokemonInnerPokemon value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeDetailPokemonInnerPokemon {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeDetailPokemonInnerPokemon".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeDetailPokemonInnerPokemon".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeDetailPokemonInnerPokemon {
            name: intermediate_rep.name.into_iter().next(),
            url: intermediate_rep.url.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeDetailPokemonInnerPokemon> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeDetailPokemonInnerPokemon>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeDetailPokemonInnerPokemon>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeDetailPokemonInnerPokemon - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeDetailPokemonInnerPokemon> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeDetailPokemonInnerPokemon as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeDetailPokemonInnerPokemon - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeDetailSpritesValueValue {
    #[serde(rename = "name-icon")]
          #[validate(custom(function = "check_xss_string"))]
    #[serde(skip_serializing_if="Option::is_none")]
    pub name_icon: Option<String>,

}



impl TypeDetailSpritesValueValue {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new() -> TypeDetailSpritesValueValue {
        TypeDetailSpritesValueValue {
 name_icon: None,
        }
    }
}

/// Converts the TypeDetailSpritesValueValue value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeDetailSpritesValueValue {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            self.name_icon.as_ref().map(|name_icon| {
                [
                    "name-icon".to_string(),
                    name_icon.to_string(),
                ].join(",")
            }),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeDetailSpritesValueValue value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeDetailSpritesValueValue {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name_icon: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeDetailSpritesValueValue".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name-icon" => intermediate_rep.name_icon.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeDetailSpritesValueValue".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeDetailSpritesValueValue {
            name_icon: intermediate_rep.name_icon.into_iter().next(),
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeDetailSpritesValueValue> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeDetailSpritesValueValue>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeDetailSpritesValueValue>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeDetailSpritesValueValue - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeDetailSpritesValueValue> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeDetailSpritesValueValue as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeDetailSpritesValueValue - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeGameIndex {
    #[serde(rename = "game_index")]
    pub game_index: i32,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::GenerationSummary,

}



impl TypeGameIndex {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(game_index: i32, generation: models::GenerationSummary, ) -> TypeGameIndex {
        TypeGameIndex {
 game_index,
 generation,
        }
    }
}

/// Converts the TypeGameIndex value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeGameIndex {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("game_index".to_string()),
            Some(self.game_index.to_string()),

            // Skipping generation in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeGameIndex value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeGameIndex {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub game_index: Vec<i32>,
            pub generation: Vec<models::GenerationSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeGameIndex".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "game_index" => intermediate_rep.game_index.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeGameIndex".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeGameIndex {
            game_index: intermediate_rep.game_index.into_iter().next().ok_or_else(|| "game_index missing in TypeGameIndex".to_string())?,
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in TypeGameIndex".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeGameIndex> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeGameIndex>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeGameIndex>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeGameIndex - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeGameIndex> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeGameIndex as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeGameIndex - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct TypeSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl TypeSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> TypeSummary {
        TypeSummary {
 name,
 url,
        }
    }
}

/// Converts the TypeSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for TypeSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a TypeSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for TypeSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing TypeSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing TypeSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(TypeSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in TypeSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in TypeSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<TypeSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<TypeSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<TypeSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for TypeSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<TypeSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <TypeSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into TypeSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



/// Should have a link to Version Group info but the Circular dependency and compilation order fight eachother and I'm not sure how to add anything other than a hyperlink
#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VersionDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "names")]
          #[validate(nested)]
    pub names: Vec<models::VersionName>,

    #[serde(rename = "version_group")]
          #[validate(nested)]
    pub version_group: models::VersionGroupSummary,

}



impl VersionDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, names: Vec<models::VersionName>, version_group: models::VersionGroupSummary, ) -> VersionDetail {
        VersionDetail {
 id,
 name,
 names,
 version_group,
        }
    }
}

/// Converts the VersionDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VersionDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping names in query parameter serialization

            // Skipping version_group in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VersionDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VersionDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub names: Vec<Vec<models::VersionName>>,
            pub version_group: Vec<models::VersionGroupSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VersionDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "names" => return std::result::Result::Err("Parsing a container in this style is not supported in VersionDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "version_group" => intermediate_rep.version_group.push(<models::VersionGroupSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VersionDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VersionDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in VersionDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in VersionDetail".to_string())?,
            names: intermediate_rep.names.into_iter().next().ok_or_else(|| "names missing in VersionDetail".to_string())?,
            version_group: intermediate_rep.version_group.into_iter().next().ok_or_else(|| "version_group missing in VersionDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VersionDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VersionDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VersionDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VersionDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VersionDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VersionDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VersionDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VersionGroupDetail {
    #[serde(rename = "id")]
    pub id: i32,

    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "order")]
    #[serde(deserialize_with = "deserialize_optional_nullable")]
    #[serde(default = "default_optional_nullable")]
    #[serde(skip_serializing_if="Option::is_none")]
    pub order: Option<Nullable<i32>>,

    #[serde(rename = "generation")]
          #[validate(nested)]
    pub generation: models::GenerationSummary,

    #[serde(rename = "move_learn_methods")]
          #[validate(nested)]
    pub move_learn_methods: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "pokedexes")]
          #[validate(nested)]
    pub pokedexes: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "regions")]
          #[validate(nested)]
    pub regions: Vec<models::AbilityDetailPokemonInnerPokemon>,

    #[serde(rename = "versions")]
          #[validate(nested)]
    pub versions: Vec<models::VersionSummary>,

}



impl VersionGroupDetail {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(id: i32, name: String, generation: models::GenerationSummary, move_learn_methods: Vec<models::AbilityDetailPokemonInnerPokemon>, pokedexes: Vec<models::AbilityDetailPokemonInnerPokemon>, regions: Vec<models::AbilityDetailPokemonInnerPokemon>, versions: Vec<models::VersionSummary>, ) -> VersionGroupDetail {
        VersionGroupDetail {
 id,
 name,
 order: None,
 generation,
 move_learn_methods,
 pokedexes,
 regions,
 versions,
        }
    }
}

/// Converts the VersionGroupDetail value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VersionGroupDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("id".to_string()),
            Some(self.id.to_string()),


            Some("name".to_string()),
            Some(self.name.to_string()),


            self.order.as_ref().map(|order| {
                [
                    "order".to_string(),
                    order.as_ref().map_or("null".to_string(), |x| x.to_string()),
                ].join(",")
            }),

            // Skipping generation in query parameter serialization

            // Skipping move_learn_methods in query parameter serialization

            // Skipping pokedexes in query parameter serialization

            // Skipping regions in query parameter serialization

            // Skipping versions in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VersionGroupDetail value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VersionGroupDetail {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub id: Vec<i32>,
            pub name: Vec<String>,
            pub order: Vec<i32>,
            pub generation: Vec<models::GenerationSummary>,
            pub move_learn_methods: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub pokedexes: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub regions: Vec<Vec<models::AbilityDetailPokemonInnerPokemon>>,
            pub versions: Vec<Vec<models::VersionSummary>>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VersionGroupDetail".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "id" => intermediate_rep.id.push(<i32 as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "order" => return std::result::Result::Err("Parsing a nullable type in this style is not supported in VersionGroupDetail".to_string()),
                    #[allow(clippy::redundant_clone)]
                    "generation" => intermediate_rep.generation.push(<models::GenerationSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    "move_learn_methods" => return std::result::Result::Err("Parsing a container in this style is not supported in VersionGroupDetail".to_string()),
                    "pokedexes" => return std::result::Result::Err("Parsing a container in this style is not supported in VersionGroupDetail".to_string()),
                    "regions" => return std::result::Result::Err("Parsing a container in this style is not supported in VersionGroupDetail".to_string()),
                    "versions" => return std::result::Result::Err("Parsing a container in this style is not supported in VersionGroupDetail".to_string()),
                    _ => return std::result::Result::Err("Unexpected key while parsing VersionGroupDetail".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VersionGroupDetail {
            id: intermediate_rep.id.into_iter().next().ok_or_else(|| "id missing in VersionGroupDetail".to_string())?,
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in VersionGroupDetail".to_string())?,
            order: std::result::Result::Err("Nullable types not supported in VersionGroupDetail".to_string())?,
            generation: intermediate_rep.generation.into_iter().next().ok_or_else(|| "generation missing in VersionGroupDetail".to_string())?,
            move_learn_methods: intermediate_rep.move_learn_methods.into_iter().next().ok_or_else(|| "move_learn_methods missing in VersionGroupDetail".to_string())?,
            pokedexes: intermediate_rep.pokedexes.into_iter().next().ok_or_else(|| "pokedexes missing in VersionGroupDetail".to_string())?,
            regions: intermediate_rep.regions.into_iter().next().ok_or_else(|| "regions missing in VersionGroupDetail".to_string())?,
            versions: intermediate_rep.versions.into_iter().next().ok_or_else(|| "versions missing in VersionGroupDetail".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VersionGroupDetail> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VersionGroupDetail>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VersionGroupDetail>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VersionGroupDetail - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VersionGroupDetail> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VersionGroupDetail as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VersionGroupDetail - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VersionGroupSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl VersionGroupSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> VersionGroupSummary {
        VersionGroupSummary {
 name,
 url,
        }
    }
}

/// Converts the VersionGroupSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VersionGroupSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VersionGroupSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VersionGroupSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VersionGroupSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VersionGroupSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VersionGroupSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in VersionGroupSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in VersionGroupSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VersionGroupSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VersionGroupSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VersionGroupSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VersionGroupSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VersionGroupSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VersionGroupSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VersionGroupSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VersionName {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "language")]
          #[validate(nested)]
    pub language: models::LanguageSummary,

}



impl VersionName {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, language: models::LanguageSummary, ) -> VersionName {
        VersionName {
 name,
 language,
        }
    }
}

/// Converts the VersionName value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VersionName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),

            // Skipping language in query parameter serialization

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VersionName value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VersionName {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub language: Vec<models::LanguageSummary>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VersionName".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "language" => intermediate_rep.language.push(<models::LanguageSummary as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VersionName".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VersionName {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in VersionName".to_string())?,
            language: intermediate_rep.language.into_iter().next().ok_or_else(|| "language missing in VersionName".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VersionName> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VersionName>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VersionName>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VersionName - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VersionName> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VersionName as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VersionName - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}



#[derive(Debug, Clone, PartialEq, serde::Serialize, serde::Deserialize, validator::Validate)]
#[cfg_attr(feature = "conversion", derive(frunk::LabelledGeneric))]
pub struct VersionSummary {
    #[serde(rename = "name")]
    #[validate(
            length(max = 100),
          custom(function = "check_xss_string"),
    )]
    pub name: String,

    #[serde(rename = "url")]
          #[validate(custom(function = "check_xss_string"))]
    pub url: String,

}



impl VersionSummary {
    #[allow(clippy::new_without_default, clippy::too_many_arguments)]
    pub fn new(name: String, url: String, ) -> VersionSummary {
        VersionSummary {
 name,
 url,
        }
    }
}

/// Converts the VersionSummary value to the Query Parameters representation (style=form, explode=false)
/// specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde serializer
impl std::fmt::Display for VersionSummary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let params: Vec<Option<String>> = vec![

            Some("name".to_string()),
            Some(self.name.to_string()),


            Some("url".to_string()),
            Some(self.url.to_string()),

        ];

        write!(f, "{}", params.into_iter().flatten().collect::<Vec<_>>().join(","))
    }
}

/// Converts Query Parameters representation (style=form, explode=false) to a VersionSummary value
/// as specified in https://swagger.io/docs/specification/serialization/
/// Should be implemented in a serde deserializer
impl std::str::FromStr for VersionSummary {
    type Err = String;

    fn from_str(s: &str) -> std::result::Result<Self, Self::Err> {
        /// An intermediate representation of the struct to use for parsing.
        #[derive(Default)]
        #[allow(dead_code)]
        struct IntermediateRep {
            pub name: Vec<String>,
            pub url: Vec<String>,
        }

        let mut intermediate_rep = IntermediateRep::default();

        // Parse into intermediate representation
        let mut string_iter = s.split(',');
        let mut key_result = string_iter.next();

        while key_result.is_some() {
            let val = match string_iter.next() {
                Some(x) => x,
                None => return std::result::Result::Err("Missing value while parsing VersionSummary".to_string())
            };

            if let Some(key) = key_result {
                #[allow(clippy::match_single_binding)]
                match key {
                    #[allow(clippy::redundant_clone)]
                    "name" => intermediate_rep.name.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    #[allow(clippy::redundant_clone)]
                    "url" => intermediate_rep.url.push(<String as std::str::FromStr>::from_str(val).map_err(|x| x.to_string())?),
                    _ => return std::result::Result::Err("Unexpected key while parsing VersionSummary".to_string())
                }
            }

            // Get the next key
            key_result = string_iter.next();
        }

        // Use the intermediate representation to return the struct
        std::result::Result::Ok(VersionSummary {
            name: intermediate_rep.name.into_iter().next().ok_or_else(|| "name missing in VersionSummary".to_string())?,
            url: intermediate_rep.url.into_iter().next().ok_or_else(|| "url missing in VersionSummary".to_string())?,
        })
    }
}

// Methods for converting between header::IntoHeaderValue<VersionSummary> and HeaderValue

#[cfg(feature = "server")]
impl std::convert::TryFrom<header::IntoHeaderValue<VersionSummary>> for HeaderValue {
    type Error = String;

    fn try_from(hdr_value: header::IntoHeaderValue<VersionSummary>) -> std::result::Result<Self, Self::Error> {
        let hdr_value = hdr_value.to_string();
        match HeaderValue::from_str(&hdr_value) {
             std::result::Result::Ok(value) => std::result::Result::Ok(value),
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Invalid header value for VersionSummary - value: {hdr_value} is invalid {e}"#))
        }
    }
}

#[cfg(feature = "server")]
impl std::convert::TryFrom<HeaderValue> for header::IntoHeaderValue<VersionSummary> {
    type Error = String;

    fn try_from(hdr_value: HeaderValue) -> std::result::Result<Self, Self::Error> {
        match hdr_value.to_str() {
             std::result::Result::Ok(value) => {
                    match <VersionSummary as std::str::FromStr>::from_str(value) {
                        std::result::Result::Ok(value) => std::result::Result::Ok(header::IntoHeaderValue(value)),
                        std::result::Result::Err(err) => std::result::Result::Err(format!(r#"Unable to convert header value '{value}' into VersionSummary - {err}"#))
                    }
             },
             std::result::Result::Err(e) => std::result::Result::Err(format!(r#"Unable to convert header: {hdr_value:?} to string: {e}"#))
        }
    }
}


