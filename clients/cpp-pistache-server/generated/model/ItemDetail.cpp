/**
* PokéAPI
* All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
*
* The version of the OpenAPI document: 2.7.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "ItemDetail.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

ItemDetail::ItemDetail()
{
    m_Id = 0;
    m_Name = "";
    m_Cost = 0;
    m_CostIsSet = false;
    m_Fling_power = 0;
    m_Fling_powerIsSet = false;
    
}

void ItemDetail::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool ItemDetail::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool ItemDetail::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "ItemDetail" : pathPrefix;

             
    
    /* Name */ {
        const std::string& value = m_Name;
        const std::string currentValuePath = _pathPrefix + ".name";
                
        
        if (value.length() > 100)
        {
            success = false;
            msg << currentValuePath << ": must be at most 100 characters long;";
        }

    }
                
    if (!m_Fling_effect.validate(msg, _pathPrefix + ".flingEffect")) {
        msg << _pathPrefix << ": Fling_effect is invalid;";
        success = false;
    }     
    
    /* Attributes */ {
        const std::vector<org::openapitools::server::model::AbilityDetail_pokemon_inner_pokemon>& value = m_Attributes;
        const std::string currentValuePath = _pathPrefix + ".attributes";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::AbilityDetail_pokemon_inner_pokemon& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".attributes") && success;
 
                i++;
            }
        }

    }
        
    if (!m_Category.validate(msg, _pathPrefix + ".category")) {
        msg << _pathPrefix << ": Category is invalid;";
        success = false;
    }     
    
    /* Effect_entries */ {
        const std::vector<org::openapitools::server::model::ItemEffectText>& value = m_Effect_entries;
        const std::string currentValuePath = _pathPrefix + ".effectEntries";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::ItemEffectText& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".effectEntries") && success;
 
                i++;
            }
        }

    }
         
    
    /* Flavor_text_entries */ {
        const std::vector<org::openapitools::server::model::ItemFlavorText>& value = m_Flavor_text_entries;
        const std::string currentValuePath = _pathPrefix + ".flavorTextEntries";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::ItemFlavorText& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".flavorTextEntries") && success;
 
                i++;
            }
        }

    }
         
    
    /* Game_indices */ {
        const std::vector<org::openapitools::server::model::ItemGameIndex>& value = m_Game_indices;
        const std::string currentValuePath = _pathPrefix + ".gameIndices";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::ItemGameIndex& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".gameIndices") && success;
 
                i++;
            }
        }

    }
         
    
    /* Names */ {
        const std::vector<org::openapitools::server::model::ItemName>& value = m_Names;
        const std::string currentValuePath = _pathPrefix + ".names";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::ItemName& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".names") && success;
 
                i++;
            }
        }

    }
         
    
    /* Held_by_pokemon */ {
        const std::vector<org::openapitools::server::model::ItemDetail_held_by_pokemon_inner>& value = m_Held_by_pokemon;
        const std::string currentValuePath = _pathPrefix + ".heldByPokemon";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::ItemDetail_held_by_pokemon_inner& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".heldByPokemon") && success;
 
                i++;
            }
        }

    }
        
    if (!m_Sprites.validate(msg, _pathPrefix + ".sprites")) {
        msg << _pathPrefix << ": Sprites is invalid;";
        success = false;
    }    
    if (!m_Baby_trigger_for.validate(msg, _pathPrefix + ".babyTriggerFor")) {
        msg << _pathPrefix << ": Baby_trigger_for is invalid;";
        success = false;
    }     
    
    /* Machines */ {
        const std::vector<org::openapitools::server::model::ItemDetail_machines_inner>& value = m_Machines;
        const std::string currentValuePath = _pathPrefix + ".machines";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::ItemDetail_machines_inner& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".machines") && success;
 
                i++;
            }
        }

    }
    
    return success;
}

bool ItemDetail::operator==(const ItemDetail& rhs) const
{
    return
    
    
    (getId() == rhs.getId())
     &&
    
    (getName() == rhs.getName())
     &&
    
    
    ((!costIsSet() && !rhs.costIsSet()) || (costIsSet() && rhs.costIsSet() && getCost() == rhs.getCost())) &&
    
    
    ((!flingPowerIsSet() && !rhs.flingPowerIsSet()) || (flingPowerIsSet() && rhs.flingPowerIsSet() && getFlingPower() == rhs.getFlingPower())) &&
    
    (getFlingEffect() == rhs.getFlingEffect())
     &&
    
    (getAttributes() == rhs.getAttributes())
     &&
    
    (getCategory() == rhs.getCategory())
     &&
    
    (getEffectEntries() == rhs.getEffectEntries())
     &&
    
    (getFlavorTextEntries() == rhs.getFlavorTextEntries())
     &&
    
    (getGameIndices() == rhs.getGameIndices())
     &&
    
    (getNames() == rhs.getNames())
     &&
    
    (getHeldByPokemon() == rhs.getHeldByPokemon())
     &&
    
    (getSprites() == rhs.getSprites())
     &&
    
    (getBabyTriggerFor() == rhs.getBabyTriggerFor())
     &&
    
    (getMachines() == rhs.getMachines())
    
    
    ;
}

bool ItemDetail::operator!=(const ItemDetail& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const ItemDetail& o)
{
    j = nlohmann::json::object();
    j["id"] = o.m_Id;
    j["name"] = o.m_Name;
    if(o.costIsSet())
        j["cost"] = o.m_Cost;
    if(o.flingPowerIsSet())
        j["fling_power"] = o.m_Fling_power;
    j["fling_effect"] = o.m_Fling_effect;
    j["attributes"] = o.m_Attributes;
    j["category"] = o.m_Category;
    j["effect_entries"] = o.m_Effect_entries;
    j["flavor_text_entries"] = o.m_Flavor_text_entries;
    j["game_indices"] = o.m_Game_indices;
    j["names"] = o.m_Names;
    j["held_by_pokemon"] = o.m_Held_by_pokemon;
    j["sprites"] = o.m_Sprites;
    j["baby_trigger_for"] = o.m_Baby_trigger_for;
    j["machines"] = o.m_Machines;
    
}

void from_json(const nlohmann::json& j, ItemDetail& o)
{
    j.at("id").get_to(o.m_Id);
    j.at("name").get_to(o.m_Name);
    if(j.find("cost") != j.end())
    {
        j.at("cost").get_to(o.m_Cost);
        o.m_CostIsSet = true;
    } 
    if(j.find("fling_power") != j.end())
    {
        j.at("fling_power").get_to(o.m_Fling_power);
        o.m_Fling_powerIsSet = true;
    } 
    j.at("fling_effect").get_to(o.m_Fling_effect);
    j.at("attributes").get_to(o.m_Attributes);
    j.at("category").get_to(o.m_Category);
    j.at("effect_entries").get_to(o.m_Effect_entries);
    j.at("flavor_text_entries").get_to(o.m_Flavor_text_entries);
    j.at("game_indices").get_to(o.m_Game_indices);
    j.at("names").get_to(o.m_Names);
    j.at("held_by_pokemon").get_to(o.m_Held_by_pokemon);
    j.at("sprites").get_to(o.m_Sprites);
    j.at("baby_trigger_for").get_to(o.m_Baby_trigger_for);
    j.at("machines").get_to(o.m_Machines);
    
}

int32_t ItemDetail::getId() const
{
    return m_Id;
}
void ItemDetail::setId(int32_t const value)
{
    m_Id = value;
}
std::string ItemDetail::getName() const
{
    return m_Name;
}
void ItemDetail::setName(std::string const& value)
{
    m_Name = value;
}
int32_t ItemDetail::getCost() const
{
    return m_Cost;
}
void ItemDetail::setCost(int32_t const value)
{
    m_Cost = value;
    m_CostIsSet = true;
}
bool ItemDetail::costIsSet() const
{
    return m_CostIsSet;
}
void ItemDetail::unsetCost()
{
    m_CostIsSet = false;
}
int32_t ItemDetail::getFlingPower() const
{
    return m_Fling_power;
}
void ItemDetail::setFlingPower(int32_t const value)
{
    m_Fling_power = value;
    m_Fling_powerIsSet = true;
}
bool ItemDetail::flingPowerIsSet() const
{
    return m_Fling_powerIsSet;
}
void ItemDetail::unsetFling_power()
{
    m_Fling_powerIsSet = false;
}
org::openapitools::server::model::ItemFlingEffectSummary ItemDetail::getFlingEffect() const
{
    return m_Fling_effect;
}
void ItemDetail::setFlingEffect(org::openapitools::server::model::ItemFlingEffectSummary const& value)
{
    m_Fling_effect = value;
}
std::vector<org::openapitools::server::model::AbilityDetail_pokemon_inner_pokemon> ItemDetail::getAttributes() const
{
    return m_Attributes;
}
void ItemDetail::setAttributes(std::vector<org::openapitools::server::model::AbilityDetail_pokemon_inner_pokemon> const& value)
{
    m_Attributes = value;
}
org::openapitools::server::model::ItemCategorySummary ItemDetail::getCategory() const
{
    return m_Category;
}
void ItemDetail::setCategory(org::openapitools::server::model::ItemCategorySummary const& value)
{
    m_Category = value;
}
std::vector<org::openapitools::server::model::ItemEffectText> ItemDetail::getEffectEntries() const
{
    return m_Effect_entries;
}
void ItemDetail::setEffectEntries(std::vector<org::openapitools::server::model::ItemEffectText> const& value)
{
    m_Effect_entries = value;
}
std::vector<org::openapitools::server::model::ItemFlavorText> ItemDetail::getFlavorTextEntries() const
{
    return m_Flavor_text_entries;
}
void ItemDetail::setFlavorTextEntries(std::vector<org::openapitools::server::model::ItemFlavorText> const& value)
{
    m_Flavor_text_entries = value;
}
std::vector<org::openapitools::server::model::ItemGameIndex> ItemDetail::getGameIndices() const
{
    return m_Game_indices;
}
void ItemDetail::setGameIndices(std::vector<org::openapitools::server::model::ItemGameIndex> const& value)
{
    m_Game_indices = value;
}
std::vector<org::openapitools::server::model::ItemName> ItemDetail::getNames() const
{
    return m_Names;
}
void ItemDetail::setNames(std::vector<org::openapitools::server::model::ItemName> const& value)
{
    m_Names = value;
}
std::vector<org::openapitools::server::model::ItemDetail_held_by_pokemon_inner> ItemDetail::getHeldByPokemon() const
{
    return m_Held_by_pokemon;
}
void ItemDetail::setHeldByPokemon(std::vector<org::openapitools::server::model::ItemDetail_held_by_pokemon_inner> const& value)
{
    m_Held_by_pokemon = value;
}
org::openapitools::server::model::ItemDetail_sprites ItemDetail::getSprites() const
{
    return m_Sprites;
}
void ItemDetail::setSprites(org::openapitools::server::model::ItemDetail_sprites const& value)
{
    m_Sprites = value;
}
org::openapitools::server::model::ItemDetail_baby_trigger_for ItemDetail::getBabyTriggerFor() const
{
    return m_Baby_trigger_for;
}
void ItemDetail::setBabyTriggerFor(org::openapitools::server::model::ItemDetail_baby_trigger_for const& value)
{
    m_Baby_trigger_for = value;
}
std::vector<org::openapitools::server::model::ItemDetail_machines_inner> ItemDetail::getMachines() const
{
    return m_Machines;
}
void ItemDetail::setMachines(std::vector<org::openapitools::server::model::ItemDetail_machines_inner> const& value)
{
    m_Machines = value;
}


} // namespace org::openapitools::server::model

