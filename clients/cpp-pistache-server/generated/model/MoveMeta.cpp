/**
* PokéAPI
* All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
*
* The version of the OpenAPI document: 2.7.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "MoveMeta.h"
#include "Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

MoveMeta::MoveMeta()
{
    m_Min_hits = 0;
    m_Min_hitsIsSet = false;
    m_Max_hits = 0;
    m_Max_hitsIsSet = false;
    m_Min_turns = 0;
    m_Min_turnsIsSet = false;
    m_Max_turns = 0;
    m_Max_turnsIsSet = false;
    m_Drain = 0;
    m_DrainIsSet = false;
    m_Healing = 0;
    m_HealingIsSet = false;
    m_Crit_rate = 0;
    m_Crit_rateIsSet = false;
    m_Ailment_chance = 0;
    m_Ailment_chanceIsSet = false;
    m_Flinch_chance = 0;
    m_Flinch_chanceIsSet = false;
    m_Stat_chance = 0;
    m_Stat_chanceIsSet = false;
    
}

void MoveMeta::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool MoveMeta::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool MoveMeta::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "MoveMeta" : pathPrefix;

        
    if (!m_Ailment.validate(msg, _pathPrefix + ".ailment")) {
        msg << _pathPrefix << ": Ailment is invalid;";
        success = false;
    }    
    if (!m_Category.validate(msg, _pathPrefix + ".category")) {
        msg << _pathPrefix << ": Category is invalid;";
        success = false;
    }                                        
    return success;
}

bool MoveMeta::operator==(const MoveMeta& rhs) const
{
    return
    
    
    (getAilment() == rhs.getAilment())
     &&
    
    (getCategory() == rhs.getCategory())
     &&
    
    
    ((!minHitsIsSet() && !rhs.minHitsIsSet()) || (minHitsIsSet() && rhs.minHitsIsSet() && getMinHits() == rhs.getMinHits())) &&
    
    
    ((!maxHitsIsSet() && !rhs.maxHitsIsSet()) || (maxHitsIsSet() && rhs.maxHitsIsSet() && getMaxHits() == rhs.getMaxHits())) &&
    
    
    ((!minTurnsIsSet() && !rhs.minTurnsIsSet()) || (minTurnsIsSet() && rhs.minTurnsIsSet() && getMinTurns() == rhs.getMinTurns())) &&
    
    
    ((!maxTurnsIsSet() && !rhs.maxTurnsIsSet()) || (maxTurnsIsSet() && rhs.maxTurnsIsSet() && getMaxTurns() == rhs.getMaxTurns())) &&
    
    
    ((!drainIsSet() && !rhs.drainIsSet()) || (drainIsSet() && rhs.drainIsSet() && getDrain() == rhs.getDrain())) &&
    
    
    ((!healingIsSet() && !rhs.healingIsSet()) || (healingIsSet() && rhs.healingIsSet() && getHealing() == rhs.getHealing())) &&
    
    
    ((!critRateIsSet() && !rhs.critRateIsSet()) || (critRateIsSet() && rhs.critRateIsSet() && getCritRate() == rhs.getCritRate())) &&
    
    
    ((!ailmentChanceIsSet() && !rhs.ailmentChanceIsSet()) || (ailmentChanceIsSet() && rhs.ailmentChanceIsSet() && getAilmentChance() == rhs.getAilmentChance())) &&
    
    
    ((!flinchChanceIsSet() && !rhs.flinchChanceIsSet()) || (flinchChanceIsSet() && rhs.flinchChanceIsSet() && getFlinchChance() == rhs.getFlinchChance())) &&
    
    
    ((!statChanceIsSet() && !rhs.statChanceIsSet()) || (statChanceIsSet() && rhs.statChanceIsSet() && getStatChance() == rhs.getStatChance()))
    
    ;
}

bool MoveMeta::operator!=(const MoveMeta& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const MoveMeta& o)
{
    j = nlohmann::json::object();
    j["ailment"] = o.m_Ailment;
    j["category"] = o.m_Category;
    if(o.minHitsIsSet())
        j["min_hits"] = o.m_Min_hits;
    if(o.maxHitsIsSet())
        j["max_hits"] = o.m_Max_hits;
    if(o.minTurnsIsSet())
        j["min_turns"] = o.m_Min_turns;
    if(o.maxTurnsIsSet())
        j["max_turns"] = o.m_Max_turns;
    if(o.drainIsSet())
        j["drain"] = o.m_Drain;
    if(o.healingIsSet())
        j["healing"] = o.m_Healing;
    if(o.critRateIsSet())
        j["crit_rate"] = o.m_Crit_rate;
    if(o.ailmentChanceIsSet())
        j["ailment_chance"] = o.m_Ailment_chance;
    if(o.flinchChanceIsSet())
        j["flinch_chance"] = o.m_Flinch_chance;
    if(o.statChanceIsSet())
        j["stat_chance"] = o.m_Stat_chance;
    
}

void from_json(const nlohmann::json& j, MoveMeta& o)
{
    j.at("ailment").get_to(o.m_Ailment);
    j.at("category").get_to(o.m_Category);
    if(j.find("min_hits") != j.end())
    {
        j.at("min_hits").get_to(o.m_Min_hits);
        o.m_Min_hitsIsSet = true;
    } 
    if(j.find("max_hits") != j.end())
    {
        j.at("max_hits").get_to(o.m_Max_hits);
        o.m_Max_hitsIsSet = true;
    } 
    if(j.find("min_turns") != j.end())
    {
        j.at("min_turns").get_to(o.m_Min_turns);
        o.m_Min_turnsIsSet = true;
    } 
    if(j.find("max_turns") != j.end())
    {
        j.at("max_turns").get_to(o.m_Max_turns);
        o.m_Max_turnsIsSet = true;
    } 
    if(j.find("drain") != j.end())
    {
        j.at("drain").get_to(o.m_Drain);
        o.m_DrainIsSet = true;
    } 
    if(j.find("healing") != j.end())
    {
        j.at("healing").get_to(o.m_Healing);
        o.m_HealingIsSet = true;
    } 
    if(j.find("crit_rate") != j.end())
    {
        j.at("crit_rate").get_to(o.m_Crit_rate);
        o.m_Crit_rateIsSet = true;
    } 
    if(j.find("ailment_chance") != j.end())
    {
        j.at("ailment_chance").get_to(o.m_Ailment_chance);
        o.m_Ailment_chanceIsSet = true;
    } 
    if(j.find("flinch_chance") != j.end())
    {
        j.at("flinch_chance").get_to(o.m_Flinch_chance);
        o.m_Flinch_chanceIsSet = true;
    } 
    if(j.find("stat_chance") != j.end())
    {
        j.at("stat_chance").get_to(o.m_Stat_chance);
        o.m_Stat_chanceIsSet = true;
    } 
    
}

org::openapitools::server::model::MoveMetaAilmentSummary MoveMeta::getAilment() const
{
    return m_Ailment;
}
void MoveMeta::setAilment(org::openapitools::server::model::MoveMetaAilmentSummary const& value)
{
    m_Ailment = value;
}
org::openapitools::server::model::MoveMetaCategorySummary MoveMeta::getCategory() const
{
    return m_Category;
}
void MoveMeta::setCategory(org::openapitools::server::model::MoveMetaCategorySummary const& value)
{
    m_Category = value;
}
int32_t MoveMeta::getMinHits() const
{
    return m_Min_hits;
}
void MoveMeta::setMinHits(int32_t const value)
{
    m_Min_hits = value;
    m_Min_hitsIsSet = true;
}
bool MoveMeta::minHitsIsSet() const
{
    return m_Min_hitsIsSet;
}
void MoveMeta::unsetMin_hits()
{
    m_Min_hitsIsSet = false;
}
int32_t MoveMeta::getMaxHits() const
{
    return m_Max_hits;
}
void MoveMeta::setMaxHits(int32_t const value)
{
    m_Max_hits = value;
    m_Max_hitsIsSet = true;
}
bool MoveMeta::maxHitsIsSet() const
{
    return m_Max_hitsIsSet;
}
void MoveMeta::unsetMax_hits()
{
    m_Max_hitsIsSet = false;
}
int32_t MoveMeta::getMinTurns() const
{
    return m_Min_turns;
}
void MoveMeta::setMinTurns(int32_t const value)
{
    m_Min_turns = value;
    m_Min_turnsIsSet = true;
}
bool MoveMeta::minTurnsIsSet() const
{
    return m_Min_turnsIsSet;
}
void MoveMeta::unsetMin_turns()
{
    m_Min_turnsIsSet = false;
}
int32_t MoveMeta::getMaxTurns() const
{
    return m_Max_turns;
}
void MoveMeta::setMaxTurns(int32_t const value)
{
    m_Max_turns = value;
    m_Max_turnsIsSet = true;
}
bool MoveMeta::maxTurnsIsSet() const
{
    return m_Max_turnsIsSet;
}
void MoveMeta::unsetMax_turns()
{
    m_Max_turnsIsSet = false;
}
int32_t MoveMeta::getDrain() const
{
    return m_Drain;
}
void MoveMeta::setDrain(int32_t const value)
{
    m_Drain = value;
    m_DrainIsSet = true;
}
bool MoveMeta::drainIsSet() const
{
    return m_DrainIsSet;
}
void MoveMeta::unsetDrain()
{
    m_DrainIsSet = false;
}
int32_t MoveMeta::getHealing() const
{
    return m_Healing;
}
void MoveMeta::setHealing(int32_t const value)
{
    m_Healing = value;
    m_HealingIsSet = true;
}
bool MoveMeta::healingIsSet() const
{
    return m_HealingIsSet;
}
void MoveMeta::unsetHealing()
{
    m_HealingIsSet = false;
}
int32_t MoveMeta::getCritRate() const
{
    return m_Crit_rate;
}
void MoveMeta::setCritRate(int32_t const value)
{
    m_Crit_rate = value;
    m_Crit_rateIsSet = true;
}
bool MoveMeta::critRateIsSet() const
{
    return m_Crit_rateIsSet;
}
void MoveMeta::unsetCrit_rate()
{
    m_Crit_rateIsSet = false;
}
int32_t MoveMeta::getAilmentChance() const
{
    return m_Ailment_chance;
}
void MoveMeta::setAilmentChance(int32_t const value)
{
    m_Ailment_chance = value;
    m_Ailment_chanceIsSet = true;
}
bool MoveMeta::ailmentChanceIsSet() const
{
    return m_Ailment_chanceIsSet;
}
void MoveMeta::unsetAilment_chance()
{
    m_Ailment_chanceIsSet = false;
}
int32_t MoveMeta::getFlinchChance() const
{
    return m_Flinch_chance;
}
void MoveMeta::setFlinchChance(int32_t const value)
{
    m_Flinch_chance = value;
    m_Flinch_chanceIsSet = true;
}
bool MoveMeta::flinchChanceIsSet() const
{
    return m_Flinch_chanceIsSet;
}
void MoveMeta::unsetFlinch_chance()
{
    m_Flinch_chanceIsSet = false;
}
int32_t MoveMeta::getStatChance() const
{
    return m_Stat_chance;
}
void MoveMeta::setStatChance(int32_t const value)
{
    m_Stat_chance = value;
    m_Stat_chanceIsSet = true;
}
bool MoveMeta::statChanceIsSet() const
{
    return m_Stat_chanceIsSet;
}
void MoveMeta::unsetStat_chance()
{
    m_Stat_chanceIsSet = false;
}


} // namespace org::openapitools::server::model

