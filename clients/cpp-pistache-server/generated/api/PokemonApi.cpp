/**
* PokéAPI
* All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
*
* The version of the OpenAPI document: 2.7.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/

#include "PokemonApi.h"
#include "Helpers.h"

namespace org::openapitools::server::api
{

using namespace org::openapitools::server::helpers;
using namespace org::openapitools::server::model;

const std::string PokemonApi::base = "";

PokemonApi::PokemonApi(const std::shared_ptr<Pistache::Rest::Router>& rtr)
    : ApiBase(rtr)
{}

void PokemonApi::init() {
    setupRoutes();
}

void PokemonApi::setupRoutes() {
    using namespace Pistache::Rest;

    Routes::Get(*router, base + "/api/v2/ability/", Routes::bind(&PokemonApi::ability_list_handler, this));
    Routes::Get(*router, base + "/api/v2/ability/:id/", Routes::bind(&PokemonApi::ability_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/characteristic/", Routes::bind(&PokemonApi::characteristic_list_handler, this));
    Routes::Get(*router, base + "/api/v2/characteristic/:id/", Routes::bind(&PokemonApi::characteristic_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/egg-group/", Routes::bind(&PokemonApi::egg_group_list_handler, this));
    Routes::Get(*router, base + "/api/v2/egg-group/:id/", Routes::bind(&PokemonApi::egg_group_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/gender/", Routes::bind(&PokemonApi::gender_list_handler, this));
    Routes::Get(*router, base + "/api/v2/gender/:id/", Routes::bind(&PokemonApi::gender_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/growth-rate/", Routes::bind(&PokemonApi::growth_rate_list_handler, this));
    Routes::Get(*router, base + "/api/v2/growth-rate/:id/", Routes::bind(&PokemonApi::growth_rate_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/move-damage-class/", Routes::bind(&PokemonApi::move_damage_class_list_handler, this));
    Routes::Get(*router, base + "/api/v2/move-damage-class/:id/", Routes::bind(&PokemonApi::move_damage_class_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/nature/", Routes::bind(&PokemonApi::nature_list_handler, this));
    Routes::Get(*router, base + "/api/v2/nature/:id/", Routes::bind(&PokemonApi::nature_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/pokeathlon-stat/", Routes::bind(&PokemonApi::pokeathlon_stat_list_handler, this));
    Routes::Get(*router, base + "/api/v2/pokeathlon-stat/:id/", Routes::bind(&PokemonApi::pokeathlon_stat_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-color/", Routes::bind(&PokemonApi::pokemon_color_list_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-color/:id/", Routes::bind(&PokemonApi::pokemon_color_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-form/", Routes::bind(&PokemonApi::pokemon_form_list_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-form/:id/", Routes::bind(&PokemonApi::pokemon_form_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-habitat/", Routes::bind(&PokemonApi::pokemon_habitat_list_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-habitat/:id/", Routes::bind(&PokemonApi::pokemon_habitat_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon/", Routes::bind(&PokemonApi::pokemon_list_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon/:id/", Routes::bind(&PokemonApi::pokemon_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-shape/", Routes::bind(&PokemonApi::pokemon_shape_list_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-shape/:id/", Routes::bind(&PokemonApi::pokemon_shape_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-species/", Routes::bind(&PokemonApi::pokemon_species_list_handler, this));
    Routes::Get(*router, base + "/api/v2/pokemon-species/:id/", Routes::bind(&PokemonApi::pokemon_species_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/stat/", Routes::bind(&PokemonApi::stat_list_handler, this));
    Routes::Get(*router, base + "/api/v2/stat/:id/", Routes::bind(&PokemonApi::stat_retrieve_handler, this));
    Routes::Get(*router, base + "/api/v2/type/", Routes::bind(&PokemonApi::type_list_handler, this));
    Routes::Get(*router, base + "/api/v2/type/:id/", Routes::bind(&PokemonApi::type_retrieve_handler, this));

    // Default handler, called when a route is not found
    router->addCustomHandler(Routes::bind(&PokemonApi::pokemon_api_default_handler, this));
}

void PokemonApi::handleParsingException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleParsingException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> PokemonApi::handleParsingException(const std::exception& ex) const noexcept {
    try {
        throw;
    } catch (nlohmann::detail::exception &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (org::openapitools::server::helpers::ValidationException &e) {
        return std::make_pair(Pistache::Http::Code::Bad_Request, e.what());
    } catch (std::exception &e) {
        return std::make_pair(Pistache::Http::Code::Internal_Server_Error, e.what());
    }
}

void PokemonApi::handleOperationException(const std::exception& ex, Pistache::Http::ResponseWriter &response) const noexcept {
    std::pair<Pistache::Http::Code, std::string> codeAndError = handleOperationException(ex);
    response.send(codeAndError.first, codeAndError.second);
}

std::pair<Pistache::Http::Code, std::string> PokemonApi::handleOperationException(const std::exception& ex) const noexcept {
    return std::make_pair(Pistache::Http::Code::Internal_Server_Error, ex.what());
}

void PokemonApi::ability_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->ability_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/ability/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::ability_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->ability_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/ability/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::characteristic_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->characteristic_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/characteristic/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::characteristic_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->characteristic_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/characteristic/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::egg_group_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->egg_group_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/egg-group/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::egg_group_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->egg_group_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/egg-group/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::gender_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->gender_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/gender/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::gender_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->gender_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/gender/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::growth_rate_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->growth_rate_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/growth-rate/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::growth_rate_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->growth_rate_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/growth-rate/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::move_damage_class_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->move_damage_class_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/move-damage-class/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::move_damage_class_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->move_damage_class_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/move-damage-class/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::nature_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->nature_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/nature/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::nature_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->nature_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/nature/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokeathlon_stat_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokeathlon_stat_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokeathlon-stat/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokeathlon_stat_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokeathlon_stat_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokeathlon-stat/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_color_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_color_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-color/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_color_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_color_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-color/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_form_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_form_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-form/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_form_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_form_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-form/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_habitat_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_habitat_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-habitat/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_habitat_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_habitat_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-habitat/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_shape_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_shape_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-shape/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_shape_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_shape_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-shape/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_species_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_species_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-species/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::pokemon_species_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->pokemon_species_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/pokemon-species/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::stat_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->stat_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/stat/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::stat_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->stat_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/stat/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::type_list_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        
        
        // Getting the query params
        auto limitQuery = request.query().get("limit");
        std::optional<int32_t> limit;
        if (limitQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(limitQuery.value(), valueQuery_instance)) {
                limit = valueQuery_instance;
            }
        }
        auto offsetQuery = request.query().get("offset");
        std::optional<int32_t> offset;
        if (offsetQuery.has_value()) {
            int32_t valueQuery_instance;
            if (fromStringValue(offsetQuery.value(), valueQuery_instance)) {
                offset = valueQuery_instance;
            }
        }
        auto qQuery = request.query().get("q");
        std::optional<std::string> q;
        if (qQuery.has_value()) {
            std::string valueQuery_instance;
            if (fromStringValue(qQuery.value(), valueQuery_instance)) {
                q = valueQuery_instance;
            }
        }
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->type_list(credentials,limit, offset, q, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/type/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}

void PokemonApi::type_retrieve_handler(const Pistache::Rest::Request& request, Pistache::Http::ResponseWriter response) {
    try {

        // Getting the path params
        auto id = request.param(":id").as<std::string>();
        
        
    


        try {
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif




#undef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 1

            auto basicAuthHeader = request.headers().tryGet<Pistache::Http::Header::Authorization>();

            if(!basicAuthHeader || (basicAuthHeader->getMethod() != Pistache::Http::Header::Authorization::Method::Basic))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }

            HttpBasicCredentials credentials{basicAuthHeader->getBasicUser(), basicAuthHeader->getBasicPassword()};
            
            if (!this->basicCredentialsAuthenticator.has_value() || !this->basicCredentialsAuthenticator.value()(credentials))
            {
                response.send(Pistache::Http::Code::Unauthorized, "");
                return;
            }



            this->type_retrieve(credentials,id, response);
            } catch (Pistache::Http::HttpError &e) {
                response.send(static_cast<Pistache::Http::Code>(e.code()), e.what());
                return;
            } catch (std::exception &e) {
                this->handleOperationException(e, response);
                return;
            }

    } catch (std::exception &e) {
        response.send(Pistache::Http::Code::Internal_Server_Error, e.what());
    }

#ifndef HTTP_BASIC_AUTH_DEFINED
#define HTTP_BASIC_AUTH_DEFINED 0
#endif
#ifndef HTTP_BEARER_AUTH_DEFINED
#define HTTP_BEARER_AUTH_DEFINED 0
#endif
#define REST_PATH "/api/v2/type/:id/" 
    static_assert(HTTP_BASIC_AUTH_DEFINED + HTTP_BEARER_AUTH_DEFINED < 2, "Path '" REST_PATH "' has more than one security scheme specified, and the Pistache server generator does not support that.");
#undef REST_PATH
#ifdef HTTP_BEARER_AUTH_DEFINED
#undef HTTP_BEARER_AUTH_DEFINED
#endif
#ifdef HTTP_BASIC_AUTH_DEFINED
#undef HTTP_BASIC_AUTH_DEFINED
#endif

}


void PokemonApi::pokemon_api_default_handler(const Pistache::Rest::Request &, Pistache::Http::ResponseWriter response) {
    response.send(Pistache::Http::Code::Not_Found, "The requested method does not exist");
}

} // namespace org::openapitools::server::api

