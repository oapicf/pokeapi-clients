/**
 * PokéAPI
 * All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#ifndef OAI_APIROUTER_H
#define OAI_APIROUTER_H

#include <functional>
#include <QObject>
#include <QStringList>
#include <QSharedPointer>
#include <QList>
#include <QMultiMap>
#include <QRegularExpression>

#include <qhttpengine/socket.h>
#include <qhttpengine/handler.h>
#include <qhttpengine/qobjecthandler.h>

#include "OAIBerriesApiHandler.h"
#include "OAIContestsApiHandler.h"
#include "OAIEncountersApiHandler.h"
#include "OAIEvolutionApiHandler.h"
#include "OAIGamesApiHandler.h"
#include "OAIItemsApiHandler.h"
#include "OAILocationApiHandler.h"
#include "OAIMachinesApiHandler.h"
#include "OAIMovesApiHandler.h"
#include "OAIPokemonApiHandler.h"
#include "OAIUtilityApiHandler.h"


namespace OpenAPI {

class OAIApiRequestHandler : public  QHttpEngine::QObjectHandler
{
    Q_OBJECT
Q_SIGNALS:
    void requestReceived(QHttpEngine::Socket *socket);

protected:
    virtual void process(QHttpEngine::Socket *socket, const QString &path){
        Q_UNUSED(path);

        // If the slot requires all data to be received, check to see if this is
        // already the case, otherwise, wait until the rest of it arrives
        if (socket->bytesAvailable() >= socket->contentLength()) {
            Q_EMIT requestReceived(socket);
        } else {
            connect(socket, &QHttpEngine::Socket::readChannelFinished, [this, socket]() {
                Q_EMIT requestReceived(socket);
            });
        }
    }
};

class OAIApiRouter : public QObject
{
    Q_OBJECT
public:
    OAIApiRouter();
    virtual ~OAIApiRouter();

    void setUpRoutes();
    void processRequest(QHttpEngine::Socket *socket);
    
    void setOAIBerriesApiHandler(QSharedPointer<OAIBerriesApiHandler> handler);
    void setOAIContestsApiHandler(QSharedPointer<OAIContestsApiHandler> handler);
    void setOAIEncountersApiHandler(QSharedPointer<OAIEncountersApiHandler> handler);
    void setOAIEvolutionApiHandler(QSharedPointer<OAIEvolutionApiHandler> handler);
    void setOAIGamesApiHandler(QSharedPointer<OAIGamesApiHandler> handler);
    void setOAIItemsApiHandler(QSharedPointer<OAIItemsApiHandler> handler);
    void setOAILocationApiHandler(QSharedPointer<OAILocationApiHandler> handler);
    void setOAIMachinesApiHandler(QSharedPointer<OAIMachinesApiHandler> handler);
    void setOAIMovesApiHandler(QSharedPointer<OAIMovesApiHandler> handler);
    void setOAIPokemonApiHandler(QSharedPointer<OAIPokemonApiHandler> handler);
    void setOAIUtilityApiHandler(QSharedPointer<OAIUtilityApiHandler> handler);
private:
    QMap<QString, std::function<void(QHttpEngine::Socket *)>> Routes;
    QMultiMap<QString, std::function<void(QHttpEngine::Socket *)>> RoutesWithPathParam;

    bool handleRequest(QHttpEngine::Socket *socket);
    bool handleRequestAndExtractPathParam(QHttpEngine::Socket *socket);

    
    QSharedPointer<OAIBerriesApiHandler> mOAIBerriesApiHandler;
    QSharedPointer<OAIContestsApiHandler> mOAIContestsApiHandler;
    QSharedPointer<OAIEncountersApiHandler> mOAIEncountersApiHandler;
    QSharedPointer<OAIEvolutionApiHandler> mOAIEvolutionApiHandler;
    QSharedPointer<OAIGamesApiHandler> mOAIGamesApiHandler;
    QSharedPointer<OAIItemsApiHandler> mOAIItemsApiHandler;
    QSharedPointer<OAILocationApiHandler> mOAILocationApiHandler;
    QSharedPointer<OAIMachinesApiHandler> mOAIMachinesApiHandler;
    QSharedPointer<OAIMovesApiHandler> mOAIMovesApiHandler;
    QSharedPointer<OAIPokemonApiHandler> mOAIPokemonApiHandler;
    QSharedPointer<OAIUtilityApiHandler> mOAIUtilityApiHandler;
protected:
    // override this method to provide custom class derived from ApiHandler classes
    virtual void createApiHandlers();

private :
    inline QString fromQHttpEngineMethod(QHttpEngine::Socket::Method method){
        switch( method ){
            case QHttpEngine::Socket::Method::OPTIONS:
                return QStringLiteral("OPTIONS");
            case QHttpEngine::Socket::Method::GET:
                return QStringLiteral("GET");
            case QHttpEngine::Socket::Method::HEAD:
                return QStringLiteral("HEAD");
            case QHttpEngine::Socket::Method::POST:
                return QStringLiteral("POST");
            case QHttpEngine::Socket::Method::PUT:
                return QStringLiteral("PUT");
            case QHttpEngine::Socket::Method::DELETE:
                return QStringLiteral("DELETE");
            case QHttpEngine::Socket::Method::TRACE:
                return QStringLiteral("TRACE");
            case QHttpEngine::Socket::Method::CONNECT:
                return QStringLiteral("CONNECT");
        }
        return QStringLiteral("");
    }

    inline QRegularExpressionMatch getRequestMatch(QString serverTemplatePath, QString requestPath){
        QRegularExpression parExpr( R"(\{([^\/\s]+)\})" );
        serverTemplatePath.replace( parExpr, R"((?<\1>[^\/\s]+))" );
        serverTemplatePath.append("[\\/]?$");
        QRegularExpression pathExpr( serverTemplatePath );
        return pathExpr.match( requestPath );
    }

};


}

#endif // OAI_APIROUTER_H
