/**
 * PokéAPI
 * All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "OAIMoveMeta.h"

#include <QDebug>
#include <QJsonArray>
#include <QJsonDocument>
#include <QObject>

#include "OAIHelpers.h"

namespace OpenAPI {

OAIMoveMeta::OAIMoveMeta(QString json) {
    this->initializeModel();
    this->fromJson(json);
}

OAIMoveMeta::OAIMoveMeta() {
    this->initializeModel();
}

OAIMoveMeta::~OAIMoveMeta() {}

void OAIMoveMeta::initializeModel() {

    m_ailment_isSet = false;
    m_ailment_isValid = false;

    m_category_isSet = false;
    m_category_isValid = false;

    m_min_hits_isSet = false;
    m_min_hits_isValid = false;

    m_max_hits_isSet = false;
    m_max_hits_isValid = false;

    m_min_turns_isSet = false;
    m_min_turns_isValid = false;

    m_max_turns_isSet = false;
    m_max_turns_isValid = false;

    m_drain_isSet = false;
    m_drain_isValid = false;

    m_healing_isSet = false;
    m_healing_isValid = false;

    m_crit_rate_isSet = false;
    m_crit_rate_isValid = false;

    m_ailment_chance_isSet = false;
    m_ailment_chance_isValid = false;

    m_flinch_chance_isSet = false;
    m_flinch_chance_isValid = false;

    m_stat_chance_isSet = false;
    m_stat_chance_isValid = false;
}

void OAIMoveMeta::fromJson(QString jsonString) {
    QByteArray array(jsonString.toStdString().c_str());
    QJsonDocument doc = QJsonDocument::fromJson(array);
    QJsonObject jsonObject = doc.object();
    this->fromJsonObject(jsonObject);
}

void OAIMoveMeta::fromJsonObject(QJsonObject json) {

    m_ailment_isValid = ::OpenAPI::fromJsonValue(ailment, json[QString("ailment")]);
    m_ailment_isSet = !json[QString("ailment")].isNull() && m_ailment_isValid;

    m_category_isValid = ::OpenAPI::fromJsonValue(category, json[QString("category")]);
    m_category_isSet = !json[QString("category")].isNull() && m_category_isValid;

    m_min_hits_isValid = ::OpenAPI::fromJsonValue(min_hits, json[QString("min_hits")]);
    m_min_hits_isSet = !json[QString("min_hits")].isNull() && m_min_hits_isValid;

    m_max_hits_isValid = ::OpenAPI::fromJsonValue(max_hits, json[QString("max_hits")]);
    m_max_hits_isSet = !json[QString("max_hits")].isNull() && m_max_hits_isValid;

    m_min_turns_isValid = ::OpenAPI::fromJsonValue(min_turns, json[QString("min_turns")]);
    m_min_turns_isSet = !json[QString("min_turns")].isNull() && m_min_turns_isValid;

    m_max_turns_isValid = ::OpenAPI::fromJsonValue(max_turns, json[QString("max_turns")]);
    m_max_turns_isSet = !json[QString("max_turns")].isNull() && m_max_turns_isValid;

    m_drain_isValid = ::OpenAPI::fromJsonValue(drain, json[QString("drain")]);
    m_drain_isSet = !json[QString("drain")].isNull() && m_drain_isValid;

    m_healing_isValid = ::OpenAPI::fromJsonValue(healing, json[QString("healing")]);
    m_healing_isSet = !json[QString("healing")].isNull() && m_healing_isValid;

    m_crit_rate_isValid = ::OpenAPI::fromJsonValue(crit_rate, json[QString("crit_rate")]);
    m_crit_rate_isSet = !json[QString("crit_rate")].isNull() && m_crit_rate_isValid;

    m_ailment_chance_isValid = ::OpenAPI::fromJsonValue(ailment_chance, json[QString("ailment_chance")]);
    m_ailment_chance_isSet = !json[QString("ailment_chance")].isNull() && m_ailment_chance_isValid;

    m_flinch_chance_isValid = ::OpenAPI::fromJsonValue(flinch_chance, json[QString("flinch_chance")]);
    m_flinch_chance_isSet = !json[QString("flinch_chance")].isNull() && m_flinch_chance_isValid;

    m_stat_chance_isValid = ::OpenAPI::fromJsonValue(stat_chance, json[QString("stat_chance")]);
    m_stat_chance_isSet = !json[QString("stat_chance")].isNull() && m_stat_chance_isValid;
}

QString OAIMoveMeta::asJson() const {
    QJsonObject obj = this->asJsonObject();
    QJsonDocument doc(obj);
    QByteArray bytes = doc.toJson();
    return QString(bytes);
}

QJsonObject OAIMoveMeta::asJsonObject() const {
    QJsonObject obj;
    if (ailment.isSet()) {
        obj.insert(QString("ailment"), ::OpenAPI::toJsonValue(ailment));
    }
    if (category.isSet()) {
        obj.insert(QString("category"), ::OpenAPI::toJsonValue(category));
    }
    if (m_min_hits_isSet) {
        obj.insert(QString("min_hits"), ::OpenAPI::toJsonValue(min_hits));
    }
    if (m_max_hits_isSet) {
        obj.insert(QString("max_hits"), ::OpenAPI::toJsonValue(max_hits));
    }
    if (m_min_turns_isSet) {
        obj.insert(QString("min_turns"), ::OpenAPI::toJsonValue(min_turns));
    }
    if (m_max_turns_isSet) {
        obj.insert(QString("max_turns"), ::OpenAPI::toJsonValue(max_turns));
    }
    if (m_drain_isSet) {
        obj.insert(QString("drain"), ::OpenAPI::toJsonValue(drain));
    }
    if (m_healing_isSet) {
        obj.insert(QString("healing"), ::OpenAPI::toJsonValue(healing));
    }
    if (m_crit_rate_isSet) {
        obj.insert(QString("crit_rate"), ::OpenAPI::toJsonValue(crit_rate));
    }
    if (m_ailment_chance_isSet) {
        obj.insert(QString("ailment_chance"), ::OpenAPI::toJsonValue(ailment_chance));
    }
    if (m_flinch_chance_isSet) {
        obj.insert(QString("flinch_chance"), ::OpenAPI::toJsonValue(flinch_chance));
    }
    if (m_stat_chance_isSet) {
        obj.insert(QString("stat_chance"), ::OpenAPI::toJsonValue(stat_chance));
    }
    return obj;
}

OAIMoveMetaAilmentSummary OAIMoveMeta::getAilment() const {
    return ailment;
}
void OAIMoveMeta::setAilment(const OAIMoveMetaAilmentSummary &ailment) {
    this->ailment = ailment;
    this->m_ailment_isSet = true;
}

bool OAIMoveMeta::is_ailment_Set() const{
    return m_ailment_isSet;
}

bool OAIMoveMeta::is_ailment_Valid() const{
    return m_ailment_isValid;
}

OAIMoveMetaCategorySummary OAIMoveMeta::getCategory() const {
    return category;
}
void OAIMoveMeta::setCategory(const OAIMoveMetaCategorySummary &category) {
    this->category = category;
    this->m_category_isSet = true;
}

bool OAIMoveMeta::is_category_Set() const{
    return m_category_isSet;
}

bool OAIMoveMeta::is_category_Valid() const{
    return m_category_isValid;
}

qint32 OAIMoveMeta::getMinHits() const {
    return min_hits;
}
void OAIMoveMeta::setMinHits(const qint32 &min_hits) {
    this->min_hits = min_hits;
    this->m_min_hits_isSet = true;
}

bool OAIMoveMeta::is_min_hits_Set() const{
    return m_min_hits_isSet;
}

bool OAIMoveMeta::is_min_hits_Valid() const{
    return m_min_hits_isValid;
}

qint32 OAIMoveMeta::getMaxHits() const {
    return max_hits;
}
void OAIMoveMeta::setMaxHits(const qint32 &max_hits) {
    this->max_hits = max_hits;
    this->m_max_hits_isSet = true;
}

bool OAIMoveMeta::is_max_hits_Set() const{
    return m_max_hits_isSet;
}

bool OAIMoveMeta::is_max_hits_Valid() const{
    return m_max_hits_isValid;
}

qint32 OAIMoveMeta::getMinTurns() const {
    return min_turns;
}
void OAIMoveMeta::setMinTurns(const qint32 &min_turns) {
    this->min_turns = min_turns;
    this->m_min_turns_isSet = true;
}

bool OAIMoveMeta::is_min_turns_Set() const{
    return m_min_turns_isSet;
}

bool OAIMoveMeta::is_min_turns_Valid() const{
    return m_min_turns_isValid;
}

qint32 OAIMoveMeta::getMaxTurns() const {
    return max_turns;
}
void OAIMoveMeta::setMaxTurns(const qint32 &max_turns) {
    this->max_turns = max_turns;
    this->m_max_turns_isSet = true;
}

bool OAIMoveMeta::is_max_turns_Set() const{
    return m_max_turns_isSet;
}

bool OAIMoveMeta::is_max_turns_Valid() const{
    return m_max_turns_isValid;
}

qint32 OAIMoveMeta::getDrain() const {
    return drain;
}
void OAIMoveMeta::setDrain(const qint32 &drain) {
    this->drain = drain;
    this->m_drain_isSet = true;
}

bool OAIMoveMeta::is_drain_Set() const{
    return m_drain_isSet;
}

bool OAIMoveMeta::is_drain_Valid() const{
    return m_drain_isValid;
}

qint32 OAIMoveMeta::getHealing() const {
    return healing;
}
void OAIMoveMeta::setHealing(const qint32 &healing) {
    this->healing = healing;
    this->m_healing_isSet = true;
}

bool OAIMoveMeta::is_healing_Set() const{
    return m_healing_isSet;
}

bool OAIMoveMeta::is_healing_Valid() const{
    return m_healing_isValid;
}

qint32 OAIMoveMeta::getCritRate() const {
    return crit_rate;
}
void OAIMoveMeta::setCritRate(const qint32 &crit_rate) {
    this->crit_rate = crit_rate;
    this->m_crit_rate_isSet = true;
}

bool OAIMoveMeta::is_crit_rate_Set() const{
    return m_crit_rate_isSet;
}

bool OAIMoveMeta::is_crit_rate_Valid() const{
    return m_crit_rate_isValid;
}

qint32 OAIMoveMeta::getAilmentChance() const {
    return ailment_chance;
}
void OAIMoveMeta::setAilmentChance(const qint32 &ailment_chance) {
    this->ailment_chance = ailment_chance;
    this->m_ailment_chance_isSet = true;
}

bool OAIMoveMeta::is_ailment_chance_Set() const{
    return m_ailment_chance_isSet;
}

bool OAIMoveMeta::is_ailment_chance_Valid() const{
    return m_ailment_chance_isValid;
}

qint32 OAIMoveMeta::getFlinchChance() const {
    return flinch_chance;
}
void OAIMoveMeta::setFlinchChance(const qint32 &flinch_chance) {
    this->flinch_chance = flinch_chance;
    this->m_flinch_chance_isSet = true;
}

bool OAIMoveMeta::is_flinch_chance_Set() const{
    return m_flinch_chance_isSet;
}

bool OAIMoveMeta::is_flinch_chance_Valid() const{
    return m_flinch_chance_isValid;
}

qint32 OAIMoveMeta::getStatChance() const {
    return stat_chance;
}
void OAIMoveMeta::setStatChance(const qint32 &stat_chance) {
    this->stat_chance = stat_chance;
    this->m_stat_chance_isSet = true;
}

bool OAIMoveMeta::is_stat_chance_Set() const{
    return m_stat_chance_isSet;
}

bool OAIMoveMeta::is_stat_chance_Valid() const{
    return m_stat_chance_isValid;
}

bool OAIMoveMeta::isSet() const {
    bool isObjectUpdated = false;
    do {
        if (ailment.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (category.isSet()) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_hits_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_hits_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_min_turns_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_max_turns_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_drain_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_healing_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_crit_rate_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_ailment_chance_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_flinch_chance_isSet) {
            isObjectUpdated = true;
            break;
        }

        if (m_stat_chance_isSet) {
            isObjectUpdated = true;
            break;
        }
    } while (false);
    return isObjectUpdated;
}

bool OAIMoveMeta::isValid() const {
    // only required properties are required for the object to be considered valid
    return m_ailment_isValid && m_category_isValid && true;
}

} // namespace OpenAPI
