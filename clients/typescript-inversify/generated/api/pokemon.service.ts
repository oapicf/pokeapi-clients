/**
 * PokéAPI
 * All the Pokémon data you\'ll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We\'ve covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Observable } from 'rxjs/Observable';

import { map } from 'rxjs/operators';
import IHttpClient from '../IHttpClient';
import { inject, injectable } from 'inversify';
import { IAPIConfiguration } from '../IAPIConfiguration';
import { Headers } from '../Headers';
import HttpResponse from '../HttpResponse';

import { AbilityDetail } from '../model/abilityDetail';
import { CharacteristicDetail } from '../model/characteristicDetail';
import { EggGroupDetail } from '../model/eggGroupDetail';
import { GenderDetail } from '../model/genderDetail';
import { GrowthRateDetail } from '../model/growthRateDetail';
import { MoveDamageClassDetail } from '../model/moveDamageClassDetail';
import { NatureDetail } from '../model/natureDetail';
import { PaginatedAbilitySummaryList } from '../model/paginatedAbilitySummaryList';
import { PaginatedCharacteristicSummaryList } from '../model/paginatedCharacteristicSummaryList';
import { PaginatedEggGroupSummaryList } from '../model/paginatedEggGroupSummaryList';
import { PaginatedGenderSummaryList } from '../model/paginatedGenderSummaryList';
import { PaginatedGrowthRateSummaryList } from '../model/paginatedGrowthRateSummaryList';
import { PaginatedMoveDamageClassSummaryList } from '../model/paginatedMoveDamageClassSummaryList';
import { PaginatedNatureSummaryList } from '../model/paginatedNatureSummaryList';
import { PaginatedPokeathlonStatSummaryList } from '../model/paginatedPokeathlonStatSummaryList';
import { PaginatedPokemonColorSummaryList } from '../model/paginatedPokemonColorSummaryList';
import { PaginatedPokemonFormSummaryList } from '../model/paginatedPokemonFormSummaryList';
import { PaginatedPokemonHabitatSummaryList } from '../model/paginatedPokemonHabitatSummaryList';
import { PaginatedPokemonShapeSummaryList } from '../model/paginatedPokemonShapeSummaryList';
import { PaginatedPokemonSpeciesSummaryList } from '../model/paginatedPokemonSpeciesSummaryList';
import { PaginatedPokemonSummaryList } from '../model/paginatedPokemonSummaryList';
import { PaginatedStatSummaryList } from '../model/paginatedStatSummaryList';
import { PaginatedTypeSummaryList } from '../model/paginatedTypeSummaryList';
import { PokeathlonStatDetail } from '../model/pokeathlonStatDetail';
import { PokemonColorDetail } from '../model/pokemonColorDetail';
import { PokemonDetail } from '../model/pokemonDetail';
import { PokemonFormDetail } from '../model/pokemonFormDetail';
import { PokemonHabitatDetail } from '../model/pokemonHabitatDetail';
import { PokemonShapeDetail } from '../model/pokemonShapeDetail';
import { PokemonSpeciesDetail } from '../model/pokemonSpeciesDetail';
import { StatDetail } from '../model/statDetail';
import { TypeDetail } from '../model/typeDetail';

import { COLLECTION_FORMATS }  from '../variables';



@injectable()
export class PokemonService {
    private basePath: string = 'https://pokeapi.co';

    constructor(@inject('IApiHttpClient') private httpClient: IHttpClient,
        @inject('IAPIConfiguration') private APIConfiguration: IAPIConfiguration ) {
        if(this.APIConfiguration.basePath)
            this.basePath = this.APIConfiguration.basePath;
    }

    /**
     * 
     * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public abilityList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedAbilitySummaryList>;
    public abilityList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedAbilitySummaryList>>;
    public abilityList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedAbilitySummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/ability/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedAbilitySummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * 
     * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
     * @param id This parameter can be a string or an integer.
     
     */
    public abilityRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<AbilityDetail>;
    public abilityRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<AbilityDetail>>;
    public abilityRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling abilityRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<AbilityDetail>> = this.httpClient.get(`${this.basePath}/api/v2/ability/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <AbilityDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List charecterictics
     * Characteristics indicate which stat contains a Pokémon\&#39;s highest IV. A Pokémon\&#39;s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public characteristicList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedCharacteristicSummaryList>;
    public characteristicList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedCharacteristicSummaryList>>;
    public characteristicList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedCharacteristicSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/characteristic/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedCharacteristicSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get characteristic
     * Characteristics indicate which stat contains a Pokémon\&#39;s highest IV. A Pokémon\&#39;s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
     * @param id This parameter can be a string or an integer.
     
     */
    public characteristicRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<CharacteristicDetail>;
    public characteristicRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<CharacteristicDetail>>;
    public characteristicRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling characteristicRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<CharacteristicDetail>> = this.httpClient.get(`${this.basePath}/api/v2/characteristic/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <CharacteristicDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List egg groups
     * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public eggGroupList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedEggGroupSummaryList>;
    public eggGroupList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedEggGroupSummaryList>>;
    public eggGroupList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedEggGroupSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/egg-group/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedEggGroupSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get egg group
     * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
     * @param id This parameter can be a string or an integer.
     
     */
    public eggGroupRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<EggGroupDetail>;
    public eggGroupRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<EggGroupDetail>>;
    public eggGroupRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling eggGroupRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<EggGroupDetail>> = this.httpClient.get(`${this.basePath}/api/v2/egg-group/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <EggGroupDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List genders
     * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public genderList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedGenderSummaryList>;
    public genderList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedGenderSummaryList>>;
    public genderList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedGenderSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/gender/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedGenderSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get gender
     * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
     * @param id This parameter can be a string or an integer.
     
     */
    public genderRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<GenderDetail>;
    public genderRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<GenderDetail>>;
    public genderRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling genderRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<GenderDetail>> = this.httpClient.get(`${this.basePath}/api/v2/gender/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <GenderDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List growth rates
     * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public growthRateList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedGrowthRateSummaryList>;
    public growthRateList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedGrowthRateSummaryList>>;
    public growthRateList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedGrowthRateSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/growth-rate/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedGrowthRateSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get growth rate
     * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
     * @param id This parameter can be a string or an integer.
     
     */
    public growthRateRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<GrowthRateDetail>;
    public growthRateRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<GrowthRateDetail>>;
    public growthRateRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling growthRateRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<GrowthRateDetail>> = this.httpClient.get(`${this.basePath}/api/v2/growth-rate/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <GrowthRateDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List move damage classes
     * Damage classes moves can have, e.g. physical, special, or non-damaging.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public moveDamageClassList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedMoveDamageClassSummaryList>;
    public moveDamageClassList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedMoveDamageClassSummaryList>>;
    public moveDamageClassList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedMoveDamageClassSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/move-damage-class/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedMoveDamageClassSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get move damage class
     * Damage classes moves can have, e.g. physical, special, or non-damaging.
     * @param id This parameter can be a string or an integer.
     
     */
    public moveDamageClassRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<MoveDamageClassDetail>;
    public moveDamageClassRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<MoveDamageClassDetail>>;
    public moveDamageClassRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling moveDamageClassRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<MoveDamageClassDetail>> = this.httpClient.get(`${this.basePath}/api/v2/move-damage-class/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <MoveDamageClassDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List natures
     * Natures influence how a Pokémon\&#39;s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public natureList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedNatureSummaryList>;
    public natureList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedNatureSummaryList>>;
    public natureList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedNatureSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/nature/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedNatureSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get nature
     * Natures influence how a Pokémon\&#39;s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
     * @param id This parameter can be a string or an integer.
     
     */
    public natureRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<NatureDetail>;
    public natureRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<NatureDetail>>;
    public natureRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling natureRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<NatureDetail>> = this.httpClient.get(`${this.basePath}/api/v2/nature/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <NatureDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List pokeathlon stats
     * Pokeathlon Stats are different attributes of a Pokémon\&#39;s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public pokeathlonStatList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedPokeathlonStatSummaryList>;
    public pokeathlonStatList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedPokeathlonStatSummaryList>>;
    public pokeathlonStatList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedPokeathlonStatSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/pokeathlon-stat/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedPokeathlonStatSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get pokeathlon stat
     * Pokeathlon Stats are different attributes of a Pokémon\&#39;s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
     * @param id This parameter can be a string or an integer.
     
     */
    public pokeathlonStatRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<PokeathlonStatDetail>;
    public pokeathlonStatRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PokeathlonStatDetail>>;
    public pokeathlonStatRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling pokeathlonStatRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PokeathlonStatDetail>> = this.httpClient.get(`${this.basePath}/api/v2/pokeathlon-stat/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PokeathlonStatDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List pokemon colors
     * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\&#39;s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public pokemonColorList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedPokemonColorSummaryList>;
    public pokemonColorList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedPokemonColorSummaryList>>;
    public pokemonColorList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedPokemonColorSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-color/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedPokemonColorSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get pokemon color
     * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\&#39;s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
     * @param id This parameter can be a string or an integer.
     
     */
    public pokemonColorRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<PokemonColorDetail>;
    public pokemonColorRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PokemonColorDetail>>;
    public pokemonColorRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling pokemonColorRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PokemonColorDetail>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-color/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PokemonColorDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List pokemon forms
     * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \&#39;Pokémon\&#39; entity is used to represent such a variety.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public pokemonFormList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedPokemonFormSummaryList>;
    public pokemonFormList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedPokemonFormSummaryList>>;
    public pokemonFormList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedPokemonFormSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-form/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedPokemonFormSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get pokemon form
     * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \&#39;Pokémon\&#39; entity is used to represent such a variety.
     * @param id This parameter can be a string or an integer.
     
     */
    public pokemonFormRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<PokemonFormDetail>;
    public pokemonFormRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PokemonFormDetail>>;
    public pokemonFormRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling pokemonFormRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PokemonFormDetail>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-form/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PokemonFormDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List pokemom habitas
     * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public pokemonHabitatList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedPokemonHabitatSummaryList>;
    public pokemonHabitatList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedPokemonHabitatSummaryList>>;
    public pokemonHabitatList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedPokemonHabitatSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-habitat/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedPokemonHabitatSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get pokemom habita
     * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
     * @param id This parameter can be a string or an integer.
     
     */
    public pokemonHabitatRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<PokemonHabitatDetail>;
    public pokemonHabitatRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PokemonHabitatDetail>>;
    public pokemonHabitatRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling pokemonHabitatRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PokemonHabitatDetail>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-habitat/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PokemonHabitatDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List pokemon
     * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public pokemonList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedPokemonSummaryList>;
    public pokemonList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedPokemonSummaryList>>;
    public pokemonList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedPokemonSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedPokemonSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get pokemon
     * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
     * @param id This parameter can be a string or an integer.
     
     */
    public pokemonRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<PokemonDetail>;
    public pokemonRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PokemonDetail>>;
    public pokemonRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling pokemonRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PokemonDetail>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PokemonDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List pokemon shapes
     * Shapes used for sorting Pokémon in a Pokédex.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public pokemonShapeList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedPokemonShapeSummaryList>;
    public pokemonShapeList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedPokemonShapeSummaryList>>;
    public pokemonShapeList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedPokemonShapeSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-shape/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedPokemonShapeSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get pokemon shape
     * Shapes used for sorting Pokémon in a Pokédex.
     * @param id This parameter can be a string or an integer.
     
     */
    public pokemonShapeRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<PokemonShapeDetail>;
    public pokemonShapeRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PokemonShapeDetail>>;
    public pokemonShapeRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling pokemonShapeRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PokemonShapeDetail>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-shape/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PokemonShapeDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List pokemon species
     * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public pokemonSpeciesList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedPokemonSpeciesSummaryList>;
    public pokemonSpeciesList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedPokemonSpeciesSummaryList>>;
    public pokemonSpeciesList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedPokemonSpeciesSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-species/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedPokemonSpeciesSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get pokemon species
     * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
     * @param id This parameter can be a string or an integer.
     
     */
    public pokemonSpeciesRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<PokemonSpeciesDetail>;
    public pokemonSpeciesRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PokemonSpeciesDetail>>;
    public pokemonSpeciesRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling pokemonSpeciesRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PokemonSpeciesDetail>> = this.httpClient.get(`${this.basePath}/api/v2/pokemon-species/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PokemonSpeciesDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List stats
     * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public statList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedStatSummaryList>;
    public statList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedStatSummaryList>>;
    public statList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedStatSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/stat/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedStatSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get stat
     * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
     * @param id This parameter can be a string or an integer.
     
     */
    public statRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<StatDetail>;
    public statRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<StatDetail>>;
    public statRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling statRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<StatDetail>> = this.httpClient.get(`${this.basePath}/api/v2/stat/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <StatDetail>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * List types
     * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
     * @param limit Number of results to return per page.
     * @param offset The initial index from which to return the results.
     * @param q &gt; Only available locally and not at [pokeapi.co](https://pokeapi.co/docs/v2) Case-insensitive query applied on the &#x60;name&#x60; property. 
     
     */
    public typeList(limit?: number, offset?: number, q?: string, observe?: 'body', headers?: Headers): Observable<PaginatedTypeSummaryList>;
    public typeList(limit?: number, offset?: number, q?: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<PaginatedTypeSummaryList>>;
    public typeList(limit?: number, offset?: number, q?: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        let queryParameters: string[] = [];
        if (limit !== undefined) {
            queryParameters.push('limit='+encodeURIComponent(String(limit)));
        }
        if (offset !== undefined) {
            queryParameters.push('offset='+encodeURIComponent(String(offset)));
        }
        if (q !== undefined) {
            queryParameters.push('q='+encodeURIComponent(String(q)));
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<PaginatedTypeSummaryList>> = this.httpClient.get(`${this.basePath}/api/v2/type/?${queryParameters.join('&')}`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <PaginatedTypeSummaryList>(httpResponse.response))
               );
        }
        return response;
    }


    /**
     * Get types
     * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
     * @param id This parameter can be a string or an integer.
     
     */
    public typeRetrieve(id: string, observe?: 'body', headers?: Headers): Observable<TypeDetail>;
    public typeRetrieve(id: string, observe?: 'response', headers?: Headers): Observable<HttpResponse<TypeDetail>>;
    public typeRetrieve(id: string, observe: any = 'body', headers: Headers = {}): Observable<any> {
        if (id === null || id === undefined){
            throw new Error('Required parameter id was null or undefined when calling typeRetrieve.');
        }

        // authentication (basicAuth) required
        if (this.APIConfiguration.username || this.APIConfiguration.password) {
            headers['Authorization'] = btoa(this.APIConfiguration.username + ':' + this.APIConfiguration.password);
        }
        // authentication (cookieAuth) required
        headers['Accept'] = 'application/json';

        const response: Observable<HttpResponse<TypeDetail>> = this.httpClient.get(`${this.basePath}/api/v2/type/${encodeURIComponent(String(id))}/`, headers);
        if (observe === 'body') {
               return response.pipe(
                   map((httpResponse: HttpResponse) => <TypeDetail>(httpResponse.response))
               );
        }
        return response;
    }

}
