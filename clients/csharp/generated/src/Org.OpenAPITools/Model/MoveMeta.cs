// <auto-generated>
/*
 * PokéAPI
 *
 * All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Org.OpenAPITools.Client;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// MoveMeta
    /// </summary>
    public partial class MoveMeta : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="MoveMeta" /> class.
        /// </summary>
        /// <param name="ailment">ailment</param>
        /// <param name="category">category</param>
        /// <param name="minHits">minHits</param>
        /// <param name="maxHits">maxHits</param>
        /// <param name="minTurns">minTurns</param>
        /// <param name="maxTurns">maxTurns</param>
        /// <param name="drain">drain</param>
        /// <param name="healing">healing</param>
        /// <param name="critRate">critRate</param>
        /// <param name="ailmentChance">ailmentChance</param>
        /// <param name="flinchChance">flinchChance</param>
        /// <param name="statChance">statChance</param>
        [JsonConstructor]
        public MoveMeta(MoveMetaAilmentSummary ailment, MoveMetaCategorySummary category, Option<int?> minHits = default, Option<int?> maxHits = default, Option<int?> minTurns = default, Option<int?> maxTurns = default, Option<int?> drain = default, Option<int?> healing = default, Option<int?> critRate = default, Option<int?> ailmentChance = default, Option<int?> flinchChance = default, Option<int?> statChance = default)
        {
            Ailment = ailment;
            Category = category;
            MinHitsOption = minHits;
            MaxHitsOption = maxHits;
            MinTurnsOption = minTurns;
            MaxTurnsOption = maxTurns;
            DrainOption = drain;
            HealingOption = healing;
            CritRateOption = critRate;
            AilmentChanceOption = ailmentChance;
            FlinchChanceOption = flinchChance;
            StatChanceOption = statChance;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Gets or Sets Ailment
        /// </summary>
        [JsonPropertyName("ailment")]
        public MoveMetaAilmentSummary Ailment { get; set; }

        /// <summary>
        /// Gets or Sets Category
        /// </summary>
        [JsonPropertyName("category")]
        public MoveMetaCategorySummary Category { get; set; }

        /// <summary>
        /// Used to track the state of MinHits
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> MinHitsOption { get; private set; }

        /// <summary>
        /// Gets or Sets MinHits
        /// </summary>
        [JsonPropertyName("min_hits")]
        public int? MinHits { get { return this.MinHitsOption; } set { this.MinHitsOption = new(value); } }

        /// <summary>
        /// Used to track the state of MaxHits
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> MaxHitsOption { get; private set; }

        /// <summary>
        /// Gets or Sets MaxHits
        /// </summary>
        [JsonPropertyName("max_hits")]
        public int? MaxHits { get { return this.MaxHitsOption; } set { this.MaxHitsOption = new(value); } }

        /// <summary>
        /// Used to track the state of MinTurns
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> MinTurnsOption { get; private set; }

        /// <summary>
        /// Gets or Sets MinTurns
        /// </summary>
        [JsonPropertyName("min_turns")]
        public int? MinTurns { get { return this.MinTurnsOption; } set { this.MinTurnsOption = new(value); } }

        /// <summary>
        /// Used to track the state of MaxTurns
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> MaxTurnsOption { get; private set; }

        /// <summary>
        /// Gets or Sets MaxTurns
        /// </summary>
        [JsonPropertyName("max_turns")]
        public int? MaxTurns { get { return this.MaxTurnsOption; } set { this.MaxTurnsOption = new(value); } }

        /// <summary>
        /// Used to track the state of Drain
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> DrainOption { get; private set; }

        /// <summary>
        /// Gets or Sets Drain
        /// </summary>
        [JsonPropertyName("drain")]
        public int? Drain { get { return this.DrainOption; } set { this.DrainOption = new(value); } }

        /// <summary>
        /// Used to track the state of Healing
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> HealingOption { get; private set; }

        /// <summary>
        /// Gets or Sets Healing
        /// </summary>
        [JsonPropertyName("healing")]
        public int? Healing { get { return this.HealingOption; } set { this.HealingOption = new(value); } }

        /// <summary>
        /// Used to track the state of CritRate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> CritRateOption { get; private set; }

        /// <summary>
        /// Gets or Sets CritRate
        /// </summary>
        [JsonPropertyName("crit_rate")]
        public int? CritRate { get { return this.CritRateOption; } set { this.CritRateOption = new(value); } }

        /// <summary>
        /// Used to track the state of AilmentChance
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> AilmentChanceOption { get; private set; }

        /// <summary>
        /// Gets or Sets AilmentChance
        /// </summary>
        [JsonPropertyName("ailment_chance")]
        public int? AilmentChance { get { return this.AilmentChanceOption; } set { this.AilmentChanceOption = new(value); } }

        /// <summary>
        /// Used to track the state of FlinchChance
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> FlinchChanceOption { get; private set; }

        /// <summary>
        /// Gets or Sets FlinchChance
        /// </summary>
        [JsonPropertyName("flinch_chance")]
        public int? FlinchChance { get { return this.FlinchChanceOption; } set { this.FlinchChanceOption = new(value); } }

        /// <summary>
        /// Used to track the state of StatChance
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> StatChanceOption { get; private set; }

        /// <summary>
        /// Gets or Sets StatChance
        /// </summary>
        [JsonPropertyName("stat_chance")]
        public int? StatChance { get { return this.StatChanceOption; } set { this.StatChanceOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class MoveMeta {\n");
            sb.Append("  Ailment: ").Append(Ailment).Append("\n");
            sb.Append("  Category: ").Append(Category).Append("\n");
            sb.Append("  MinHits: ").Append(MinHits).Append("\n");
            sb.Append("  MaxHits: ").Append(MaxHits).Append("\n");
            sb.Append("  MinTurns: ").Append(MinTurns).Append("\n");
            sb.Append("  MaxTurns: ").Append(MaxTurns).Append("\n");
            sb.Append("  Drain: ").Append(Drain).Append("\n");
            sb.Append("  Healing: ").Append(Healing).Append("\n");
            sb.Append("  CritRate: ").Append(CritRate).Append("\n");
            sb.Append("  AilmentChance: ").Append(AilmentChance).Append("\n");
            sb.Append("  FlinchChance: ").Append(FlinchChance).Append("\n");
            sb.Append("  StatChance: ").Append(StatChance).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="MoveMeta" />
    /// </summary>
    public class MoveMetaJsonConverter : JsonConverter<MoveMeta>
    {
        /// <summary>
        /// Deserializes json to <see cref="MoveMeta" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override MoveMeta Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<MoveMetaAilmentSummary?> ailment = default;
            Option<MoveMetaCategorySummary?> category = default;
            Option<int?> minHits = default;
            Option<int?> maxHits = default;
            Option<int?> minTurns = default;
            Option<int?> maxTurns = default;
            Option<int?> drain = default;
            Option<int?> healing = default;
            Option<int?> critRate = default;
            Option<int?> ailmentChance = default;
            Option<int?> flinchChance = default;
            Option<int?> statChance = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "ailment":
                            ailment = new Option<MoveMetaAilmentSummary?>(JsonSerializer.Deserialize<MoveMetaAilmentSummary>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "category":
                            category = new Option<MoveMetaCategorySummary?>(JsonSerializer.Deserialize<MoveMetaCategorySummary>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "min_hits":
                            minHits = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "max_hits":
                            maxHits = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "min_turns":
                            minTurns = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "max_turns":
                            maxTurns = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "drain":
                            drain = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "healing":
                            healing = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "crit_rate":
                            critRate = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "ailment_chance":
                            ailmentChance = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "flinch_chance":
                            flinchChance = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "stat_chance":
                            statChance = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        default:
                            break;
                    }
                }
            }

            if (!ailment.IsSet)
                throw new ArgumentException("Property is required for class MoveMeta.", nameof(ailment));

            if (!category.IsSet)
                throw new ArgumentException("Property is required for class MoveMeta.", nameof(category));

            if (ailment.IsSet && ailment.Value == null)
                throw new ArgumentNullException(nameof(ailment), "Property is not nullable for class MoveMeta.");

            if (category.IsSet && category.Value == null)
                throw new ArgumentNullException(nameof(category), "Property is not nullable for class MoveMeta.");

            return new MoveMeta(ailment.Value!, category.Value!, minHits, maxHits, minTurns, maxTurns, drain, healing, critRate, ailmentChance, flinchChance, statChance);
        }

        /// <summary>
        /// Serializes a <see cref="MoveMeta" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="moveMeta"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, MoveMeta moveMeta, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, moveMeta, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="MoveMeta" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="moveMeta"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, MoveMeta moveMeta, JsonSerializerOptions jsonSerializerOptions)
        {
            if (moveMeta.Ailment == null)
                throw new ArgumentNullException(nameof(moveMeta.Ailment), "Property is required for class MoveMeta.");

            if (moveMeta.Category == null)
                throw new ArgumentNullException(nameof(moveMeta.Category), "Property is required for class MoveMeta.");

            writer.WritePropertyName("ailment");
            JsonSerializer.Serialize(writer, moveMeta.Ailment, jsonSerializerOptions);
            writer.WritePropertyName("category");
            JsonSerializer.Serialize(writer, moveMeta.Category, jsonSerializerOptions);
            if (moveMeta.MinHitsOption.IsSet)
                if (moveMeta.MinHitsOption.Value != null)
                    writer.WriteNumber("min_hits", moveMeta.MinHitsOption.Value!.Value);
                else
                    writer.WriteNull("min_hits");

            if (moveMeta.MaxHitsOption.IsSet)
                if (moveMeta.MaxHitsOption.Value != null)
                    writer.WriteNumber("max_hits", moveMeta.MaxHitsOption.Value!.Value);
                else
                    writer.WriteNull("max_hits");

            if (moveMeta.MinTurnsOption.IsSet)
                if (moveMeta.MinTurnsOption.Value != null)
                    writer.WriteNumber("min_turns", moveMeta.MinTurnsOption.Value!.Value);
                else
                    writer.WriteNull("min_turns");

            if (moveMeta.MaxTurnsOption.IsSet)
                if (moveMeta.MaxTurnsOption.Value != null)
                    writer.WriteNumber("max_turns", moveMeta.MaxTurnsOption.Value!.Value);
                else
                    writer.WriteNull("max_turns");

            if (moveMeta.DrainOption.IsSet)
                if (moveMeta.DrainOption.Value != null)
                    writer.WriteNumber("drain", moveMeta.DrainOption.Value!.Value);
                else
                    writer.WriteNull("drain");

            if (moveMeta.HealingOption.IsSet)
                if (moveMeta.HealingOption.Value != null)
                    writer.WriteNumber("healing", moveMeta.HealingOption.Value!.Value);
                else
                    writer.WriteNull("healing");

            if (moveMeta.CritRateOption.IsSet)
                if (moveMeta.CritRateOption.Value != null)
                    writer.WriteNumber("crit_rate", moveMeta.CritRateOption.Value!.Value);
                else
                    writer.WriteNull("crit_rate");

            if (moveMeta.AilmentChanceOption.IsSet)
                if (moveMeta.AilmentChanceOption.Value != null)
                    writer.WriteNumber("ailment_chance", moveMeta.AilmentChanceOption.Value!.Value);
                else
                    writer.WriteNull("ailment_chance");

            if (moveMeta.FlinchChanceOption.IsSet)
                if (moveMeta.FlinchChanceOption.Value != null)
                    writer.WriteNumber("flinch_chance", moveMeta.FlinchChanceOption.Value!.Value);
                else
                    writer.WriteNull("flinch_chance");

            if (moveMeta.StatChanceOption.IsSet)
                if (moveMeta.StatChanceOption.Value != null)
                    writer.WriteNumber("stat_chance", moveMeta.StatChanceOption.Value!.Value);
                else
                    writer.WriteNull("stat_chance");
        }
    }
}
