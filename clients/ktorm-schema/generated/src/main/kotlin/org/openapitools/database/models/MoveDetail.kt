/**
* PokéAPI
* All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
*
* The version of the OpenAPI document: 2.7.0
* Contact: blah+oapicf@cliffano.com
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/
package org.openapitools.database.models

import org.ktorm.dsl.*
import org.ktorm.schema.*
import org.ktorm.database.Database
import .*


/**
 * 
 * @param id 
 * @param name 
 * @param effectChance 
 * @param contestCombos 
 * @param contestType 
 * @param contestEffect 
 * @param damageClass 
 * @param effectEntries 
 * @param effectChanges 
 * @param generation 
 * @param meta 
 * @param names 
 * @param pastValues 
 * @param statChanges 
 * @param superContestEffect 
 * @param target 
 * @param type 
 * @param machines 
 * @param flavorTextEntries 
 * @param learnedByPokemon 
 * @param accuracy 
 * @param pp 
 * @param priority 
 * @param power 
 */
object MoveDetails : BaseTable<MoveDetail>("MoveDetail") {
    val id = int("id")
    val name = text("name")
    val effectChance = int("effect_chance")
    val contestCombos = long("contest_combos")
    val contestType = long("contest_type")
    val contestEffect = long("contest_effect")
    val damageClass = long("damage_class")
    val generation = long("generation")
    val meta = long("meta")
    val superContestEffect = long("super_contest_effect")
    val target = long("target")
    val type = long("type")
    val accuracy = int("accuracy") /* null */
    val pp = int("pp") /* null */
    val priority = int("priority") /* null */
    val power = int("power") /* null */

    /**
     * Create an entity of type MoveDetail from the model
     */
    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean) = MoveDetail(
        id = row[id] ?: 0 /* kotlin.Int */,
        name = row[name] ?: "" /* kotlin.String */,
        effectChance = row[effectChance] ?: 0 /* kotlin.Int */,
        contestCombos = MoveDetailContestComboss.createEntity(row, withReferences) /* MoveDetailContestCombos */,
        contestType = ContestTypeSummarys.createEntity(row, withReferences) /* ContestTypeSummary */,
        contestEffect = ContestEffectSummarys.createEntity(row, withReferences) /* ContestEffectSummary */,
        damageClass = MoveDamageClassSummarys.createEntity(row, withReferences) /* MoveDamageClassSummary */,
        effectEntries = emptyList() /* kotlin.Array<MoveChangeEffectEntriesInner> */,
        effectChanges = emptyList() /* kotlin.Array<MoveDetailEffectChangesInner> */,
        generation = GenerationSummarys.createEntity(row, withReferences) /* GenerationSummary */,
        meta = MoveMetas.createEntity(row, withReferences) /* MoveMeta */,
        names = emptyList() /* kotlin.Array<MoveName> */,
        pastValues = emptyList() /* kotlin.Array<MoveChange> */,
        statChanges = emptyList() /* kotlin.Array<MoveDetailStatChangesInner> */,
        superContestEffect = SuperContestEffectSummarys.createEntity(row, withReferences) /* SuperContestEffectSummary */,
        target = MoveTargetSummarys.createEntity(row, withReferences) /* MoveTargetSummary */,
        type = TypeSummarys.createEntity(row, withReferences) /* TypeSummary */,
        machines = emptyList() /* kotlin.Array<MoveDetailMachinesInner> */,
        flavorTextEntries = emptyList() /* kotlin.Array<MoveFlavorText> */,
        learnedByPokemon = emptyList() /* kotlin.Array<AbilityDetailPokemonInnerPokemon> */,
        accuracy = row[accuracy]  /* kotlin.Int? */,
        pp = row[pp]  /* kotlin.Int? */,
        priority = row[priority]  /* kotlin.Int? */,
        power = row[power]  /* kotlin.Int? */
    )

    /**
    * Assign all the columns from the entity of type MoveDetail to the DML expression.
    *
    * Usage:
    *
    * ```kotlin
    * let entity = MoveDetail()
    * database.update(MoveDetails, {
    *     assignFrom(entity)
    * })
    * ```
    * @return the builder with the columns for the update or insert.
    */
    fun AssignmentsBuilder.assignFrom(entity: MoveDetail) {
        this.apply {
            set(MoveDetails.id, entity.id)
            set(MoveDetails.name, entity.name)
            set(MoveDetails.effectChance, entity.effectChance)
            set(MoveDetails.contestCombos, entity.contestCombos)
            set(MoveDetails.contestType, entity.contestType)
            set(MoveDetails.contestEffect, entity.contestEffect)
            set(MoveDetails.damageClass, entity.damageClass)
            set(MoveDetails.generation, entity.generation)
            set(MoveDetails.meta, entity.meta)
            set(MoveDetails.superContestEffect, entity.superContestEffect)
            set(MoveDetails.target, entity.target)
            set(MoveDetails.type, entity.type)
            set(MoveDetails.accuracy, entity.accuracy)
            set(MoveDetails.pp, entity.pp)
            set(MoveDetails.priority, entity.priority)
            set(MoveDetails.power, entity.power)
        }
    }

}


object MoveDetailMoveChangeEffectEntriesInner : BaseTable<Pair<kotlin.Long, kotlin.Long>>("MoveDetailMoveChangeEffectEntriesInner") {
    val moveDetail = long("moveDetail")
    val moveChangeEffectEntriesInner = long("moveChangeEffectEntriesInner")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[moveDetail] ?: 0, row[moveChangeEffectEntriesInner] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(MoveDetailMoveChangeEffectEntriesInner.moveDetail, entity.first)
            set(MoveDetailMoveChangeEffectEntriesInner.moveChangeEffectEntriesInner, entity.second)
        }
    }

}

object MoveDetailMoveDetailEffectChangesInner : BaseTable<Pair<kotlin.Long, kotlin.Long>>("MoveDetailMoveDetailEffectChangesInner") {
    val moveDetail = long("moveDetail")
    val moveDetailEffectChangesInner = long("moveDetailEffectChangesInner")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[moveDetail] ?: 0, row[moveDetailEffectChangesInner] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(MoveDetailMoveDetailEffectChangesInner.moveDetail, entity.first)
            set(MoveDetailMoveDetailEffectChangesInner.moveDetailEffectChangesInner, entity.second)
        }
    }

}

object MoveDetailMoveName : BaseTable<Pair<kotlin.Long, kotlin.Long>>("MoveDetailMoveName") {
    val moveDetail = long("moveDetail")
    val moveName = long("moveName")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[moveDetail] ?: 0, row[moveName] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(MoveDetailMoveName.moveDetail, entity.first)
            set(MoveDetailMoveName.moveName, entity.second)
        }
    }

}

object MoveDetailMoveChange : BaseTable<Pair<kotlin.Long, kotlin.Long>>("MoveDetailMoveChange") {
    val moveDetail = long("moveDetail")
    val moveChange = long("moveChange")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[moveDetail] ?: 0, row[moveChange] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(MoveDetailMoveChange.moveDetail, entity.first)
            set(MoveDetailMoveChange.moveChange, entity.second)
        }
    }

}

object MoveDetailMoveDetailStatChangesInner : BaseTable<Pair<kotlin.Long, kotlin.Long>>("MoveDetailMoveDetailStatChangesInner") {
    val moveDetail = long("moveDetail")
    val moveDetailStatChangesInner = long("moveDetailStatChangesInner")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[moveDetail] ?: 0, row[moveDetailStatChangesInner] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(MoveDetailMoveDetailStatChangesInner.moveDetail, entity.first)
            set(MoveDetailMoveDetailStatChangesInner.moveDetailStatChangesInner, entity.second)
        }
    }

}

object MoveDetailMoveDetailMachinesInner : BaseTable<Pair<kotlin.Long, kotlin.Long>>("MoveDetailMoveDetailMachinesInner") {
    val moveDetail = long("moveDetail")
    val moveDetailMachinesInner = long("moveDetailMachinesInner")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[moveDetail] ?: 0, row[moveDetailMachinesInner] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(MoveDetailMoveDetailMachinesInner.moveDetail, entity.first)
            set(MoveDetailMoveDetailMachinesInner.moveDetailMachinesInner, entity.second)
        }
    }

}

object MoveDetailMoveFlavorText : BaseTable<Pair<kotlin.Long, kotlin.Long>>("MoveDetailMoveFlavorText") {
    val moveDetail = long("moveDetail")
    val moveFlavorText = long("moveFlavorText")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[moveDetail] ?: 0, row[moveFlavorText] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(MoveDetailMoveFlavorText.moveDetail, entity.first)
            set(MoveDetailMoveFlavorText.moveFlavorText, entity.second)
        }
    }

}

object MoveDetailAbilityDetailPokemonInnerPokemon : BaseTable<Pair<kotlin.Long, kotlin.Long>>("MoveDetailAbilityDetailPokemonInnerPokemon") {
    val moveDetail = long("moveDetail")
    val abilityDetailPokemonInnerPokemon = long("abilityDetailPokemonInnerPokemon")

    override fun doCreateEntity(row: QueryRowSet, withReferences: Boolean): Pair<kotlin.Long, kotlin.Long> =
        Pair(row[moveDetail] ?: 0, row[abilityDetailPokemonInnerPokemon] ?: 0)

    fun AssignmentsBuilder.assignFrom(entity: Pair<kotlin.Long, kotlin.Long>) {
        this.apply {
            set(MoveDetailAbilityDetailPokemonInnerPokemon.moveDetail, entity.first)
            set(MoveDetailAbilityDetailPokemonInnerPokemon.abilityDetailPokemonInnerPokemon, entity.second)
        }
    }

}

