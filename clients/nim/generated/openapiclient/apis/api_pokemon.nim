#
# PokéAPI
# 
# All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
# The version of the OpenAPI document: 2.7.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_ability_detail
import ../models/model_characteristic_detail
import ../models/model_egg_group_detail
import ../models/model_gender_detail
import ../models/model_growth_rate_detail
import ../models/model_move_damage_class_detail
import ../models/model_nature_detail
import ../models/model_paginated_ability_summary_list
import ../models/model_paginated_characteristic_summary_list
import ../models/model_paginated_egg_group_summary_list
import ../models/model_paginated_gender_summary_list
import ../models/model_paginated_growth_rate_summary_list
import ../models/model_paginated_move_damage_class_summary_list
import ../models/model_paginated_nature_summary_list
import ../models/model_paginated_pokeathlon_stat_summary_list
import ../models/model_paginated_pokemon_color_summary_list
import ../models/model_paginated_pokemon_form_summary_list
import ../models/model_paginated_pokemon_habitat_summary_list
import ../models/model_paginated_pokemon_shape_summary_list
import ../models/model_paginated_pokemon_species_summary_list
import ../models/model_paginated_pokemon_summary_list
import ../models/model_paginated_stat_summary_list
import ../models/model_paginated_type_summary_list
import ../models/model_pokeathlon_stat_detail
import ../models/model_pokemon_color_detail
import ../models/model_pokemon_detail
import ../models/model_pokemon_form_detail
import ../models/model_pokemon_habitat_detail
import ../models/model_pokemon_shape_detail
import ../models/model_pokemon_species_detail
import ../models/model_stat_detail
import ../models/model_type_detail

const basepath = "https://pokeapi.co"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      (some(to(parseJson(response.body), T)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc abilityList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedAbilitySummaryList], Response) =
  ## 
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/ability/" & "?" & url_encoded_query_params)
  constructResult[PaginatedAbilitySummaryList](response)


proc abilityRetrieve*(httpClient: HttpClient, id: string): (Option[AbilityDetail], Response) =
  ## 

  let response = httpClient.get(basepath & fmt"/api/v2/ability/{id}/")
  constructResult[AbilityDetail](response)


proc characteristicList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedCharacteristicSummaryList], Response) =
  ## List charecterictics
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/characteristic/" & "?" & url_encoded_query_params)
  constructResult[PaginatedCharacteristicSummaryList](response)


proc characteristicRetrieve*(httpClient: HttpClient, id: string): (Option[CharacteristicDetail], Response) =
  ## Get characteristic

  let response = httpClient.get(basepath & fmt"/api/v2/characteristic/{id}/")
  constructResult[CharacteristicDetail](response)


proc eggGroupList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedEggGroupSummaryList], Response) =
  ## List egg groups
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/egg-group/" & "?" & url_encoded_query_params)
  constructResult[PaginatedEggGroupSummaryList](response)


proc eggGroupRetrieve*(httpClient: HttpClient, id: string): (Option[EggGroupDetail], Response) =
  ## Get egg group

  let response = httpClient.get(basepath & fmt"/api/v2/egg-group/{id}/")
  constructResult[EggGroupDetail](response)


proc genderList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedGenderSummaryList], Response) =
  ## List genders
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/gender/" & "?" & url_encoded_query_params)
  constructResult[PaginatedGenderSummaryList](response)


proc genderRetrieve*(httpClient: HttpClient, id: string): (Option[GenderDetail], Response) =
  ## Get gender

  let response = httpClient.get(basepath & fmt"/api/v2/gender/{id}/")
  constructResult[GenderDetail](response)


proc growthRateList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedGrowthRateSummaryList], Response) =
  ## List growth rates
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/growth-rate/" & "?" & url_encoded_query_params)
  constructResult[PaginatedGrowthRateSummaryList](response)


proc growthRateRetrieve*(httpClient: HttpClient, id: string): (Option[GrowthRateDetail], Response) =
  ## Get growth rate

  let response = httpClient.get(basepath & fmt"/api/v2/growth-rate/{id}/")
  constructResult[GrowthRateDetail](response)


proc moveDamageClassList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedMoveDamageClassSummaryList], Response) =
  ## List move damage classes
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/move-damage-class/" & "?" & url_encoded_query_params)
  constructResult[PaginatedMoveDamageClassSummaryList](response)


proc moveDamageClassRetrieve*(httpClient: HttpClient, id: string): (Option[MoveDamageClassDetail], Response) =
  ## Get move damage class

  let response = httpClient.get(basepath & fmt"/api/v2/move-damage-class/{id}/")
  constructResult[MoveDamageClassDetail](response)


proc natureList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedNatureSummaryList], Response) =
  ## List natures
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/nature/" & "?" & url_encoded_query_params)
  constructResult[PaginatedNatureSummaryList](response)


proc natureRetrieve*(httpClient: HttpClient, id: string): (Option[NatureDetail], Response) =
  ## Get nature

  let response = httpClient.get(basepath & fmt"/api/v2/nature/{id}/")
  constructResult[NatureDetail](response)


proc pokeathlonStatList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedPokeathlonStatSummaryList], Response) =
  ## List pokeathlon stats
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/pokeathlon-stat/" & "?" & url_encoded_query_params)
  constructResult[PaginatedPokeathlonStatSummaryList](response)


proc pokeathlonStatRetrieve*(httpClient: HttpClient, id: string): (Option[PokeathlonStatDetail], Response) =
  ## Get pokeathlon stat

  let response = httpClient.get(basepath & fmt"/api/v2/pokeathlon-stat/{id}/")
  constructResult[PokeathlonStatDetail](response)


proc pokemonColorList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedPokemonColorSummaryList], Response) =
  ## List pokemon colors
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/pokemon-color/" & "?" & url_encoded_query_params)
  constructResult[PaginatedPokemonColorSummaryList](response)


proc pokemonColorRetrieve*(httpClient: HttpClient, id: string): (Option[PokemonColorDetail], Response) =
  ## Get pokemon color

  let response = httpClient.get(basepath & fmt"/api/v2/pokemon-color/{id}/")
  constructResult[PokemonColorDetail](response)


proc pokemonFormList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedPokemonFormSummaryList], Response) =
  ## List pokemon forms
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/pokemon-form/" & "?" & url_encoded_query_params)
  constructResult[PaginatedPokemonFormSummaryList](response)


proc pokemonFormRetrieve*(httpClient: HttpClient, id: string): (Option[PokemonFormDetail], Response) =
  ## Get pokemon form

  let response = httpClient.get(basepath & fmt"/api/v2/pokemon-form/{id}/")
  constructResult[PokemonFormDetail](response)


proc pokemonHabitatList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedPokemonHabitatSummaryList], Response) =
  ## List pokemom habitas
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/pokemon-habitat/" & "?" & url_encoded_query_params)
  constructResult[PaginatedPokemonHabitatSummaryList](response)


proc pokemonHabitatRetrieve*(httpClient: HttpClient, id: string): (Option[PokemonHabitatDetail], Response) =
  ## Get pokemom habita

  let response = httpClient.get(basepath & fmt"/api/v2/pokemon-habitat/{id}/")
  constructResult[PokemonHabitatDetail](response)


proc pokemonList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedPokemonSummaryList], Response) =
  ## List pokemon
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/pokemon/" & "?" & url_encoded_query_params)
  constructResult[PaginatedPokemonSummaryList](response)


proc pokemonRetrieve*(httpClient: HttpClient, id: string): (Option[PokemonDetail], Response) =
  ## Get pokemon

  let response = httpClient.get(basepath & fmt"/api/v2/pokemon/{id}/")
  constructResult[PokemonDetail](response)


proc pokemonShapeList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedPokemonShapeSummaryList], Response) =
  ## List pokemon shapes
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/pokemon-shape/" & "?" & url_encoded_query_params)
  constructResult[PaginatedPokemonShapeSummaryList](response)


proc pokemonShapeRetrieve*(httpClient: HttpClient, id: string): (Option[PokemonShapeDetail], Response) =
  ## Get pokemon shape

  let response = httpClient.get(basepath & fmt"/api/v2/pokemon-shape/{id}/")
  constructResult[PokemonShapeDetail](response)


proc pokemonSpeciesList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedPokemonSpeciesSummaryList], Response) =
  ## List pokemon species
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/pokemon-species/" & "?" & url_encoded_query_params)
  constructResult[PaginatedPokemonSpeciesSummaryList](response)


proc pokemonSpeciesRetrieve*(httpClient: HttpClient, id: string): (Option[PokemonSpeciesDetail], Response) =
  ## Get pokemon species

  let response = httpClient.get(basepath & fmt"/api/v2/pokemon-species/{id}/")
  constructResult[PokemonSpeciesDetail](response)


proc statList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedStatSummaryList], Response) =
  ## List stats
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/stat/" & "?" & url_encoded_query_params)
  constructResult[PaginatedStatSummaryList](response)


proc statRetrieve*(httpClient: HttpClient, id: string): (Option[StatDetail], Response) =
  ## Get stat

  let response = httpClient.get(basepath & fmt"/api/v2/stat/{id}/")
  constructResult[StatDetail](response)


proc typeList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedTypeSummaryList], Response) =
  ## List types
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/type/" & "?" & url_encoded_query_params)
  constructResult[PaginatedTypeSummaryList](response)


proc typeRetrieve*(httpClient: HttpClient, id: string): (Option[TypeDetail], Response) =
  ## Get types

  let response = httpClient.get(basepath & fmt"/api/v2/type/{id}/")
  constructResult[TypeDetail](response)

