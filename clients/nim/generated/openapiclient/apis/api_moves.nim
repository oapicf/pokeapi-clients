#
# PokéAPI
# 
# All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
# The version of the OpenAPI document: 2.7.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import httpclient
import json
import logging
import marshal
import options
import strformat
import strutils
import tables
import typetraits
import uri

import ../models/model_move_battle_style_detail
import ../models/model_move_detail
import ../models/model_move_learn_method_detail
import ../models/model_move_meta_ailment_detail
import ../models/model_move_meta_category_detail
import ../models/model_move_target_detail
import ../models/model_paginated_move_battle_style_summary_list
import ../models/model_paginated_move_learn_method_summary_list
import ../models/model_paginated_move_meta_ailment_summary_list
import ../models/model_paginated_move_meta_category_summary_list
import ../models/model_paginated_move_summary_list
import ../models/model_paginated_move_target_summary_list

const basepath = "https://pokeapi.co"

template constructResult[T](response: Response): untyped =
  if response.code in {Http200, Http201, Http202, Http204, Http206}:
    try:
      (some(to(parseJson(response.body), T)), response)
    except JsonParsingError:
      # The server returned a malformed response though the response code is 2XX
      # TODO: need better error handling
      error("JsonParsingError")
      (none(T.typedesc), response)
  else:
    (none(T.typedesc), response)


proc moveAilmentList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedMoveMetaAilmentSummaryList], Response) =
  ## List move meta ailments
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/move-ailment/" & "?" & url_encoded_query_params)
  constructResult[PaginatedMoveMetaAilmentSummaryList](response)


proc moveAilmentRetrieve*(httpClient: HttpClient, id: string): (Option[MoveMetaAilmentDetail], Response) =
  ## Get move meta ailment

  let response = httpClient.get(basepath & fmt"/api/v2/move-ailment/{id}/")
  constructResult[MoveMetaAilmentDetail](response)


proc moveBattleStyleList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedMoveBattleStyleSummaryList], Response) =
  ## List move battle styles
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/move-battle-style/" & "?" & url_encoded_query_params)
  constructResult[PaginatedMoveBattleStyleSummaryList](response)


proc moveBattleStyleRetrieve*(httpClient: HttpClient, id: string): (Option[MoveBattleStyleDetail], Response) =
  ## Get move battle style

  let response = httpClient.get(basepath & fmt"/api/v2/move-battle-style/{id}/")
  constructResult[MoveBattleStyleDetail](response)


proc moveCategoryList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedMoveMetaCategorySummaryList], Response) =
  ## List move meta categories
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/move-category/" & "?" & url_encoded_query_params)
  constructResult[PaginatedMoveMetaCategorySummaryList](response)


proc moveCategoryRetrieve*(httpClient: HttpClient, id: string): (Option[MoveMetaCategoryDetail], Response) =
  ## Get move meta category

  let response = httpClient.get(basepath & fmt"/api/v2/move-category/{id}/")
  constructResult[MoveMetaCategoryDetail](response)


proc moveLearnMethodList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedMoveLearnMethodSummaryList], Response) =
  ## List move learn methods
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/move-learn-method/" & "?" & url_encoded_query_params)
  constructResult[PaginatedMoveLearnMethodSummaryList](response)


proc moveLearnMethodRetrieve*(httpClient: HttpClient, id: string): (Option[MoveLearnMethodDetail], Response) =
  ## Get move learn method

  let response = httpClient.get(basepath & fmt"/api/v2/move-learn-method/{id}/")
  constructResult[MoveLearnMethodDetail](response)


proc moveList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedMoveSummaryList], Response) =
  ## List moves
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/move/" & "?" & url_encoded_query_params)
  constructResult[PaginatedMoveSummaryList](response)


proc moveRetrieve*(httpClient: HttpClient, id: string): (Option[MoveDetail], Response) =
  ## Get move

  let response = httpClient.get(basepath & fmt"/api/v2/move/{id}/")
  constructResult[MoveDetail](response)


proc moveTargetList*(httpClient: HttpClient, limit: int, offset: int, q: string): (Option[PaginatedMoveTargetSummaryList], Response) =
  ## List move targets
  var query_params_list: seq[(string, string)] = @[]
  if $limit != "":
    query_params_list.add(("limit", $limit))
  if $offset != "":
    query_params_list.add(("offset", $offset))
  if $q != "":
    query_params_list.add(("q", $q))
  let url_encoded_query_params = encodeQuery(query_params_list)

  let response = httpClient.get(basepath & "/api/v2/move-target/" & "?" & url_encoded_query_params)
  constructResult[PaginatedMoveTargetSummaryList](response)


proc moveTargetRetrieve*(httpClient: HttpClient, id: string): (Option[MoveTargetDetail], Response) =
  ## Get move target

  let response = httpClient.get(basepath & fmt"/api/v2/move-target/{id}/")
  constructResult[MoveTargetDetail](response)

