#
# PokéAPI
# 
# All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
# The version of the OpenAPI document: 2.7.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import json
import tables
import marshal
import options

import model_ability_detail_pokemon_inner_pokemon
import model_item_category_summary
import model_item_detail_baby_trigger_for
import model_item_detail_held_by_pokemon_inner
import model_item_detail_machines_inner
import model_item_detail_sprites
import model_item_effect_text
import model_item_flavor_text
import model_item_fling_effect_summary
import model_item_game_index
import model_item_name

type ItemDetail* = object
  ## 
  id*: int
  name*: string
  cost*: Option[int]
  flingPower*: Option[int]
  flingEffect*: ItemFlingEffectSummary
  attributes*: seq[AbilityDetail_pokemon_inner_pokemon]
  category*: ItemCategorySummary
  effectEntries*: seq[ItemEffectText]
  flavorTextEntries*: seq[ItemFlavorText]
  gameIndices*: seq[ItemGameIndex]
  names*: seq[ItemName]
  heldByPokemon*: seq[ItemDetail_held_by_pokemon_inner]
  sprites*: ItemDetail_sprites
  babyTriggerFor*: ItemDetail_baby_trigger_for
  machines*: seq[ItemDetail_machines_inner]


# Custom JSON deserialization for ItemDetail with custom field names
proc to*(node: JsonNode, T: typedesc[ItemDetail]): ItemDetail =
  result = ItemDetail()
  if node.kind == JObject:
    if node.hasKey("id"):
      result.id = to(node["id"], int)
    if node.hasKey("name"):
      result.name = to(node["name"], string)
    if node.hasKey("cost") and node["cost"].kind != JNull:
      result.cost = some(to(node["cost"], typeof(result.cost.get())))
    if node.hasKey("fling_power") and node["fling_power"].kind != JNull:
      result.flingPower = some(to(node["fling_power"], typeof(result.flingPower.get())))
    if node.hasKey("fling_effect"):
      result.flingEffect = to(node["fling_effect"], ItemFlingEffectSummary)
    if node.hasKey("attributes"):
      result.attributes = to(node["attributes"], seq[AbilityDetail_pokemon_inner_pokemon])
    if node.hasKey("category"):
      result.category = to(node["category"], ItemCategorySummary)
    if node.hasKey("effect_entries"):
      # Array of types with custom JSON - manually iterate and deserialize
      let arrayNode = node["effect_entries"]
      if arrayNode.kind == JArray:
        result.effectEntries = @[]
        for item in arrayNode.items:
          result.effectEntries.add(to(item, ItemEffectText))
    if node.hasKey("flavor_text_entries"):
      # Array of types with custom JSON - manually iterate and deserialize
      let arrayNode = node["flavor_text_entries"]
      if arrayNode.kind == JArray:
        result.flavorTextEntries = @[]
        for item in arrayNode.items:
          result.flavorTextEntries.add(to(item, ItemFlavorText))
    if node.hasKey("game_indices"):
      # Array of types with custom JSON - manually iterate and deserialize
      let arrayNode = node["game_indices"]
      if arrayNode.kind == JArray:
        result.gameIndices = @[]
        for item in arrayNode.items:
          result.gameIndices.add(to(item, ItemGameIndex))
    if node.hasKey("names"):
      result.names = to(node["names"], seq[ItemName])
    if node.hasKey("held_by_pokemon"):
      result.heldByPokemon = to(node["held_by_pokemon"], seq[ItemDetail_held_by_pokemon_inner])
    if node.hasKey("sprites"):
      result.sprites = to(node["sprites"], ItemDetail_sprites)
    if node.hasKey("baby_trigger_for"):
      result.babyTriggerFor = to(node["baby_trigger_for"], ItemDetail_baby_trigger_for)
    if node.hasKey("machines"):
      result.machines = to(node["machines"], seq[ItemDetail_machines_inner])

# Custom JSON serialization for ItemDetail with custom field names
proc `%`*(obj: ItemDetail): JsonNode =
  result = newJObject()
  result["id"] = %obj.id
  result["name"] = %obj.name
  if obj.cost.isSome():
    result["cost"] = %obj.cost.get()
  if obj.flingPower.isSome():
    result["fling_power"] = %obj.flingPower.get()
  result["fling_effect"] = %obj.flingEffect
  result["attributes"] = %obj.attributes
  result["category"] = %obj.category
  result["effect_entries"] = %obj.effectEntries
  result["flavor_text_entries"] = %obj.flavorTextEntries
  result["game_indices"] = %obj.gameIndices
  result["names"] = %obj.names
  result["held_by_pokemon"] = %obj.heldByPokemon
  result["sprites"] = %obj.sprites
  result["baby_trigger_for"] = %obj.babyTriggerFor
  result["machines"] = %obj.machines

