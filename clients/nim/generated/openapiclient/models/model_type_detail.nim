#
# PokéAPI
# 
# All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
# The version of the OpenAPI document: 2.7.0
# Contact: blah+oapicf@cliffano.com
# Generated by: https://openapi-generator.tech
#

import json
import tables
import marshal
import options

import model_ability_name
import model_generation_summary
import model_move_damage_class_summary
import model_move_summary
import model_type_detail_damage_relations
import model_type_detail_past_damage_relations_inner
import model_type_detail_pokemon_inner
import model_type_detail_sprites_value_value
import model_type_game_index

type TypeDetail* = object
  ## Serializer for the Type resource
  id*: int
  name*: string
  damageRelations*: TypeDetail_damage_relations
  pastDamageRelations*: seq[TypeDetail_past_damage_relations_inner]
  gameIndices*: seq[TypeGameIndex]
  generation*: GenerationSummary
  moveDamageClass*: MoveDamageClassSummary
  names*: seq[AbilityName]
  pokemon*: seq[TypeDetail_pokemon_inner]
  moves*: seq[MoveSummary]
  sprites*: Table[string, Table[string, TypeDetail_sprites_value_value]]


# Custom JSON deserialization for TypeDetail with custom field names
proc to*(node: JsonNode, T: typedesc[TypeDetail]): TypeDetail =
  result = TypeDetail()
  if node.kind == JObject:
    if node.hasKey("id"):
      result.id = to(node["id"], int)
    if node.hasKey("name"):
      result.name = to(node["name"], string)
    if node.hasKey("damage_relations"):
      result.damageRelations = to(node["damage_relations"], TypeDetail_damage_relations)
    if node.hasKey("past_damage_relations"):
      result.pastDamageRelations = to(node["past_damage_relations"], seq[TypeDetail_past_damage_relations_inner])
    if node.hasKey("game_indices"):
      # Array of types with custom JSON - manually iterate and deserialize
      let arrayNode = node["game_indices"]
      if arrayNode.kind == JArray:
        result.gameIndices = @[]
        for item in arrayNode.items:
          result.gameIndices.add(to(item, TypeGameIndex))
    if node.hasKey("generation"):
      result.generation = to(node["generation"], GenerationSummary)
    if node.hasKey("move_damage_class"):
      result.moveDamageClass = to(node["move_damage_class"], MoveDamageClassSummary)
    if node.hasKey("names"):
      result.names = to(node["names"], seq[AbilityName])
    if node.hasKey("pokemon"):
      result.pokemon = to(node["pokemon"], seq[TypeDetail_pokemon_inner])
    if node.hasKey("moves"):
      result.moves = to(node["moves"], seq[MoveSummary])
    if node.hasKey("sprites"):
      result.sprites = to(node["sprites"], Table[string, Table[string, TypeDetail_sprites_value_value]])

# Custom JSON serialization for TypeDetail with custom field names
proc `%`*(obj: TypeDetail): JsonNode =
  result = newJObject()
  result["id"] = %obj.id
  result["name"] = %obj.name
  result["damage_relations"] = %obj.damageRelations
  result["past_damage_relations"] = %obj.pastDamageRelations
  result["game_indices"] = %obj.gameIndices
  result["generation"] = %obj.generation
  result["move_damage_class"] = %obj.moveDamageClass
  result["names"] = %obj.names
  result["pokemon"] = %obj.pokemon
  result["moves"] = %obj.moves
  result["sprites"] = %obj.sprites

