// @flow
/* eslint-disable no-use-before-define */
/**
 * PokéAPI
 * All the Pokémon data you\'ll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We\'ve covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as url from "url";
import * as portableFetch from "portable-fetch";
import { Configuration } from "./configuration";

const BASE_PATH: string = "https://pokeapi.co".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 */
export type FetchAPI = {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 */
export type FetchArgs = {
    url: string;
    options: {};
}

/**
 *
 * @export
 */
export type RequestOptions = {
    headers?: {};
    query?: {};
    body?: string | FormData;
}

/**
 * * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name:string = "RequiredError"
    constructor(field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 */
export type AbilityChange = {
    /**
     * 
     * @type {VersionGroupSummary}
     * @memberof AbilityChange
     */
    version_group: VersionGroupSummary;
    /**
     * 
     * @type {Array<AbilityChangeEffectText>}
     * @memberof AbilityChange
     */
    effect_entries: Array<AbilityChangeEffectText>;
}

/**
 * 
 * @export
 */
export type AbilityChangeEffectText = {
    /**
     * 
     * @type {string}
     * @memberof AbilityChangeEffectText
     */
    effect: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof AbilityChangeEffectText
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type AbilityDetail = {
    /**
     * 
     * @type {number}
     * @memberof AbilityDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof AbilityDetail
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof AbilityDetail
     */
    is_main_series?: boolean;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof AbilityDetail
     */
    generation: GenerationSummary;
    /**
     * 
     * @type {Array<AbilityName>}
     * @memberof AbilityDetail
     */
    names: Array<AbilityName>;
    /**
     * 
     * @type {Array<AbilityEffectText>}
     * @memberof AbilityDetail
     */
    effect_entries: Array<AbilityEffectText>;
    /**
     * 
     * @type {Array<AbilityChange>}
     * @memberof AbilityDetail
     */
    effect_changes: Array<AbilityChange>;
    /**
     * 
     * @type {Array<AbilityFlavorText>}
     * @memberof AbilityDetail
     */
    flavor_text_entries: Array<AbilityFlavorText>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInner>}
     * @memberof AbilityDetail
     */
    pokemon: Array<AbilityDetailPokemonInner>;
}

/**
 * 
 * @export
 */
export type AbilityDetailPokemonInner = {
    /**
     * 
     * @type {boolean}
     * @memberof AbilityDetailPokemonInner
     */
    is_hidden: boolean;
    /**
     * 
     * @type {number}
     * @memberof AbilityDetailPokemonInner
     */
    slot: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof AbilityDetailPokemonInner
     */
    pokemon: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type AbilityDetailPokemonInnerPokemon = {
    /**
     * 
     * @type {string}
     * @memberof AbilityDetailPokemonInnerPokemon
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AbilityDetailPokemonInnerPokemon
     */
    url: string;
}

/**
 * 
 * @export
 */
export type AbilityEffectText = {
    /**
     * 
     * @type {string}
     * @memberof AbilityEffectText
     */
    effect: string;
    /**
     * 
     * @type {string}
     * @memberof AbilityEffectText
     */
    short_effect: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof AbilityEffectText
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type AbilityFlavorText = {
    /**
     * 
     * @type {string}
     * @memberof AbilityFlavorText
     */
    flavor_text: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof AbilityFlavorText
     */
    language: LanguageSummary;
    /**
     * 
     * @type {VersionGroupSummary}
     * @memberof AbilityFlavorText
     */
    version_group: VersionGroupSummary;
}

/**
 * 
 * @export
 */
export type AbilityName = {
    /**
     * 
     * @type {string}
     * @memberof AbilityName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof AbilityName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type AbilitySummary = {
    /**
     * 
     * @type {string}
     * @memberof AbilitySummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof AbilitySummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type BerryDetail = {
    /**
     * 
     * @type {number}
     * @memberof BerryDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BerryDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof BerryDetail
     */
    growth_time: number;
    /**
     * 
     * @type {number}
     * @memberof BerryDetail
     */
    max_harvest: number;
    /**
     * 
     * @type {number}
     * @memberof BerryDetail
     */
    natural_gift_power: number;
    /**
     * 
     * @type {number}
     * @memberof BerryDetail
     */
    size: number;
    /**
     * 
     * @type {number}
     * @memberof BerryDetail
     */
    smoothness: number;
    /**
     * 
     * @type {number}
     * @memberof BerryDetail
     */
    soil_dryness: number;
    /**
     * 
     * @type {BerryFirmnessSummary}
     * @memberof BerryDetail
     */
    firmness: BerryFirmnessSummary;
    /**
     * 
     * @type {Array<BerryDetailFlavorsInner>}
     * @memberof BerryDetail
     */
    flavors: Array<BerryDetailFlavorsInner>;
    /**
     * 
     * @type {ItemSummary}
     * @memberof BerryDetail
     */
    item: ItemSummary;
    /**
     * 
     * @type {TypeSummary}
     * @memberof BerryDetail
     */
    natural_gift_type: TypeSummary;
}

/**
 * 
 * @export
 */
export type BerryDetailFlavorsInner = {
    /**
     * 
     * @type {number}
     * @memberof BerryDetailFlavorsInner
     */
    potency: number;
    /**
     * 
     * @type {BerryDetailFlavorsInnerFlavor}
     * @memberof BerryDetailFlavorsInner
     */
    flavor: BerryDetailFlavorsInnerFlavor;
}

/**
 * 
 * @export
 */
export type BerryDetailFlavorsInnerFlavor = {
    /**
     * The name of the flavor
     * @type {string}
     * @memberof BerryDetailFlavorsInnerFlavor
     */
    name?: string;
    /**
     * The URL to get more information about the flavor
     * @type {string}
     * @memberof BerryDetailFlavorsInnerFlavor
     */
    url?: string;
}

/**
 * 
 * @export
 */
export type BerryFirmnessDetail = {
    /**
     * 
     * @type {number}
     * @memberof BerryFirmnessDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BerryFirmnessDetail
     */
    name: string;
    /**
     * 
     * @type {Array<BerrySummary>}
     * @memberof BerryFirmnessDetail
     */
    berries: Array<BerrySummary>;
    /**
     * 
     * @type {Array<BerryFirmnessName>}
     * @memberof BerryFirmnessDetail
     */
    names: Array<BerryFirmnessName>;
}

/**
 * 
 * @export
 */
export type BerryFirmnessName = {
    /**
     * 
     * @type {string}
     * @memberof BerryFirmnessName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof BerryFirmnessName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type BerryFirmnessSummary = {
    /**
     * 
     * @type {string}
     * @memberof BerryFirmnessSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BerryFirmnessSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type BerryFlavorDetail = {
    /**
     * 
     * @type {number}
     * @memberof BerryFlavorDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof BerryFlavorDetail
     */
    name: string;
    /**
     * 
     * @type {Array<BerryFlavorDetailBerriesInner>}
     * @memberof BerryFlavorDetail
     */
    berries: Array<BerryFlavorDetailBerriesInner>;
    /**
     * 
     * @type {ContestTypeSummary}
     * @memberof BerryFlavorDetail
     */
    contest_type: ContestTypeSummary;
    /**
     * 
     * @type {Array<BerryFlavorName>}
     * @memberof BerryFlavorDetail
     */
    names: Array<BerryFlavorName>;
}

/**
 * 
 * @export
 */
export type BerryFlavorDetailBerriesInner = {
    /**
     * 
     * @type {number}
     * @memberof BerryFlavorDetailBerriesInner
     */
    potency: number;
    /**
     * 
     * @type {BerryFlavorDetailBerriesInnerBerry}
     * @memberof BerryFlavorDetailBerriesInner
     */
    berry: BerryFlavorDetailBerriesInnerBerry;
}

/**
 * 
 * @export
 */
export type BerryFlavorDetailBerriesInnerBerry = {
    /**
     * The name of the berry
     * @type {string}
     * @memberof BerryFlavorDetailBerriesInnerBerry
     */
    name?: string;
    /**
     * The URL to get more information about the berry
     * @type {string}
     * @memberof BerryFlavorDetailBerriesInnerBerry
     */
    url?: string;
}

/**
 * 
 * @export
 */
export type BerryFlavorName = {
    /**
     * 
     * @type {string}
     * @memberof BerryFlavorName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof BerryFlavorName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type BerryFlavorSummary = {
    /**
     * 
     * @type {string}
     * @memberof BerryFlavorSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BerryFlavorSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type BerrySummary = {
    /**
     * 
     * @type {string}
     * @memberof BerrySummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof BerrySummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type CharacteristicDescription = {
    /**
     * 
     * @type {string}
     * @memberof CharacteristicDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof CharacteristicDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type CharacteristicDetail = {
    /**
     * 
     * @type {number}
     * @memberof CharacteristicDetail
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof CharacteristicDetail
     */
    gene_modulo: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof CharacteristicDetail
     */
    possible_values: Array<number>;
    /**
     * 
     * @type {StatSummary}
     * @memberof CharacteristicDetail
     */
    highest_stat: StatSummary;
    /**
     * 
     * @type {Array<CharacteristicDescription>}
     * @memberof CharacteristicDetail
     */
    descriptions: Array<CharacteristicDescription>;
}

/**
 * 
 * @export
 */
export type CharacteristicSummary = {
    /**
     * 
     * @type {string}
     * @memberof CharacteristicSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type ContestEffectDetail = {
    /**
     * 
     * @type {number}
     * @memberof ContestEffectDetail
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof ContestEffectDetail
     */
    appeal: number;
    /**
     * 
     * @type {number}
     * @memberof ContestEffectDetail
     */
    jam: number;
    /**
     * 
     * @type {Array<ContestEffectEffectText>}
     * @memberof ContestEffectDetail
     */
    effect_entries: Array<ContestEffectEffectText>;
    /**
     * 
     * @type {Array<ContestEffectFlavorText>}
     * @memberof ContestEffectDetail
     */
    flavor_text_entries: Array<ContestEffectFlavorText>;
}

/**
 * 
 * @export
 */
export type ContestEffectEffectText = {
    /**
     * 
     * @type {string}
     * @memberof ContestEffectEffectText
     */
    effect: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ContestEffectEffectText
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ContestEffectFlavorText = {
    /**
     * 
     * @type {string}
     * @memberof ContestEffectFlavorText
     */
    flavor_text: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ContestEffectFlavorText
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ContestEffectSummary = {
    /**
     * 
     * @type {string}
     * @memberof ContestEffectSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type ContestTypeDetail = {
    /**
     * 
     * @type {number}
     * @memberof ContestTypeDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ContestTypeDetail
     */
    name: string;
    /**
     * 
     * @type {BerryFlavorSummary}
     * @memberof ContestTypeDetail
     */
    berry_flavor: BerryFlavorSummary;
    /**
     * 
     * @type {Array<ContestTypeName>}
     * @memberof ContestTypeDetail
     */
    names: Array<ContestTypeName>;
}

/**
 * 
 * @export
 */
export type ContestTypeName = {
    /**
     * 
     * @type {string}
     * @memberof ContestTypeName
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContestTypeName
     */
    color: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ContestTypeName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ContestTypeSummary = {
    /**
     * 
     * @type {string}
     * @memberof ContestTypeSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ContestTypeSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type EggGroupDetail = {
    /**
     * 
     * @type {number}
     * @memberof EggGroupDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof EggGroupDetail
     */
    name: string;
    /**
     * 
     * @type {Array<EggGroupName>}
     * @memberof EggGroupDetail
     */
    names: Array<EggGroupName>;
    /**
     * 
     * @type {Array<EggGroupDetailPokemonSpeciesInner>}
     * @memberof EggGroupDetail
     */
    pokemon_species: Array<EggGroupDetailPokemonSpeciesInner>;
}

/**
 * 
 * @export
 */
export type EggGroupDetailPokemonSpeciesInner = {
    /**
     * Pokemon species name.
     * @type {string}
     * @memberof EggGroupDetailPokemonSpeciesInner
     */
    name?: string;
    /**
     * The URL to get more information about the species
     * @type {string}
     * @memberof EggGroupDetailPokemonSpeciesInner
     */
    url?: string;
}

/**
 * 
 * @export
 */
export type EggGroupName = {
    /**
     * 
     * @type {string}
     * @memberof EggGroupName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof EggGroupName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type EggGroupSummary = {
    /**
     * 
     * @type {string}
     * @memberof EggGroupSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EggGroupSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type EncounterConditionDetail = {
    /**
     * 
     * @type {number}
     * @memberof EncounterConditionDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof EncounterConditionDetail
     */
    name: string;
    /**
     * 
     * @type {Array<EncounterConditionValueSummary>}
     * @memberof EncounterConditionDetail
     */
    values: Array<EncounterConditionValueSummary>;
    /**
     * 
     * @type {Array<EncounterConditionName>}
     * @memberof EncounterConditionDetail
     */
    names: Array<EncounterConditionName>;
}

/**
 * 
 * @export
 */
export type EncounterConditionName = {
    /**
     * 
     * @type {string}
     * @memberof EncounterConditionName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof EncounterConditionName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type EncounterConditionSummary = {
    /**
     * 
     * @type {string}
     * @memberof EncounterConditionSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EncounterConditionSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type EncounterConditionValueDetail = {
    /**
     * 
     * @type {number}
     * @memberof EncounterConditionValueDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof EncounterConditionValueDetail
     */
    name: string;
    /**
     * 
     * @type {EncounterConditionSummary}
     * @memberof EncounterConditionValueDetail
     */
    condition: EncounterConditionSummary;
    /**
     * 
     * @type {Array<EncounterConditionValueName>}
     * @memberof EncounterConditionValueDetail
     */
    names: Array<EncounterConditionValueName>;
}

/**
 * 
 * @export
 */
export type EncounterConditionValueName = {
    /**
     * 
     * @type {string}
     * @memberof EncounterConditionValueName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof EncounterConditionValueName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type EncounterConditionValueSummary = {
    /**
     * 
     * @type {string}
     * @memberof EncounterConditionValueSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EncounterConditionValueSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type EncounterMethodDetail = {
    /**
     * 
     * @type {number}
     * @memberof EncounterMethodDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof EncounterMethodDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof EncounterMethodDetail
     */
    order?: number;
    /**
     * 
     * @type {Array<EncounterMethodName>}
     * @memberof EncounterMethodDetail
     */
    names: Array<EncounterMethodName>;
}

/**
 * 
 * @export
 */
export type EncounterMethodName = {
    /**
     * 
     * @type {string}
     * @memberof EncounterMethodName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof EncounterMethodName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type EncounterMethodSummary = {
    /**
     * 
     * @type {string}
     * @memberof EncounterMethodSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EncounterMethodSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type EvolutionChainDetail = {
    /**
     * 
     * @type {number}
     * @memberof EvolutionChainDetail
     */
    id: number;
    /**
     * 
     * @type {ItemSummary}
     * @memberof EvolutionChainDetail
     */
    baby_trigger_item: ItemSummary;
    /**
     * 
     * @type {EvolutionChainDetailChain}
     * @memberof EvolutionChainDetail
     */
    chain: EvolutionChainDetailChain;
}

/**
 * 
 * @export
 */
export type EvolutionChainDetailChain = {
    /**
     * 
     * @type {Array<AnyType>}
     * @memberof EvolutionChainDetailChain
     */
    evolution_details: Array<AnyType>;
    /**
     * 
     * @type {Array<EvolutionChainDetailChainEvolvesToInner>}
     * @memberof EvolutionChainDetailChain
     */
    evolves_to: Array<EvolutionChainDetailChainEvolvesToInner>;
    /**
     * 
     * @type {boolean}
     * @memberof EvolutionChainDetailChain
     */
    is_baby: boolean;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof EvolutionChainDetailChain
     */
    species: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type EvolutionChainDetailChainEvolvesToInner = {
    /**
     * 
     * @type {Array<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner>}
     * @memberof EvolutionChainDetailChainEvolvesToInner
     */
    evolution_details: Array<EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner>;
    /**
     * 
     * @type {boolean}
     * @memberof EvolutionChainDetailChainEvolvesToInner
     */
    is_baby: boolean;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof EvolutionChainDetailChainEvolvesToInner
     */
    species: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner = {
    /**
     * 
     * @type {EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    gender: EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender;
    /**
     * 
     * @type {EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    held_item: EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender;
    /**
     * 
     * @type {EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    item: EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender;
    /**
     * 
     * @type {Object}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    known_move: Object;
    /**
     * 
     * @type {Object}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    known_move_type: Object;
    /**
     * 
     * @type {EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    location: EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender;
    /**
     * 
     * @type {number}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    min_affection: number;
    /**
     * 
     * @type {number}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    min_beauty: number;
    /**
     * 
     * @type {number}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    min_happiness: number;
    /**
     * 
     * @type {number}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    min_level: number;
    /**
     * 
     * @type {boolean}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    needs_overworld_rain: boolean;
    /**
     * 
     * @type {string}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    party_species: string;
    /**
     * 
     * @type {string}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    party_type: string;
    /**
     * 
     * @type {string}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    relative_physical_stats: string;
    /**
     * 
     * @type {string}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    time_of_day: string;
    /**
     * 
     * @type {string}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    trade_species: string;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    trigger: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {boolean}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInner
     */
    turn_upside_down: boolean;
}

/**
 * 
 * @export
 */
export type EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender = {
    /**
     * 
     * @type {string}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EvolutionChainDetailChainEvolvesToInnerEvolutionDetailsInnerGender
     */
    url: string;
}

/**
 * 
 * @export
 */
export type EvolutionChainSummary = {
    /**
     * 
     * @type {string}
     * @memberof EvolutionChainSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type EvolutionTriggerDetail = {
    /**
     * 
     * @type {number}
     * @memberof EvolutionTriggerDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof EvolutionTriggerDetail
     */
    name: string;
    /**
     * 
     * @type {Array<EvolutionTriggerName>}
     * @memberof EvolutionTriggerDetail
     */
    names: Array<EvolutionTriggerName>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof EvolutionTriggerDetail
     */
    pokemon_species: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type EvolutionTriggerName = {
    /**
     * 
     * @type {string}
     * @memberof EvolutionTriggerName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof EvolutionTriggerName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type EvolutionTriggerSummary = {
    /**
     * 
     * @type {string}
     * @memberof EvolutionTriggerSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof EvolutionTriggerSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type Experience = {
    /**
     * 
     * @type {number}
     * @memberof Experience
     */
    level: number;
    /**
     * 
     * @type {number}
     * @memberof Experience
     */
    experience: number;
}

/**
 * 
 * @export
 */
export type GenderDetail = {
    /**
     * 
     * @type {number}
     * @memberof GenderDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof GenderDetail
     */
    name: string;
    /**
     * 
     * @type {Array<GenderDetailPokemonSpeciesDetailsInner>}
     * @memberof GenderDetail
     */
    pokemon_species_details: Array<GenderDetailPokemonSpeciesDetailsInner>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof GenderDetail
     */
    required_for_evolution: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type GenderDetailPokemonSpeciesDetailsInner = {
    /**
     * 
     * @type {number}
     * @memberof GenderDetailPokemonSpeciesDetailsInner
     */
    rate: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof GenderDetailPokemonSpeciesDetailsInner
     */
    pokemon_species: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type GenderSummary = {
    /**
     * 
     * @type {string}
     * @memberof GenderSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GenderSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type GenerationDetail = {
    /**
     * 
     * @type {number}
     * @memberof GenerationDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof GenerationDetail
     */
    name: string;
    /**
     * 
     * @type {Array<AbilitySummary>}
     * @memberof GenerationDetail
     */
    abilities: Array<AbilitySummary>;
    /**
     * 
     * @type {RegionSummary}
     * @memberof GenerationDetail
     */
    main_region: RegionSummary;
    /**
     * 
     * @type {Array<MoveSummary>}
     * @memberof GenerationDetail
     */
    moves: Array<MoveSummary>;
    /**
     * 
     * @type {Array<GenerationName>}
     * @memberof GenerationDetail
     */
    names: Array<GenerationName>;
    /**
     * 
     * @type {Array<PokemonSpeciesSummary>}
     * @memberof GenerationDetail
     */
    pokemon_species: Array<PokemonSpeciesSummary>;
    /**
     * 
     * @type {Array<TypeSummary>}
     * @memberof GenerationDetail
     */
    types: Array<TypeSummary>;
    /**
     * 
     * @type {Array<VersionGroupSummary>}
     * @memberof GenerationDetail
     */
    version_groups: Array<VersionGroupSummary>;
}

/**
 * 
 * @export
 */
export type GenerationName = {
    /**
     * 
     * @type {string}
     * @memberof GenerationName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof GenerationName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type GenerationSummary = {
    /**
     * 
     * @type {string}
     * @memberof GenerationSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GenerationSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type GrowthRateDescription = {
    /**
     * 
     * @type {string}
     * @memberof GrowthRateDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof GrowthRateDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type GrowthRateDetail = {
    /**
     * 
     * @type {number}
     * @memberof GrowthRateDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof GrowthRateDetail
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GrowthRateDetail
     */
    formula: string;
    /**
     * 
     * @type {Array<GrowthRateDescription>}
     * @memberof GrowthRateDetail
     */
    descriptions: Array<GrowthRateDescription>;
    /**
     * 
     * @type {Array<Experience>}
     * @memberof GrowthRateDetail
     */
    levels: Array<Experience>;
    /**
     * 
     * @type {Array<PokemonSpeciesSummary>}
     * @memberof GrowthRateDetail
     */
    pokemon_species: Array<PokemonSpeciesSummary>;
}

/**
 * 
 * @export
 */
export type GrowthRateSummary = {
    /**
     * 
     * @type {string}
     * @memberof GrowthRateSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof GrowthRateSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type ItemAttributeDescription = {
    /**
     * 
     * @type {string}
     * @memberof ItemAttributeDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ItemAttributeDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ItemAttributeDetail = {
    /**
     * 
     * @type {number}
     * @memberof ItemAttributeDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ItemAttributeDetail
     */
    name: string;
    /**
     * 
     * @type {Array<ItemAttributeDescription>}
     * @memberof ItemAttributeDetail
     */
    descriptions: Array<ItemAttributeDescription>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof ItemAttributeDetail
     */
    items: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<ItemAttributeName>}
     * @memberof ItemAttributeDetail
     */
    names: Array<ItemAttributeName>;
}

/**
 * 
 * @export
 */
export type ItemAttributeName = {
    /**
     * 
     * @type {string}
     * @memberof ItemAttributeName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ItemAttributeName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ItemAttributeSummary = {
    /**
     * 
     * @type {string}
     * @memberof ItemAttributeSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ItemAttributeSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type ItemCategoryDetail = {
    /**
     * 
     * @type {number}
     * @memberof ItemCategoryDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ItemCategoryDetail
     */
    name: string;
    /**
     * 
     * @type {Array<ItemSummary>}
     * @memberof ItemCategoryDetail
     */
    items: Array<ItemSummary>;
    /**
     * 
     * @type {Array<ItemCategoryName>}
     * @memberof ItemCategoryDetail
     */
    names: Array<ItemCategoryName>;
    /**
     * 
     * @type {ItemPocketSummary}
     * @memberof ItemCategoryDetail
     */
    pocket: ItemPocketSummary;
}

/**
 * 
 * @export
 */
export type ItemCategoryName = {
    /**
     * 
     * @type {string}
     * @memberof ItemCategoryName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ItemCategoryName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ItemCategorySummary = {
    /**
     * 
     * @type {string}
     * @memberof ItemCategorySummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ItemCategorySummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type ItemDetail = {
    /**
     * 
     * @type {number}
     * @memberof ItemDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ItemDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof ItemDetail
     */
    cost?: number;
    /**
     * 
     * @type {number}
     * @memberof ItemDetail
     */
    fling_power?: number;
    /**
     * 
     * @type {ItemFlingEffectSummary}
     * @memberof ItemDetail
     */
    fling_effect: ItemFlingEffectSummary;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof ItemDetail
     */
    attributes: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {ItemCategorySummary}
     * @memberof ItemDetail
     */
    category: ItemCategorySummary;
    /**
     * 
     * @type {Array<ItemEffectText>}
     * @memberof ItemDetail
     */
    effect_entries: Array<ItemEffectText>;
    /**
     * 
     * @type {Array<ItemFlavorText>}
     * @memberof ItemDetail
     */
    flavor_text_entries: Array<ItemFlavorText>;
    /**
     * 
     * @type {Array<ItemGameIndex>}
     * @memberof ItemDetail
     */
    game_indices: Array<ItemGameIndex>;
    /**
     * 
     * @type {Array<ItemName>}
     * @memberof ItemDetail
     */
    names: Array<ItemName>;
    /**
     * 
     * @type {Array<ItemDetailHeldByPokemonInner>}
     * @memberof ItemDetail
     */
    held_by_pokemon: Array<ItemDetailHeldByPokemonInner>;
    /**
     * 
     * @type {ItemDetailSprites}
     * @memberof ItemDetail
     */
    sprites: ItemDetailSprites;
    /**
     * 
     * @type {ItemDetailBabyTriggerFor}
     * @memberof ItemDetail
     */
    baby_trigger_for: ItemDetailBabyTriggerFor;
    /**
     * 
     * @type {Array<ItemDetailMachinesInner>}
     * @memberof ItemDetail
     */
    machines: Array<ItemDetailMachinesInner>;
}

/**
 * 
 * @export
 */
export type ItemDetailBabyTriggerFor = {
    /**
     * 
     * @type {string}
     * @memberof ItemDetailBabyTriggerFor
     */
    url: string;
}

/**
 * 
 * @export
 */
export type ItemDetailHeldByPokemonInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof ItemDetailHeldByPokemonInner
     */
    pokemon: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {Array<ItemDetailHeldByPokemonInnerVersionDetailsInner>}
     * @memberof ItemDetailHeldByPokemonInner
     */
    version_details: Array<ItemDetailHeldByPokemonInnerVersionDetailsInner>;
}

/**
 * 
 * @export
 */
export type ItemDetailHeldByPokemonInnerVersionDetailsInner = {
    /**
     * 
     * @type {number}
     * @memberof ItemDetailHeldByPokemonInnerVersionDetailsInner
     */
    rarity: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof ItemDetailHeldByPokemonInnerVersionDetailsInner
     */
    version: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type ItemDetailMachinesInner = {
    /**
     * 
     * @type {string}
     * @memberof ItemDetailMachinesInner
     */
    machine: string;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof ItemDetailMachinesInner
     */
    version_group: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type ItemDetailSprites = {
    /**
     * 
     * @type {string}
     * @memberof ItemDetailSprites
     */
    _default: string;
}

/**
 * 
 * @export
 */
export type ItemEffectText = {
    /**
     * 
     * @type {string}
     * @memberof ItemEffectText
     */
    effect: string;
    /**
     * 
     * @type {string}
     * @memberof ItemEffectText
     */
    short_effect: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ItemEffectText
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ItemFlavorText = {
    /**
     * 
     * @type {string}
     * @memberof ItemFlavorText
     */
    text: string;
    /**
     * 
     * @type {VersionGroupSummary}
     * @memberof ItemFlavorText
     */
    version_group: VersionGroupSummary;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ItemFlavorText
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ItemFlingEffectDetail = {
    /**
     * 
     * @type {number}
     * @memberof ItemFlingEffectDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ItemFlingEffectDetail
     */
    name: string;
    /**
     * 
     * @type {Array<ItemFlingEffectEffectText>}
     * @memberof ItemFlingEffectDetail
     */
    effect_entries: Array<ItemFlingEffectEffectText>;
    /**
     * 
     * @type {Array<ItemSummary>}
     * @memberof ItemFlingEffectDetail
     */
    items: Array<ItemSummary>;
}

/**
 * 
 * @export
 */
export type ItemFlingEffectEffectText = {
    /**
     * 
     * @type {string}
     * @memberof ItemFlingEffectEffectText
     */
    effect: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ItemFlingEffectEffectText
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ItemFlingEffectSummary = {
    /**
     * 
     * @type {string}
     * @memberof ItemFlingEffectSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ItemFlingEffectSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type ItemGameIndex = {
    /**
     * 
     * @type {number}
     * @memberof ItemGameIndex
     */
    game_index: number;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof ItemGameIndex
     */
    generation: GenerationSummary;
}

/**
 * 
 * @export
 */
export type ItemName = {
    /**
     * 
     * @type {string}
     * @memberof ItemName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ItemName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ItemPocketDetail = {
    /**
     * 
     * @type {number}
     * @memberof ItemPocketDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof ItemPocketDetail
     */
    name: string;
    /**
     * 
     * @type {Array<ItemCategorySummary>}
     * @memberof ItemPocketDetail
     */
    categories: Array<ItemCategorySummary>;
    /**
     * 
     * @type {Array<ItemPocketName>}
     * @memberof ItemPocketDetail
     */
    names: Array<ItemPocketName>;
}

/**
 * 
 * @export
 */
export type ItemPocketName = {
    /**
     * 
     * @type {string}
     * @memberof ItemPocketName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof ItemPocketName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type ItemPocketSummary = {
    /**
     * 
     * @type {string}
     * @memberof ItemPocketSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ItemPocketSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type ItemSummary = {
    /**
     * 
     * @type {string}
     * @memberof ItemSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof ItemSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type LanguageDetail = {
    /**
     * 
     * @type {number}
     * @memberof LanguageDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof LanguageDetail
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof LanguageDetail
     */
    official?: boolean;
    /**
     * 
     * @type {string}
     * @memberof LanguageDetail
     */
    iso639: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageDetail
     */
    iso3166: string;
    /**
     * 
     * @type {Array<LanguageName>}
     * @memberof LanguageDetail
     */
    names: Array<LanguageName>;
}

/**
 * 
 * @export
 */
export type LanguageName = {
    /**
     * 
     * @type {string}
     * @memberof LanguageName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof LanguageName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type LanguageSummary = {
    /**
     * 
     * @type {string}
     * @memberof LanguageSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof LanguageSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type LocationAreaDetail = {
    /**
     * 
     * @type {number}
     * @memberof LocationAreaDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof LocationAreaDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof LocationAreaDetail
     */
    game_index: number;
    /**
     * 
     * @type {Array<LocationAreaDetailEncounterMethodRatesInner>}
     * @memberof LocationAreaDetail
     */
    encounter_method_rates: Array<LocationAreaDetailEncounterMethodRatesInner>;
    /**
     * 
     * @type {LocationSummary}
     * @memberof LocationAreaDetail
     */
    location: LocationSummary;
    /**
     * 
     * @type {Array<LocationAreaName>}
     * @memberof LocationAreaDetail
     */
    names: Array<LocationAreaName>;
    /**
     * 
     * @type {Array<LocationAreaDetailPokemonEncountersInner>}
     * @memberof LocationAreaDetail
     */
    pokemon_encounters: Array<LocationAreaDetailPokemonEncountersInner>;
}

/**
 * 
 * @export
 */
export type LocationAreaDetailEncounterMethodRatesInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof LocationAreaDetailEncounterMethodRatesInner
     */
    encounter_method: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {Array<LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner>}
     * @memberof LocationAreaDetailEncounterMethodRatesInner
     */
    version_details: Array<LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner>;
}

/**
 * 
 * @export
 */
export type LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner = {
    /**
     * 
     * @type {number}
     * @memberof LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner
     */
    rate: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof LocationAreaDetailEncounterMethodRatesInnerVersionDetailsInner
     */
    version: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type LocationAreaDetailPokemonEncountersInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof LocationAreaDetailPokemonEncountersInner
     */
    pokemon: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {Array<LocationAreaDetailPokemonEncountersInnerVersionDetailsInner>}
     * @memberof LocationAreaDetailPokemonEncountersInner
     */
    version_details: Array<LocationAreaDetailPokemonEncountersInnerVersionDetailsInner>;
}

/**
 * 
 * @export
 */
export type LocationAreaDetailPokemonEncountersInnerVersionDetailsInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof LocationAreaDetailPokemonEncountersInnerVersionDetailsInner
     */
    version: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {number}
     * @memberof LocationAreaDetailPokemonEncountersInnerVersionDetailsInner
     */
    max_chance: number;
    /**
     * 
     * @type {LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails}
     * @memberof LocationAreaDetailPokemonEncountersInnerVersionDetailsInner
     */
    encounter_details: LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails;
}

/**
 * 
 * @export
 */
export type LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails = {
    /**
     * 
     * @type {number}
     * @memberof LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails
     */
    min_level: number;
    /**
     * 
     * @type {number}
     * @memberof LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails
     */
    max_level: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails
     */
    condition_values?: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {number}
     * @memberof LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails
     */
    chance: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof LocationAreaDetailPokemonEncountersInnerVersionDetailsInnerEncounterDetails
     */
    method: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type LocationAreaName = {
    /**
     * 
     * @type {string}
     * @memberof LocationAreaName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof LocationAreaName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type LocationAreaSummary = {
    /**
     * 
     * @type {string}
     * @memberof LocationAreaSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof LocationAreaSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type LocationDetail = {
    /**
     * 
     * @type {number}
     * @memberof LocationDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof LocationDetail
     */
    name: string;
    /**
     * 
     * @type {RegionSummary}
     * @memberof LocationDetail
     */
    region: RegionSummary;
    /**
     * 
     * @type {Array<LocationName>}
     * @memberof LocationDetail
     */
    names: Array<LocationName>;
    /**
     * 
     * @type {Array<LocationGameIndex>}
     * @memberof LocationDetail
     */
    game_indices: Array<LocationGameIndex>;
    /**
     * 
     * @type {Array<LocationAreaSummary>}
     * @memberof LocationDetail
     */
    areas: Array<LocationAreaSummary>;
}

/**
 * 
 * @export
 */
export type LocationGameIndex = {
    /**
     * 
     * @type {number}
     * @memberof LocationGameIndex
     */
    game_index: number;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof LocationGameIndex
     */
    generation: GenerationSummary;
}

/**
 * 
 * @export
 */
export type LocationName = {
    /**
     * 
     * @type {string}
     * @memberof LocationName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof LocationName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type LocationSummary = {
    /**
     * 
     * @type {string}
     * @memberof LocationSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof LocationSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MachineDetail = {
    /**
     * 
     * @type {number}
     * @memberof MachineDetail
     */
    id: number;
    /**
     * 
     * @type {ItemSummary}
     * @memberof MachineDetail
     */
    item: ItemSummary;
    /**
     * 
     * @type {VersionGroupSummary}
     * @memberof MachineDetail
     */
    version_group: VersionGroupSummary;
    /**
     * 
     * @type {MoveSummary}
     * @memberof MachineDetail
     */
    move: MoveSummary;
}

/**
 * 
 * @export
 */
export type MachineSummary = {
    /**
     * 
     * @type {string}
     * @memberof MachineSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MoveBattleStyleDetail = {
    /**
     * 
     * @type {number}
     * @memberof MoveBattleStyleDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MoveBattleStyleDetail
     */
    name: string;
    /**
     * 
     * @type {Array<MoveBattleStyleName>}
     * @memberof MoveBattleStyleDetail
     */
    names: Array<MoveBattleStyleName>;
}

/**
 * 
 * @export
 */
export type MoveBattleStyleName = {
    /**
     * 
     * @type {string}
     * @memberof MoveBattleStyleName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveBattleStyleName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveBattleStyleSummary = {
    /**
     * 
     * @type {string}
     * @memberof MoveBattleStyleSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MoveBattleStyleSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MoveChange = {
    /**
     * 
     * @type {number}
     * @memberof MoveChange
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveChange
     */
    power?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveChange
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveChange
     */
    effect_chance: number;
    /**
     * 
     * @type {Array<MoveChangeEffectEntriesInner>}
     * @memberof MoveChange
     */
    effect_entries: Array<MoveChangeEffectEntriesInner>;
    /**
     * 
     * @type {TypeSummary}
     * @memberof MoveChange
     */
    type: TypeSummary;
    /**
     * 
     * @type {VersionGroupSummary}
     * @memberof MoveChange
     */
    version_group: VersionGroupSummary;
}

/**
 * 
 * @export
 */
export type MoveChangeEffectEntriesInner = {
    /**
     * 
     * @type {string}
     * @memberof MoveChangeEffectEntriesInner
     */
    effect: string;
    /**
     * 
     * @type {string}
     * @memberof MoveChangeEffectEntriesInner
     */
    short_effect: string;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof MoveChangeEffectEntriesInner
     */
    language: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type MoveDamageClassDescription = {
    /**
     * 
     * @type {string}
     * @memberof MoveDamageClassDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveDamageClassDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveDamageClassDetail = {
    /**
     * 
     * @type {number}
     * @memberof MoveDamageClassDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MoveDamageClassDetail
     */
    name: string;
    /**
     * 
     * @type {Array<MoveDamageClassDescription>}
     * @memberof MoveDamageClassDetail
     */
    descriptions: Array<MoveDamageClassDescription>;
    /**
     * 
     * @type {Array<MoveSummary>}
     * @memberof MoveDamageClassDetail
     */
    moves: Array<MoveSummary>;
    /**
     * 
     * @type {Array<MoveDamageClassName>}
     * @memberof MoveDamageClassDetail
     */
    names: Array<MoveDamageClassName>;
}

/**
 * 
 * @export
 */
export type MoveDamageClassName = {
    /**
     * 
     * @type {string}
     * @memberof MoveDamageClassName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveDamageClassName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveDamageClassSummary = {
    /**
     * 
     * @type {string}
     * @memberof MoveDamageClassSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MoveDamageClassSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MoveDetail = {
    /**
     * 
     * @type {number}
     * @memberof MoveDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MoveDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof MoveDetail
     */
    accuracy?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveDetail
     */
    effect_chance: number;
    /**
     * 
     * @type {number}
     * @memberof MoveDetail
     */
    pp?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveDetail
     */
    priority?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveDetail
     */
    power?: number;
    /**
     * 
     * @type {MoveDetailContestCombos}
     * @memberof MoveDetail
     */
    contest_combos: MoveDetailContestCombos;
    /**
     * 
     * @type {ContestTypeSummary}
     * @memberof MoveDetail
     */
    contest_type: ContestTypeSummary;
    /**
     * 
     * @type {ContestEffectSummary}
     * @memberof MoveDetail
     */
    contest_effect: ContestEffectSummary;
    /**
     * 
     * @type {MoveDamageClassSummary}
     * @memberof MoveDetail
     */
    damage_class: MoveDamageClassSummary;
    /**
     * 
     * @type {Array<MoveChangeEffectEntriesInner>}
     * @memberof MoveDetail
     */
    effect_entries: Array<MoveChangeEffectEntriesInner>;
    /**
     * 
     * @type {Array<MoveDetailEffectChangesInner>}
     * @memberof MoveDetail
     */
    effect_changes: Array<MoveDetailEffectChangesInner>;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof MoveDetail
     */
    generation: GenerationSummary;
    /**
     * 
     * @type {MoveMeta}
     * @memberof MoveDetail
     */
    meta: MoveMeta;
    /**
     * 
     * @type {Array<MoveName>}
     * @memberof MoveDetail
     */
    names: Array<MoveName>;
    /**
     * 
     * @type {Array<MoveChange>}
     * @memberof MoveDetail
     */
    past_values: Array<MoveChange>;
    /**
     * 
     * @type {Array<MoveDetailStatChangesInner>}
     * @memberof MoveDetail
     */
    stat_changes: Array<MoveDetailStatChangesInner>;
    /**
     * 
     * @type {SuperContestEffectSummary}
     * @memberof MoveDetail
     */
    super_contest_effect: SuperContestEffectSummary;
    /**
     * 
     * @type {MoveTargetSummary}
     * @memberof MoveDetail
     */
    target: MoveTargetSummary;
    /**
     * 
     * @type {TypeSummary}
     * @memberof MoveDetail
     */
    type: TypeSummary;
    /**
     * 
     * @type {Array<MoveDetailMachinesInner>}
     * @memberof MoveDetail
     */
    machines: Array<MoveDetailMachinesInner>;
    /**
     * 
     * @type {Array<MoveFlavorText>}
     * @memberof MoveDetail
     */
    flavor_text_entries: Array<MoveFlavorText>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof MoveDetail
     */
    learned_by_pokemon: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type MoveDetailContestCombos = {
    /**
     * 
     * @type {MoveDetailContestCombosNormal}
     * @memberof MoveDetailContestCombos
     */
    normal: MoveDetailContestCombosNormal;
    /**
     * 
     * @type {MoveDetailContestCombosNormal}
     * @memberof MoveDetailContestCombos
     */
    _super: MoveDetailContestCombosNormal;
}

/**
 * 
 * @export
 */
export type MoveDetailContestCombosNormal = {
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof MoveDetailContestCombosNormal
     */
    use_before: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof MoveDetailContestCombosNormal
     */
    use_after: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type MoveDetailEffectChangesInner = {
    /**
     * 
     * @type {Array<MoveDetailEffectChangesInnerEffectEntriesInner>}
     * @memberof MoveDetailEffectChangesInner
     */
    effect_entries: Array<MoveDetailEffectChangesInnerEffectEntriesInner>;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof MoveDetailEffectChangesInner
     */
    version_group: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type MoveDetailEffectChangesInnerEffectEntriesInner = {
    /**
     * 
     * @type {string}
     * @memberof MoveDetailEffectChangesInnerEffectEntriesInner
     */
    effect: string;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof MoveDetailEffectChangesInnerEffectEntriesInner
     */
    language: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type MoveDetailMachinesInner = {
    /**
     * 
     * @type {MoveDetailMachinesInnerMachine}
     * @memberof MoveDetailMachinesInner
     */
    machine: MoveDetailMachinesInnerMachine;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof MoveDetailMachinesInner
     */
    version_group: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type MoveDetailMachinesInnerMachine = {
    /**
     * 
     * @type {string}
     * @memberof MoveDetailMachinesInnerMachine
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MoveDetailStatChangesInner = {
    /**
     * 
     * @type {number}
     * @memberof MoveDetailStatChangesInner
     */
    change: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof MoveDetailStatChangesInner
     */
    stat: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type MoveFlavorText = {
    /**
     * 
     * @type {string}
     * @memberof MoveFlavorText
     */
    flavor_text: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveFlavorText
     */
    language: LanguageSummary;
    /**
     * 
     * @type {VersionGroupSummary}
     * @memberof MoveFlavorText
     */
    version_group: VersionGroupSummary;
}

/**
 * 
 * @export
 */
export type MoveLearnMethodDescription = {
    /**
     * 
     * @type {string}
     * @memberof MoveLearnMethodDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveLearnMethodDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveLearnMethodDetail = {
    /**
     * 
     * @type {number}
     * @memberof MoveLearnMethodDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MoveLearnMethodDetail
     */
    name: string;
    /**
     * 
     * @type {Array<MoveLearnMethodName>}
     * @memberof MoveLearnMethodDetail
     */
    names: Array<MoveLearnMethodName>;
    /**
     * 
     * @type {Array<MoveLearnMethodDescription>}
     * @memberof MoveLearnMethodDetail
     */
    descriptions: Array<MoveLearnMethodDescription>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof MoveLearnMethodDetail
     */
    version_groups: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type MoveLearnMethodName = {
    /**
     * 
     * @type {string}
     * @memberof MoveLearnMethodName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveLearnMethodName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveLearnMethodSummary = {
    /**
     * 
     * @type {string}
     * @memberof MoveLearnMethodSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MoveLearnMethodSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MoveMeta = {
    /**
     * 
     * @type {MoveMetaAilmentSummary}
     * @memberof MoveMeta
     */
    ailment: MoveMetaAilmentSummary;
    /**
     * 
     * @type {MoveMetaCategorySummary}
     * @memberof MoveMeta
     */
    category: MoveMetaCategorySummary;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    min_hits?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    max_hits?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    min_turns?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    max_turns?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    drain?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    healing?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    crit_rate?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    ailment_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    flinch_chance?: number;
    /**
     * 
     * @type {number}
     * @memberof MoveMeta
     */
    stat_chance?: number;
}

/**
 * 
 * @export
 */
export type MoveMetaAilmentDetail = {
    /**
     * 
     * @type {number}
     * @memberof MoveMetaAilmentDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MoveMetaAilmentDetail
     */
    name: string;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof MoveMetaAilmentDetail
     */
    moves: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<MoveMetaAilmentName>}
     * @memberof MoveMetaAilmentDetail
     */
    names: Array<MoveMetaAilmentName>;
}

/**
 * 
 * @export
 */
export type MoveMetaAilmentName = {
    /**
     * 
     * @type {string}
     * @memberof MoveMetaAilmentName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveMetaAilmentName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveMetaAilmentSummary = {
    /**
     * 
     * @type {string}
     * @memberof MoveMetaAilmentSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MoveMetaAilmentSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MoveMetaCategoryDescription = {
    /**
     * 
     * @type {string}
     * @memberof MoveMetaCategoryDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveMetaCategoryDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveMetaCategoryDetail = {
    /**
     * 
     * @type {number}
     * @memberof MoveMetaCategoryDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MoveMetaCategoryDetail
     */
    name: string;
    /**
     * 
     * @type {Array<MoveMetaCategoryDescription>}
     * @memberof MoveMetaCategoryDetail
     */
    descriptions: Array<MoveMetaCategoryDescription>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof MoveMetaCategoryDetail
     */
    moves: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type MoveMetaCategorySummary = {
    /**
     * 
     * @type {string}
     * @memberof MoveMetaCategorySummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MoveMetaCategorySummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MoveName = {
    /**
     * 
     * @type {string}
     * @memberof MoveName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveSummary = {
    /**
     * 
     * @type {string}
     * @memberof MoveSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MoveSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type MoveTargetDescription = {
    /**
     * 
     * @type {string}
     * @memberof MoveTargetDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveTargetDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveTargetDetail = {
    /**
     * 
     * @type {number}
     * @memberof MoveTargetDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof MoveTargetDetail
     */
    name: string;
    /**
     * 
     * @type {Array<MoveTargetDescription>}
     * @memberof MoveTargetDetail
     */
    descriptions: Array<MoveTargetDescription>;
    /**
     * 
     * @type {Array<MoveSummary>}
     * @memberof MoveTargetDetail
     */
    moves: Array<MoveSummary>;
    /**
     * 
     * @type {Array<MoveTargetName>}
     * @memberof MoveTargetDetail
     */
    names: Array<MoveTargetName>;
}

/**
 * 
 * @export
 */
export type MoveTargetName = {
    /**
     * 
     * @type {string}
     * @memberof MoveTargetName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof MoveTargetName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type MoveTargetSummary = {
    /**
     * 
     * @type {string}
     * @memberof MoveTargetSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof MoveTargetSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type NatureBattleStylePreference = {
    /**
     * 
     * @type {number}
     * @memberof NatureBattleStylePreference
     */
    low_hp_preference: number;
    /**
     * 
     * @type {number}
     * @memberof NatureBattleStylePreference
     */
    high_hp_preference: number;
    /**
     * 
     * @type {MoveBattleStyleSummary}
     * @memberof NatureBattleStylePreference
     */
    move_battle_style: MoveBattleStyleSummary;
}

/**
 * 
 * @export
 */
export type NatureDetail = {
    /**
     * 
     * @type {number}
     * @memberof NatureDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof NatureDetail
     */
    name: string;
    /**
     * 
     * @type {StatSummary}
     * @memberof NatureDetail
     */
    decreased_stat: StatSummary;
    /**
     * 
     * @type {StatSummary}
     * @memberof NatureDetail
     */
    increased_stat: StatSummary;
    /**
     * 
     * @type {BerryFlavorSummary}
     * @memberof NatureDetail
     */
    likes_flavor: BerryFlavorSummary;
    /**
     * 
     * @type {BerryFlavorSummary}
     * @memberof NatureDetail
     */
    hates_flavor: BerryFlavorSummary;
    /**
     * 
     * @type {Array<BerrySummary>}
     * @memberof NatureDetail
     */
    berries: Array<BerrySummary>;
    /**
     * 
     * @type {Array<NatureDetailPokeathlonStatChangesInner>}
     * @memberof NatureDetail
     */
    pokeathlon_stat_changes: Array<NatureDetailPokeathlonStatChangesInner>;
    /**
     * 
     * @type {Array<NatureBattleStylePreference>}
     * @memberof NatureDetail
     */
    move_battle_style_preferences: Array<NatureBattleStylePreference>;
    /**
     * 
     * @type {Array<NatureName>}
     * @memberof NatureDetail
     */
    names: Array<NatureName>;
}

/**
 * 
 * @export
 */
export type NatureDetailPokeathlonStatChangesInner = {
    /**
     * 
     * @type {number}
     * @memberof NatureDetailPokeathlonStatChangesInner
     */
    max_change: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof NatureDetailPokeathlonStatChangesInner
     */
    pokeathlon_stat: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type NatureName = {
    /**
     * 
     * @type {string}
     * @memberof NatureName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof NatureName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type NatureSummary = {
    /**
     * 
     * @type {string}
     * @memberof NatureSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof NatureSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PaginatedAbilitySummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedAbilitySummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAbilitySummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedAbilitySummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<AbilitySummary>}
     * @memberof PaginatedAbilitySummaryList
     */
    results?: Array<AbilitySummary>;
}

/**
 * 
 * @export
 */
export type PaginatedBerryFirmnessSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBerryFirmnessSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBerryFirmnessSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBerryFirmnessSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<BerryFirmnessSummary>}
     * @memberof PaginatedBerryFirmnessSummaryList
     */
    results?: Array<BerryFirmnessSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedBerryFlavorSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBerryFlavorSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBerryFlavorSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBerryFlavorSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<BerryFlavorSummary>}
     * @memberof PaginatedBerryFlavorSummaryList
     */
    results?: Array<BerryFlavorSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedBerrySummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedBerrySummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBerrySummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedBerrySummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<BerrySummary>}
     * @memberof PaginatedBerrySummaryList
     */
    results?: Array<BerrySummary>;
}

/**
 * 
 * @export
 */
export type PaginatedCharacteristicSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedCharacteristicSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacteristicSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedCharacteristicSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<CharacteristicSummary>}
     * @memberof PaginatedCharacteristicSummaryList
     */
    results?: Array<CharacteristicSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedContestEffectSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedContestEffectSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedContestEffectSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedContestEffectSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<ContestEffectSummary>}
     * @memberof PaginatedContestEffectSummaryList
     */
    results?: Array<ContestEffectSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedContestTypeSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedContestTypeSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedContestTypeSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedContestTypeSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<ContestTypeSummary>}
     * @memberof PaginatedContestTypeSummaryList
     */
    results?: Array<ContestTypeSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedEggGroupSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEggGroupSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEggGroupSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEggGroupSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<EggGroupSummary>}
     * @memberof PaginatedEggGroupSummaryList
     */
    results?: Array<EggGroupSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedEncounterConditionSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEncounterConditionSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEncounterConditionSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEncounterConditionSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<EncounterConditionSummary>}
     * @memberof PaginatedEncounterConditionSummaryList
     */
    results?: Array<EncounterConditionSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedEncounterConditionValueSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEncounterConditionValueSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEncounterConditionValueSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEncounterConditionValueSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<EncounterConditionValueSummary>}
     * @memberof PaginatedEncounterConditionValueSummaryList
     */
    results?: Array<EncounterConditionValueSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedEncounterMethodSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEncounterMethodSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEncounterMethodSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEncounterMethodSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<EncounterMethodSummary>}
     * @memberof PaginatedEncounterMethodSummaryList
     */
    results?: Array<EncounterMethodSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedEvolutionChainSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEvolutionChainSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEvolutionChainSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEvolutionChainSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<EvolutionChainSummary>}
     * @memberof PaginatedEvolutionChainSummaryList
     */
    results?: Array<EvolutionChainSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedEvolutionTriggerSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedEvolutionTriggerSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEvolutionTriggerSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedEvolutionTriggerSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<EvolutionTriggerSummary>}
     * @memberof PaginatedEvolutionTriggerSummaryList
     */
    results?: Array<EvolutionTriggerSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedGenderSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGenderSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGenderSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGenderSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<GenderSummary>}
     * @memberof PaginatedGenderSummaryList
     */
    results?: Array<GenderSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedGenerationSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGenerationSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGenerationSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGenerationSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<GenerationSummary>}
     * @memberof PaginatedGenerationSummaryList
     */
    results?: Array<GenerationSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedGrowthRateSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedGrowthRateSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGrowthRateSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedGrowthRateSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<GrowthRateSummary>}
     * @memberof PaginatedGrowthRateSummaryList
     */
    results?: Array<GrowthRateSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedItemAttributeSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedItemAttributeSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemAttributeSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemAttributeSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<ItemAttributeSummary>}
     * @memberof PaginatedItemAttributeSummaryList
     */
    results?: Array<ItemAttributeSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedItemCategorySummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedItemCategorySummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemCategorySummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemCategorySummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<ItemCategorySummary>}
     * @memberof PaginatedItemCategorySummaryList
     */
    results?: Array<ItemCategorySummary>;
}

/**
 * 
 * @export
 */
export type PaginatedItemFlingEffectSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedItemFlingEffectSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemFlingEffectSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemFlingEffectSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<ItemFlingEffectSummary>}
     * @memberof PaginatedItemFlingEffectSummaryList
     */
    results?: Array<ItemFlingEffectSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedItemPocketSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedItemPocketSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemPocketSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemPocketSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<ItemPocketSummary>}
     * @memberof PaginatedItemPocketSummaryList
     */
    results?: Array<ItemPocketSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedItemSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedItemSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedItemSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<ItemSummary>}
     * @memberof PaginatedItemSummaryList
     */
    results?: Array<ItemSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedLanguageSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLanguageSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLanguageSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLanguageSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<LanguageSummary>}
     * @memberof PaginatedLanguageSummaryList
     */
    results?: Array<LanguageSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedLocationAreaSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLocationAreaSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLocationAreaSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLocationAreaSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<LocationAreaSummary>}
     * @memberof PaginatedLocationAreaSummaryList
     */
    results?: Array<LocationAreaSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedLocationSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedLocationSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLocationSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedLocationSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<LocationSummary>}
     * @memberof PaginatedLocationSummaryList
     */
    results?: Array<LocationSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedMachineSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMachineSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMachineSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMachineSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<MachineSummary>}
     * @memberof PaginatedMachineSummaryList
     */
    results?: Array<MachineSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedMoveBattleStyleSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMoveBattleStyleSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveBattleStyleSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveBattleStyleSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<MoveBattleStyleSummary>}
     * @memberof PaginatedMoveBattleStyleSummaryList
     */
    results?: Array<MoveBattleStyleSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedMoveDamageClassSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMoveDamageClassSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveDamageClassSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveDamageClassSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<MoveDamageClassSummary>}
     * @memberof PaginatedMoveDamageClassSummaryList
     */
    results?: Array<MoveDamageClassSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedMoveLearnMethodSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMoveLearnMethodSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveLearnMethodSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveLearnMethodSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<MoveLearnMethodSummary>}
     * @memberof PaginatedMoveLearnMethodSummaryList
     */
    results?: Array<MoveLearnMethodSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedMoveMetaAilmentSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMoveMetaAilmentSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveMetaAilmentSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveMetaAilmentSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<MoveMetaAilmentSummary>}
     * @memberof PaginatedMoveMetaAilmentSummaryList
     */
    results?: Array<MoveMetaAilmentSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedMoveMetaCategorySummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMoveMetaCategorySummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveMetaCategorySummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveMetaCategorySummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<MoveMetaCategorySummary>}
     * @memberof PaginatedMoveMetaCategorySummaryList
     */
    results?: Array<MoveMetaCategorySummary>;
}

/**
 * 
 * @export
 */
export type PaginatedMoveSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMoveSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<MoveSummary>}
     * @memberof PaginatedMoveSummaryList
     */
    results?: Array<MoveSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedMoveTargetSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedMoveTargetSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveTargetSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedMoveTargetSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<MoveTargetSummary>}
     * @memberof PaginatedMoveTargetSummaryList
     */
    results?: Array<MoveTargetSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedNatureSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedNatureSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNatureSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedNatureSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<NatureSummary>}
     * @memberof PaginatedNatureSummaryList
     */
    results?: Array<NatureSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPalParkAreaSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPalParkAreaSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPalParkAreaSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPalParkAreaSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PalParkAreaSummary>}
     * @memberof PaginatedPalParkAreaSummaryList
     */
    results?: Array<PalParkAreaSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPokeathlonStatSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPokeathlonStatSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokeathlonStatSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokeathlonStatSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PokeathlonStatSummary>}
     * @memberof PaginatedPokeathlonStatSummaryList
     */
    results?: Array<PokeathlonStatSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPokedexSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPokedexSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokedexSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokedexSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PokedexSummary>}
     * @memberof PaginatedPokedexSummaryList
     */
    results?: Array<PokedexSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPokemonColorSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPokemonColorSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonColorSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonColorSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PokemonColorSummary>}
     * @memberof PaginatedPokemonColorSummaryList
     */
    results?: Array<PokemonColorSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPokemonFormSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPokemonFormSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonFormSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonFormSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PokemonFormSummary>}
     * @memberof PaginatedPokemonFormSummaryList
     */
    results?: Array<PokemonFormSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPokemonHabitatSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPokemonHabitatSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonHabitatSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonHabitatSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PokemonHabitatSummary>}
     * @memberof PaginatedPokemonHabitatSummaryList
     */
    results?: Array<PokemonHabitatSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPokemonShapeSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPokemonShapeSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonShapeSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonShapeSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PokemonShapeSummary>}
     * @memberof PaginatedPokemonShapeSummaryList
     */
    results?: Array<PokemonShapeSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPokemonSpeciesSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPokemonSpeciesSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonSpeciesSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonSpeciesSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PokemonSpeciesSummary>}
     * @memberof PaginatedPokemonSpeciesSummaryList
     */
    results?: Array<PokemonSpeciesSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedPokemonSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedPokemonSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedPokemonSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<PokemonSummary>}
     * @memberof PaginatedPokemonSummaryList
     */
    results?: Array<PokemonSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedRegionSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedRegionSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRegionSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedRegionSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<RegionSummary>}
     * @memberof PaginatedRegionSummaryList
     */
    results?: Array<RegionSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedStatSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedStatSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStatSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedStatSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<StatSummary>}
     * @memberof PaginatedStatSummaryList
     */
    results?: Array<StatSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedSuperContestEffectSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedSuperContestEffectSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSuperContestEffectSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedSuperContestEffectSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<SuperContestEffectSummary>}
     * @memberof PaginatedSuperContestEffectSummaryList
     */
    results?: Array<SuperContestEffectSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedTypeSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedTypeSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTypeSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedTypeSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<TypeSummary>}
     * @memberof PaginatedTypeSummaryList
     */
    results?: Array<TypeSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedVersionGroupSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedVersionGroupSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVersionGroupSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVersionGroupSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<VersionGroupSummary>}
     * @memberof PaginatedVersionGroupSummaryList
     */
    results?: Array<VersionGroupSummary>;
}

/**
 * 
 * @export
 */
export type PaginatedVersionSummaryList = {
    /**
     * 
     * @type {number}
     * @memberof PaginatedVersionSummaryList
     */
    count?: number;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVersionSummaryList
     */
    next?: string;
    /**
     * 
     * @type {string}
     * @memberof PaginatedVersionSummaryList
     */
    previous?: string;
    /**
     * 
     * @type {Array<VersionSummary>}
     * @memberof PaginatedVersionSummaryList
     */
    results?: Array<VersionSummary>;
}

/**
 * 
 * @export
 */
export type PalParkAreaDetail = {
    /**
     * 
     * @type {number}
     * @memberof PalParkAreaDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PalParkAreaDetail
     */
    name: string;
    /**
     * 
     * @type {Array<PalParkAreaName>}
     * @memberof PalParkAreaDetail
     */
    names: Array<PalParkAreaName>;
    /**
     * 
     * @type {Array<PalParkAreaDetailPokemonEncountersInner>}
     * @memberof PalParkAreaDetail
     */
    pokemon_encounters: Array<PalParkAreaDetailPokemonEncountersInner>;
}

/**
 * 
 * @export
 */
export type PalParkAreaDetailPokemonEncountersInner = {
    /**
     * 
     * @type {number}
     * @memberof PalParkAreaDetailPokemonEncountersInner
     */
    base_score: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PalParkAreaDetailPokemonEncountersInner
     */
    pokemon_species: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {number}
     * @memberof PalParkAreaDetailPokemonEncountersInner
     */
    rate: number;
}

/**
 * 
 * @export
 */
export type PalParkAreaName = {
    /**
     * 
     * @type {string}
     * @memberof PalParkAreaName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof PalParkAreaName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type PalParkAreaSummary = {
    /**
     * 
     * @type {string}
     * @memberof PalParkAreaSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PalParkAreaSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PokeathlonStatDetail = {
    /**
     * 
     * @type {number}
     * @memberof PokeathlonStatDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PokeathlonStatDetail
     */
    name: string;
    /**
     * 
     * @type {PokeathlonStatDetailAffectingNatures}
     * @memberof PokeathlonStatDetail
     */
    affecting_natures: PokeathlonStatDetailAffectingNatures;
    /**
     * 
     * @type {Array<PokeathlonStatName>}
     * @memberof PokeathlonStatDetail
     */
    names: Array<PokeathlonStatName>;
}

/**
 * 
 * @export
 */
export type PokeathlonStatDetailAffectingNatures = {
    /**
     * 
     * @type {Array<PokeathlonStatDetailAffectingNaturesDecreaseInner>}
     * @memberof PokeathlonStatDetailAffectingNatures
     */
    decrease: Array<PokeathlonStatDetailAffectingNaturesDecreaseInner>;
    /**
     * 
     * @type {Array<PokeathlonStatDetailAffectingNaturesIncreaseInner>}
     * @memberof PokeathlonStatDetailAffectingNatures
     */
    increase: Array<PokeathlonStatDetailAffectingNaturesIncreaseInner>;
}

/**
 * 
 * @export
 */
export type PokeathlonStatDetailAffectingNaturesDecreaseInner = {
    /**
     * 
     * @type {number}
     * @memberof PokeathlonStatDetailAffectingNaturesDecreaseInner
     */
    max_change: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokeathlonStatDetailAffectingNaturesDecreaseInner
     */
    nature: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokeathlonStatDetailAffectingNaturesIncreaseInner = {
    /**
     * 
     * @type {number}
     * @memberof PokeathlonStatDetailAffectingNaturesIncreaseInner
     */
    max_change: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokeathlonStatDetailAffectingNaturesIncreaseInner
     */
    nature: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokeathlonStatName = {
    /**
     * 
     * @type {string}
     * @memberof PokeathlonStatName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof PokeathlonStatName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type PokeathlonStatSummary = {
    /**
     * 
     * @type {string}
     * @memberof PokeathlonStatSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PokeathlonStatSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PokedexDescription = {
    /**
     * 
     * @type {string}
     * @memberof PokedexDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof PokedexDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type PokedexDetail = {
    /**
     * 
     * @type {number}
     * @memberof PokedexDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PokedexDetail
     */
    name: string;
    /**
     * 
     * @type {boolean}
     * @memberof PokedexDetail
     */
    is_main_series?: boolean;
    /**
     * 
     * @type {Array<PokedexDescription>}
     * @memberof PokedexDetail
     */
    descriptions: Array<PokedexDescription>;
    /**
     * 
     * @type {Array<PokedexName>}
     * @memberof PokedexDetail
     */
    names: Array<PokedexName>;
    /**
     * 
     * @type {Array<PokedexDetailPokemonEntriesInner>}
     * @memberof PokedexDetail
     */
    pokemon_entries: Array<PokedexDetailPokemonEntriesInner>;
    /**
     * 
     * @type {RegionSummary}
     * @memberof PokedexDetail
     */
    region: RegionSummary;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof PokedexDetail
     */
    version_groups: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type PokedexDetailPokemonEntriesInner = {
    /**
     * 
     * @type {number}
     * @memberof PokedexDetailPokemonEntriesInner
     */
    entry_number: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokedexDetailPokemonEntriesInner
     */
    pokemon_species: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokedexName = {
    /**
     * 
     * @type {string}
     * @memberof PokedexName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof PokedexName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type PokedexSummary = {
    /**
     * 
     * @type {string}
     * @memberof PokedexSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PokedexSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PokemonColorDetail = {
    /**
     * 
     * @type {number}
     * @memberof PokemonColorDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PokemonColorDetail
     */
    name: string;
    /**
     * 
     * @type {Array<PokemonColorName>}
     * @memberof PokemonColorDetail
     */
    names: Array<PokemonColorName>;
    /**
     * 
     * @type {Array<PokemonSpeciesSummary>}
     * @memberof PokemonColorDetail
     */
    pokemon_species: Array<PokemonSpeciesSummary>;
}

/**
 * 
 * @export
 */
export type PokemonColorName = {
    /**
     * 
     * @type {string}
     * @memberof PokemonColorName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof PokemonColorName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type PokemonColorSummary = {
    /**
     * 
     * @type {string}
     * @memberof PokemonColorSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PokemonColorSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PokemonDetail = {
    /**
     * 
     * @type {number}
     * @memberof PokemonDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PokemonDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof PokemonDetail
     */
    base_experience?: number;
    /**
     * 
     * @type {number}
     * @memberof PokemonDetail
     */
    height?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonDetail
     */
    is_default?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PokemonDetail
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof PokemonDetail
     */
    weight?: number;
    /**
     * 
     * @type {Array<PokemonDetailAbilitiesInner>}
     * @memberof PokemonDetail
     */
    abilities: Array<PokemonDetailAbilitiesInner>;
    /**
     * 
     * @type {Array<PokemonDetailPastAbilitiesInner>}
     * @memberof PokemonDetail
     */
    past_abilities: Array<PokemonDetailPastAbilitiesInner>;
    /**
     * 
     * @type {Array<PokemonFormSummary>}
     * @memberof PokemonDetail
     */
    forms: Array<PokemonFormSummary>;
    /**
     * 
     * @type {Array<PokemonGameIndex>}
     * @memberof PokemonDetail
     */
    game_indices: Array<PokemonGameIndex>;
    /**
     * 
     * @type {PokemonDetailHeldItems}
     * @memberof PokemonDetail
     */
    held_items: PokemonDetailHeldItems;
    /**
     * 
     * @type {string}
     * @memberof PokemonDetail
     */
    location_area_encounters: string;
    /**
     * 
     * @type {Array<PokemonDetailMovesInner>}
     * @memberof PokemonDetail
     */
    moves: Array<PokemonDetailMovesInner>;
    /**
     * 
     * @type {PokemonSpeciesSummary}
     * @memberof PokemonDetail
     */
    species: PokemonSpeciesSummary;
    /**
     * 
     * @type {PokemonDetailSprites}
     * @memberof PokemonDetail
     */
    sprites: PokemonDetailSprites;
    /**
     * 
     * @type {PokemonDetailCries}
     * @memberof PokemonDetail
     */
    cries: PokemonDetailCries;
    /**
     * 
     * @type {Array<PokemonStat>}
     * @memberof PokemonDetail
     */
    stats: Array<PokemonStat>;
    /**
     * 
     * @type {Array<PokemonDetailTypesInner>}
     * @memberof PokemonDetail
     */
    types: Array<PokemonDetailTypesInner>;
    /**
     * 
     * @type {Array<PokemonDetailPastTypesInner>}
     * @memberof PokemonDetail
     */
    past_types: Array<PokemonDetailPastTypesInner>;
}

/**
 * 
 * @export
 */
export type PokemonDetailAbilitiesInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonDetailAbilitiesInner
     */
    ability: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonDetailAbilitiesInner
     */
    is_hidden: boolean;
    /**
     * 
     * @type {number}
     * @memberof PokemonDetailAbilitiesInner
     */
    slot: number;
}

/**
 * 
 * @export
 */
export type PokemonDetailCries = {
    /**
     * 
     * @type {string}
     * @memberof PokemonDetailCries
     */
    latest: string;
    /**
     * 
     * @type {string}
     * @memberof PokemonDetailCries
     */
    legacy: string;
}

/**
 * 
 * @export
 */
export type PokemonDetailHeldItems = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonDetailHeldItems
     */
    item: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {Array<ItemDetailHeldByPokemonInnerVersionDetailsInner>}
     * @memberof PokemonDetailHeldItems
     */
    version_details: Array<ItemDetailHeldByPokemonInnerVersionDetailsInner>;
}

/**
 * 
 * @export
 */
export type PokemonDetailMovesInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonDetailMovesInner
     */
    move: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {Array<PokemonDetailMovesInnerVersionGroupDetailsInner>}
     * @memberof PokemonDetailMovesInner
     */
    version_group_details: Array<PokemonDetailMovesInnerVersionGroupDetailsInner>;
}

/**
 * 
 * @export
 */
export type PokemonDetailMovesInnerVersionGroupDetailsInner = {
    /**
     * 
     * @type {number}
     * @memberof PokemonDetailMovesInnerVersionGroupDetailsInner
     */
    level_learned_at: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonDetailMovesInnerVersionGroupDetailsInner
     */
    move_learn_method: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonDetailMovesInnerVersionGroupDetailsInner
     */
    version_group: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokemonDetailPastAbilitiesInner = {
    /**
     * 
     * @type {Array<PokemonDetailAbilitiesInner>}
     * @memberof PokemonDetailPastAbilitiesInner
     */
    abilities: Array<PokemonDetailAbilitiesInner>;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonDetailPastAbilitiesInner
     */
    generation: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokemonDetailPastTypesInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonDetailPastTypesInner
     */
    generation: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {Array<PokemonDetailTypesInner>}
     * @memberof PokemonDetailPastTypesInner
     */
    types: Array<PokemonDetailTypesInner>;
}

/**
 * 
 * @export
 */
export type PokemonDetailSprites = {
    [key: string]: string | any;

    /**
     * 
     * @type {string}
     * @memberof PokemonDetailSprites
     */
    front_default?: string;
}

/**
 * 
 * @export
 */
export type PokemonDetailTypesInner = {
    /**
     * 
     * @type {number}
     * @memberof PokemonDetailTypesInner
     */
    slot: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonDetailTypesInner
     */
    type: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokemonDexEntry = {
    /**
     * 
     * @type {number}
     * @memberof PokemonDexEntry
     */
    entry_number: number;
    /**
     * 
     * @type {PokedexSummary}
     * @memberof PokemonDexEntry
     */
    pokedex: PokedexSummary;
}

/**
 * 
 * @export
 */
export type PokemonFormDetail = {
    /**
     * 
     * @type {number}
     * @memberof PokemonFormDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PokemonFormDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof PokemonFormDetail
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof PokemonFormDetail
     */
    form_order?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonFormDetail
     */
    is_default?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonFormDetail
     */
    is_battle_only?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonFormDetail
     */
    is_mega?: boolean;
    /**
     * 
     * @type {string}
     * @memberof PokemonFormDetail
     */
    form_name: string;
    /**
     * 
     * @type {PokemonSummary}
     * @memberof PokemonFormDetail
     */
    pokemon: PokemonSummary;
    /**
     * 
     * @type {PokemonFormDetailSprites}
     * @memberof PokemonFormDetail
     */
    sprites: PokemonFormDetailSprites;
    /**
     * 
     * @type {VersionGroupSummary}
     * @memberof PokemonFormDetail
     */
    version_group: VersionGroupSummary;
    /**
     * 
     * @type {Array<PokemonFormDetailFormNamesInner>}
     * @memberof PokemonFormDetail
     */
    form_names: Array<PokemonFormDetailFormNamesInner>;
    /**
     * 
     * @type {Array<PokemonFormDetailFormNamesInner>}
     * @memberof PokemonFormDetail
     */
    names: Array<PokemonFormDetailFormNamesInner>;
    /**
     * 
     * @type {Array<PokemonDetailTypesInner>}
     * @memberof PokemonFormDetail
     */
    types: Array<PokemonDetailTypesInner>;
}

/**
 * 
 * @export
 */
export type PokemonFormDetailFormNamesInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonFormDetailFormNamesInner
     */
    language: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {string}
     * @memberof PokemonFormDetailFormNamesInner
     */
    name: string;
}

/**
 * 
 * @export
 */
export type PokemonFormDetailSprites = {
    [key: string]: string | any;

    /**
     * 
     * @type {string}
     * @memberof PokemonFormDetailSprites
     */
    _default?: string;
}

/**
 * 
 * @export
 */
export type PokemonFormSummary = {
    /**
     * 
     * @type {string}
     * @memberof PokemonFormSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PokemonFormSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PokemonGameIndex = {
    /**
     * 
     * @type {number}
     * @memberof PokemonGameIndex
     */
    game_index: number;
    /**
     * 
     * @type {VersionSummary}
     * @memberof PokemonGameIndex
     */
    version: VersionSummary;
}

/**
 * 
 * @export
 */
export type PokemonHabitatDetail = {
    /**
     * 
     * @type {number}
     * @memberof PokemonHabitatDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PokemonHabitatDetail
     */
    name: string;
    /**
     * 
     * @type {Array<PokemonHabitatName>}
     * @memberof PokemonHabitatDetail
     */
    names: Array<PokemonHabitatName>;
    /**
     * 
     * @type {Array<PokemonSpeciesSummary>}
     * @memberof PokemonHabitatDetail
     */
    pokemon_species: Array<PokemonSpeciesSummary>;
}

/**
 * 
 * @export
 */
export type PokemonHabitatName = {
    /**
     * 
     * @type {string}
     * @memberof PokemonHabitatName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof PokemonHabitatName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type PokemonHabitatSummary = {
    /**
     * 
     * @type {string}
     * @memberof PokemonHabitatSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PokemonHabitatSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PokemonShapeDetail = {
    /**
     * 
     * @type {number}
     * @memberof PokemonShapeDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PokemonShapeDetail
     */
    name: string;
    /**
     * 
     * @type {Array<PokemonShapeDetailAwesomeNamesInner>}
     * @memberof PokemonShapeDetail
     */
    awesome_names: Array<PokemonShapeDetailAwesomeNamesInner>;
    /**
     * 
     * @type {Array<PokemonShapeDetailNamesInner>}
     * @memberof PokemonShapeDetail
     */
    names: Array<PokemonShapeDetailNamesInner>;
    /**
     * 
     * @type {Array<PokemonSpeciesSummary>}
     * @memberof PokemonShapeDetail
     */
    pokemon_species: Array<PokemonSpeciesSummary>;
}

/**
 * 
 * @export
 */
export type PokemonShapeDetailAwesomeNamesInner = {
    /**
     * 
     * @type {string}
     * @memberof PokemonShapeDetailAwesomeNamesInner
     */
    awesome_name: string;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonShapeDetailAwesomeNamesInner
     */
    language: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokemonShapeDetailNamesInner = {
    /**
     * 
     * @type {string}
     * @memberof PokemonShapeDetailNamesInner
     */
    url: string;
    /**
     * 
     * @type {string}
     * @memberof PokemonShapeDetailNamesInner
     */
    name: string;
}

/**
 * 
 * @export
 */
export type PokemonShapeSummary = {
    /**
     * 
     * @type {string}
     * @memberof PokemonShapeSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PokemonShapeSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PokemonSpeciesDescription = {
    /**
     * 
     * @type {string}
     * @memberof PokemonSpeciesDescription
     */
    description?: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof PokemonSpeciesDescription
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type PokemonSpeciesDetail = {
    /**
     * 
     * @type {number}
     * @memberof PokemonSpeciesDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof PokemonSpeciesDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof PokemonSpeciesDetail
     */
    order?: number;
    /**
     * 
     * @type {number}
     * @memberof PokemonSpeciesDetail
     */
    gender_rate?: number;
    /**
     * 
     * @type {number}
     * @memberof PokemonSpeciesDetail
     */
    capture_rate?: number;
    /**
     * 
     * @type {number}
     * @memberof PokemonSpeciesDetail
     */
    base_happiness?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonSpeciesDetail
     */
    is_baby?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonSpeciesDetail
     */
    is_legendary?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonSpeciesDetail
     */
    is_mythical?: boolean;
    /**
     * 
     * @type {number}
     * @memberof PokemonSpeciesDetail
     */
    hatch_counter?: number;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonSpeciesDetail
     */
    has_gender_differences?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PokemonSpeciesDetail
     */
    forms_switchable?: boolean;
    /**
     * 
     * @type {GrowthRateSummary}
     * @memberof PokemonSpeciesDetail
     */
    growth_rate: GrowthRateSummary;
    /**
     * 
     * @type {Array<PokemonDexEntry>}
     * @memberof PokemonSpeciesDetail
     */
    pokedex_numbers: Array<PokemonDexEntry>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof PokemonSpeciesDetail
     */
    egg_groups: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {PokemonColorSummary}
     * @memberof PokemonSpeciesDetail
     */
    color: PokemonColorSummary;
    /**
     * 
     * @type {PokemonShapeSummary}
     * @memberof PokemonSpeciesDetail
     */
    shape: PokemonShapeSummary;
    /**
     * 
     * @type {PokemonSpeciesSummary}
     * @memberof PokemonSpeciesDetail
     */
    evolves_from_species: PokemonSpeciesSummary;
    /**
     * 
     * @type {EvolutionChainSummary}
     * @memberof PokemonSpeciesDetail
     */
    evolution_chain: EvolutionChainSummary;
    /**
     * 
     * @type {PokemonHabitatSummary}
     * @memberof PokemonSpeciesDetail
     */
    habitat: PokemonHabitatSummary;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof PokemonSpeciesDetail
     */
    generation: GenerationSummary;
    /**
     * 
     * @type {Array<PokemonFormDetailFormNamesInner>}
     * @memberof PokemonSpeciesDetail
     */
    names: Array<PokemonFormDetailFormNamesInner>;
    /**
     * 
     * @type {Array<PokemonSpeciesDetailPalParkEncountersInner>}
     * @memberof PokemonSpeciesDetail
     */
    pal_park_encounters: Array<PokemonSpeciesDetailPalParkEncountersInner>;
    /**
     * 
     * @type {Array<PokemonSpeciesDescription>}
     * @memberof PokemonSpeciesDetail
     */
    form_descriptions: Array<PokemonSpeciesDescription>;
    /**
     * 
     * @type {Array<PokemonSpeciesFlavorText>}
     * @memberof PokemonSpeciesDetail
     */
    flavor_text_entries: Array<PokemonSpeciesFlavorText>;
    /**
     * 
     * @type {Array<PokemonSpeciesDetailGeneraInner>}
     * @memberof PokemonSpeciesDetail
     */
    genera: Array<PokemonSpeciesDetailGeneraInner>;
    /**
     * 
     * @type {Array<PokemonSpeciesDetailVarietiesInner>}
     * @memberof PokemonSpeciesDetail
     */
    varieties: Array<PokemonSpeciesDetailVarietiesInner>;
}

/**
 * 
 * @export
 */
export type PokemonSpeciesDetailGeneraInner = {
    /**
     * 
     * @type {string}
     * @memberof PokemonSpeciesDetailGeneraInner
     */
    genus: string;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonSpeciesDetailGeneraInner
     */
    language: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokemonSpeciesDetailPalParkEncountersInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonSpeciesDetailPalParkEncountersInner
     */
    area: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {number}
     * @memberof PokemonSpeciesDetailPalParkEncountersInner
     */
    base_score: number;
    /**
     * 
     * @type {number}
     * @memberof PokemonSpeciesDetailPalParkEncountersInner
     */
    rate: number;
}

/**
 * 
 * @export
 */
export type PokemonSpeciesDetailVarietiesInner = {
    /**
     * 
     * @type {boolean}
     * @memberof PokemonSpeciesDetailVarietiesInner
     */
    is_default: boolean;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof PokemonSpeciesDetailVarietiesInner
     */
    pokemon: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type PokemonSpeciesFlavorText = {
    /**
     * 
     * @type {string}
     * @memberof PokemonSpeciesFlavorText
     */
    flavor_text: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof PokemonSpeciesFlavorText
     */
    language: LanguageSummary;
    /**
     * 
     * @type {VersionSummary}
     * @memberof PokemonSpeciesFlavorText
     */
    version: VersionSummary;
}

/**
 * 
 * @export
 */
export type PokemonSpeciesSummary = {
    /**
     * 
     * @type {string}
     * @memberof PokemonSpeciesSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PokemonSpeciesSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type PokemonStat = {
    /**
     * 
     * @type {number}
     * @memberof PokemonStat
     */
    base_stat: number;
    /**
     * 
     * @type {number}
     * @memberof PokemonStat
     */
    effort: number;
    /**
     * 
     * @type {StatSummary}
     * @memberof PokemonStat
     */
    stat: StatSummary;
}

/**
 * 
 * @export
 */
export type PokemonSummary = {
    /**
     * 
     * @type {string}
     * @memberof PokemonSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof PokemonSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type RegionDetail = {
    /**
     * 
     * @type {number}
     * @memberof RegionDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof RegionDetail
     */
    name: string;
    /**
     * 
     * @type {Array<LocationSummary>}
     * @memberof RegionDetail
     */
    locations: Array<LocationSummary>;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof RegionDetail
     */
    main_generation: GenerationSummary;
    /**
     * 
     * @type {Array<RegionName>}
     * @memberof RegionDetail
     */
    names: Array<RegionName>;
    /**
     * 
     * @type {Array<PokedexSummary>}
     * @memberof RegionDetail
     */
    pokedexes: Array<PokedexSummary>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof RegionDetail
     */
    version_groups: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type RegionName = {
    /**
     * 
     * @type {string}
     * @memberof RegionName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof RegionName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type RegionSummary = {
    /**
     * 
     * @type {string}
     * @memberof RegionSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof RegionSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type StatDetail = {
    /**
     * 
     * @type {number}
     * @memberof StatDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof StatDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof StatDetail
     */
    game_index: number;
    /**
     * 
     * @type {boolean}
     * @memberof StatDetail
     */
    is_battle_only?: boolean;
    /**
     * 
     * @type {StatDetailAffectingMoves}
     * @memberof StatDetail
     */
    affecting_moves: StatDetailAffectingMoves;
    /**
     * 
     * @type {StatDetailAffectingNatures}
     * @memberof StatDetail
     */
    affecting_natures: StatDetailAffectingNatures;
    /**
     * 
     * @type {Array<CharacteristicSummary>}
     * @memberof StatDetail
     */
    characteristics: Array<CharacteristicSummary>;
    /**
     * 
     * @type {MoveDamageClassSummary}
     * @memberof StatDetail
     */
    move_damage_class: MoveDamageClassSummary;
    /**
     * 
     * @type {Array<StatName>}
     * @memberof StatDetail
     */
    names: Array<StatName>;
}

/**
 * 
 * @export
 */
export type StatDetailAffectingMoves = {
    /**
     * 
     * @type {Array<StatDetailAffectingMovesIncreaseInner>}
     * @memberof StatDetailAffectingMoves
     */
    increase: Array<StatDetailAffectingMovesIncreaseInner>;
    /**
     * 
     * @type {Array<StatDetailAffectingMovesIncreaseInner>}
     * @memberof StatDetailAffectingMoves
     */
    decrease: Array<StatDetailAffectingMovesIncreaseInner>;
}

/**
 * 
 * @export
 */
export type StatDetailAffectingMovesIncreaseInner = {
    /**
     * 
     * @type {number}
     * @memberof StatDetailAffectingMovesIncreaseInner
     */
    change: number;
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof StatDetailAffectingMovesIncreaseInner
     */
    move: AbilityDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type StatDetailAffectingNatures = {
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof StatDetailAffectingNatures
     */
    increase: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof StatDetailAffectingNatures
     */
    decrease: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type StatName = {
    /**
     * 
     * @type {string}
     * @memberof StatName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof StatName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type StatSummary = {
    /**
     * 
     * @type {string}
     * @memberof StatSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof StatSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type SuperContestEffectDetail = {
    /**
     * 
     * @type {number}
     * @memberof SuperContestEffectDetail
     */
    id: number;
    /**
     * 
     * @type {number}
     * @memberof SuperContestEffectDetail
     */
    appeal: number;
    /**
     * 
     * @type {Array<SuperContestEffectFlavorText>}
     * @memberof SuperContestEffectDetail
     */
    flavor_text_entries: Array<SuperContestEffectFlavorText>;
    /**
     * 
     * @type {Array<MoveSummary>}
     * @memberof SuperContestEffectDetail
     */
    moves: Array<MoveSummary>;
}

/**
 * 
 * @export
 */
export type SuperContestEffectFlavorText = {
    /**
     * 
     * @type {string}
     * @memberof SuperContestEffectFlavorText
     */
    flavor_text: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof SuperContestEffectFlavorText
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type SuperContestEffectSummary = {
    /**
     * 
     * @type {string}
     * @memberof SuperContestEffectSummary
     */
    url: string;
}

/**
 * Serializer for the Type resource
 * @export
 */
export type TypeDetail = {
    /**
     * 
     * @type {number}
     * @memberof TypeDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof TypeDetail
     */
    name: string;
    /**
     * 
     * @type {TypeDetailDamageRelations}
     * @memberof TypeDetail
     */
    damage_relations: TypeDetailDamageRelations;
    /**
     * 
     * @type {Array<TypeDetailPastDamageRelationsInner>}
     * @memberof TypeDetail
     */
    past_damage_relations: Array<TypeDetailPastDamageRelationsInner>;
    /**
     * 
     * @type {Array<TypeGameIndex>}
     * @memberof TypeDetail
     */
    game_indices: Array<TypeGameIndex>;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof TypeDetail
     */
    generation: GenerationSummary;
    /**
     * 
     * @type {MoveDamageClassSummary}
     * @memberof TypeDetail
     */
    move_damage_class: MoveDamageClassSummary;
    /**
     * 
     * @type {Array<AbilityName>}
     * @memberof TypeDetail
     */
    names: Array<AbilityName>;
    /**
     * 
     * @type {Array<TypeDetailPokemonInner>}
     * @memberof TypeDetail
     */
    pokemon: Array<TypeDetailPokemonInner>;
    /**
     * 
     * @type {Array<MoveSummary>}
     * @memberof TypeDetail
     */
    moves: Array<MoveSummary>;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: TypeDetailSpritesValueValue; }; }}
     * @memberof TypeDetail
     */
    sprites: { [key: string]: { [key: string]: TypeDetailSpritesValueValue; }; };
}

/**
 * 
 * @export
 */
export type TypeDetailDamageRelations = {
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailDamageRelations
     */
    no_damage_to: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailDamageRelations
     */
    half_damage_to: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailDamageRelations
     */
    double_damage_to: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailDamageRelations
     */
    no_damage_from: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailDamageRelations
     */
    half_damage_from: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailDamageRelations
     */
    double_damage_from: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type TypeDetailPastDamageRelationsInner = {
    /**
     * 
     * @type {AbilityDetailPokemonInnerPokemon}
     * @memberof TypeDetailPastDamageRelationsInner
     */
    generation: AbilityDetailPokemonInnerPokemon;
    /**
     * 
     * @type {TypeDetailPastDamageRelationsInnerDamageRelations}
     * @memberof TypeDetailPastDamageRelationsInner
     */
    damage_relations: TypeDetailPastDamageRelationsInnerDamageRelations;
}

/**
 * 
 * @export
 */
export type TypeDetailPastDamageRelationsInnerDamageRelations = {
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailPastDamageRelationsInnerDamageRelations
     */
    no_damage_to: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailPastDamageRelationsInnerDamageRelations
     */
    half_damage_to: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailPastDamageRelationsInnerDamageRelations
     */
    double_damage_to: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailPastDamageRelationsInnerDamageRelations
     */
    no_damage_from: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailPastDamageRelationsInnerDamageRelations
     */
    half_damage_from: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof TypeDetailPastDamageRelationsInnerDamageRelations
     */
    double_damage_from: Array<AbilityDetailPokemonInnerPokemon>;
}

/**
 * 
 * @export
 */
export type TypeDetailPokemonInner = {
    /**
     * 
     * @type {number}
     * @memberof TypeDetailPokemonInner
     */
    slot?: number;
    /**
     * 
     * @type {TypeDetailPokemonInnerPokemon}
     * @memberof TypeDetailPokemonInner
     */
    pokemon?: TypeDetailPokemonInnerPokemon;
}

/**
 * 
 * @export
 */
export type TypeDetailPokemonInnerPokemon = {
    /**
     * The name of the pokemon
     * @type {string}
     * @memberof TypeDetailPokemonInnerPokemon
     */
    name?: string;
    /**
     * The URL to get more information about the pokemon
     * @type {string}
     * @memberof TypeDetailPokemonInnerPokemon
     */
    url?: string;
}

/**
 * 
 * @export
 */
export type TypeDetailSpritesValueValue = {
    /**
     * 
     * @type {string}
     * @memberof TypeDetailSpritesValueValue
     */
    name_icon?: string;
}

/**
 * 
 * @export
 */
export type TypeGameIndex = {
    /**
     * 
     * @type {number}
     * @memberof TypeGameIndex
     */
    game_index: number;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof TypeGameIndex
     */
    generation: GenerationSummary;
}

/**
 * 
 * @export
 */
export type TypeSummary = {
    /**
     * 
     * @type {string}
     * @memberof TypeSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof TypeSummary
     */
    url: string;
}

/**
 * Should have a link to Version Group info but the Circular dependency and compilation order fight eachother and I\'m not sure how to add anything other than a hyperlink
 * @export
 */
export type VersionDetail = {
    /**
     * 
     * @type {number}
     * @memberof VersionDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof VersionDetail
     */
    name: string;
    /**
     * 
     * @type {Array<VersionName>}
     * @memberof VersionDetail
     */
    names: Array<VersionName>;
    /**
     * 
     * @type {VersionGroupSummary}
     * @memberof VersionDetail
     */
    version_group: VersionGroupSummary;
}

/**
 * 
 * @export
 */
export type VersionGroupDetail = {
    /**
     * 
     * @type {number}
     * @memberof VersionGroupDetail
     */
    id: number;
    /**
     * 
     * @type {string}
     * @memberof VersionGroupDetail
     */
    name: string;
    /**
     * 
     * @type {number}
     * @memberof VersionGroupDetail
     */
    order?: number;
    /**
     * 
     * @type {GenerationSummary}
     * @memberof VersionGroupDetail
     */
    generation: GenerationSummary;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof VersionGroupDetail
     */
    move_learn_methods: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof VersionGroupDetail
     */
    pokedexes: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<AbilityDetailPokemonInnerPokemon>}
     * @memberof VersionGroupDetail
     */
    regions: Array<AbilityDetailPokemonInnerPokemon>;
    /**
     * 
     * @type {Array<VersionSummary>}
     * @memberof VersionGroupDetail
     */
    versions: Array<VersionSummary>;
}

/**
 * 
 * @export
 */
export type VersionGroupSummary = {
    /**
     * 
     * @type {string}
     * @memberof VersionGroupSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VersionGroupSummary
     */
    url: string;
}

/**
 * 
 * @export
 */
export type VersionName = {
    /**
     * 
     * @type {string}
     * @memberof VersionName
     */
    name: string;
    /**
     * 
     * @type {LanguageSummary}
     * @memberof VersionName
     */
    language: LanguageSummary;
}

/**
 * 
 * @export
 */
export type VersionSummary = {
    /**
     * 
     * @type {string}
     * @memberof VersionSummary
     */
    name: string;
    /**
     * 
     * @type {string}
     * @memberof VersionSummary
     */
    url: string;
}



/**
 * BerriesApi - fetch parameter creator
 * @export
 */
export const BerriesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
         * @summary List berry firmness
         * @throws {RequiredError}
         */
        berryFirmnessList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/berry-firmness/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
         * @summary Get berry by firmness
         * @throws {RequiredError}
         */
        berryFirmnessRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling berryFirmnessRetrieve.');
            }
            const localVarPath = `/api/v2/berry-firmness/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Flavors determine whether a Pokémon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
         * @summary List berry flavors
         * @throws {RequiredError}
         */
        berryFlavorList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/berry-flavor/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Flavors determine whether a Pokémon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
         * @summary Get berries by flavor
         * @throws {RequiredError}
         */
        berryFlavorRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling berryFlavorRetrieve.');
            }
            const localVarPath = `/api/v2/berry-flavor/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pokémon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
         * @summary List berries
         * @throws {RequiredError}
         */
        berryList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/berry/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pokémon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
         * @summary Get a berry
         * @throws {RequiredError}
         */
        berryRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling berryRetrieve.');
            }
            const localVarPath = `/api/v2/berry/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type BerriesApiType = { 
    berryFirmnessList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedBerryFirmnessSummaryList>,

    berryFirmnessRetrieve(id: string, options?: RequestOptions): Promise<BerryFirmnessDetail>,

    berryFlavorList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedBerryFlavorSummaryList>,

    berryFlavorRetrieve(id: string, options?: RequestOptions): Promise<BerryFlavorDetail>,

    berryList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedBerrySummaryList>,

    berryRetrieve(id: string, options?: RequestOptions): Promise<BerryDetail>,
}

/**
 * BerriesApi - factory function to inject configuration 
 * @export
 */
export const BerriesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): BerriesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
         * @summary List berry firmness
         * @throws {RequiredError}
         */
        berryFirmnessList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedBerryFirmnessSummaryList> {
            const localVarFetchArgs = BerriesApiFetchParamCreator(configuration).berryFirmnessList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Berries can be soft or hard. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Category:Berries_by_firmness) for greater detail.
         * @summary Get berry by firmness
         * @throws {RequiredError}
         */
        berryFirmnessRetrieve(id: string, options?: RequestOptions = {}): Promise<BerryFirmnessDetail> {
            const localVarFetchArgs = BerriesApiFetchParamCreator(configuration).berryFirmnessRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Flavors determine whether a Pokémon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
         * @summary List berry flavors
         * @throws {RequiredError}
         */
        berryFlavorList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedBerryFlavorSummaryList> {
            const localVarFetchArgs = BerriesApiFetchParamCreator(configuration).berryFlavorList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Flavors determine whether a Pokémon will benefit or suffer from eating a berry based on their **nature**. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Flavor) for greater detail.
         * @summary Get berries by flavor
         * @throws {RequiredError}
         */
        berryFlavorRetrieve(id: string, options?: RequestOptions = {}): Promise<BerryFlavorDetail> {
            const localVarFetchArgs = BerriesApiFetchParamCreator(configuration).berryFlavorRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pokémon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
         * @summary List berries
         * @throws {RequiredError}
         */
        berryList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedBerrySummaryList> {
            const localVarFetchArgs = BerriesApiFetchParamCreator(configuration).berryList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Berries are small fruits that can provide HP and status condition restoration, stat enhancement, and even damage negation when eaten by Pokémon. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Berry) for greater detail.
         * @summary Get a berry
         * @throws {RequiredError}
         */
        berryRetrieve(id: string, options?: RequestOptions = {}): Promise<BerryDetail> {
            const localVarFetchArgs = BerriesApiFetchParamCreator(configuration).berryRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ContestsApi - fetch parameter creator
 * @export
 */
export const ContestsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Contest effects refer to the effects of moves when used in contests.
         * @summary List contest effects
         * @throws {RequiredError}
         */
        contestEffectList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/contest-effect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Contest effects refer to the effects of moves when used in contests.
         * @summary Get contest effect
         * @throws {RequiredError}
         */
        contestEffectRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contestEffectRetrieve.');
            }
            const localVarPath = `/api/v2/contest-effect/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Contest types are categories judges used to weigh a Pokémon\'s condition in Pokémon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
         * @summary List contest types
         * @throws {RequiredError}
         */
        contestTypeList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/contest-type/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Contest types are categories judges used to weigh a Pokémon\'s condition in Pokémon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
         * @summary Get contest type
         * @throws {RequiredError}
         */
        contestTypeRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contestTypeRetrieve.');
            }
            const localVarPath = `/api/v2/contest-type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Super contest effects refer to the effects of moves when used in super contests.
         * @summary List super contest effects
         * @throws {RequiredError}
         */
        superContestEffectList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/super-contest-effect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Super contest effects refer to the effects of moves when used in super contests.
         * @summary Get super contest effect
         * @throws {RequiredError}
         */
        superContestEffectRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling superContestEffectRetrieve.');
            }
            const localVarPath = `/api/v2/super-contest-effect/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ContestsApiType = { 
    contestEffectList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedContestEffectSummaryList>,

    contestEffectRetrieve(id: string, options?: RequestOptions): Promise<ContestEffectDetail>,

    contestTypeList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedContestTypeSummaryList>,

    contestTypeRetrieve(id: string, options?: RequestOptions): Promise<ContestTypeDetail>,

    superContestEffectList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedSuperContestEffectSummaryList>,

    superContestEffectRetrieve(id: string, options?: RequestOptions): Promise<SuperContestEffectDetail>,
}

/**
 * ContestsApi - factory function to inject configuration 
 * @export
 */
export const ContestsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ContestsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Contest effects refer to the effects of moves when used in contests.
         * @summary List contest effects
         * @throws {RequiredError}
         */
        contestEffectList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedContestEffectSummaryList> {
            const localVarFetchArgs = ContestsApiFetchParamCreator(configuration).contestEffectList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Contest effects refer to the effects of moves when used in contests.
         * @summary Get contest effect
         * @throws {RequiredError}
         */
        contestEffectRetrieve(id: string, options?: RequestOptions = {}): Promise<ContestEffectDetail> {
            const localVarFetchArgs = ContestsApiFetchParamCreator(configuration).contestEffectRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Contest types are categories judges used to weigh a Pokémon\'s condition in Pokémon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
         * @summary List contest types
         * @throws {RequiredError}
         */
        contestTypeList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedContestTypeSummaryList> {
            const localVarFetchArgs = ContestsApiFetchParamCreator(configuration).contestTypeList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Contest types are categories judges used to weigh a Pokémon\'s condition in Pokémon contests. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Contest_condition) for greater detail.
         * @summary Get contest type
         * @throws {RequiredError}
         */
        contestTypeRetrieve(id: string, options?: RequestOptions = {}): Promise<ContestTypeDetail> {
            const localVarFetchArgs = ContestsApiFetchParamCreator(configuration).contestTypeRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Super contest effects refer to the effects of moves when used in super contests.
         * @summary List super contest effects
         * @throws {RequiredError}
         */
        superContestEffectList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedSuperContestEffectSummaryList> {
            const localVarFetchArgs = ContestsApiFetchParamCreator(configuration).superContestEffectList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Super contest effects refer to the effects of moves when used in super contests.
         * @summary Get super contest effect
         * @throws {RequiredError}
         */
        superContestEffectRetrieve(id: string, options?: RequestOptions = {}): Promise<SuperContestEffectDetail> {
            const localVarFetchArgs = ContestsApiFetchParamCreator(configuration).superContestEffectRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * EncountersApi - fetch parameter creator
 * @export
 */
export const EncountersApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
         * @summary List encounter conditions
         * @throws {RequiredError}
         */
        encounterConditionList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/encounter-condition/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
         * @summary Get encounter condition
         * @throws {RequiredError}
         */
        encounterConditionRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling encounterConditionRetrieve.');
            }
            const localVarPath = `/api/v2/encounter-condition/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
         * @summary List encounter condition values
         * @throws {RequiredError}
         */
        encounterConditionValueList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/encounter-condition-value/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
         * @summary Get encounter condition value
         * @throws {RequiredError}
         */
        encounterConditionValueRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling encounterConditionValueRetrieve.');
            }
            const localVarPath = `/api/v2/encounter-condition-value/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
         * @summary List encounter methods
         * @throws {RequiredError}
         */
        encounterMethodList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/encounter-method/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
         * @summary Get encounter method
         * @throws {RequiredError}
         */
        encounterMethodRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling encounterMethodRetrieve.');
            }
            const localVarPath = `/api/v2/encounter-method/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type EncountersApiType = { 
    encounterConditionList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedEncounterConditionSummaryList>,

    encounterConditionRetrieve(id: string, options?: RequestOptions): Promise<EncounterConditionDetail>,

    encounterConditionValueList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedEncounterConditionValueSummaryList>,

    encounterConditionValueRetrieve(id: string, options?: RequestOptions): Promise<EncounterConditionValueDetail>,

    encounterMethodList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedEncounterMethodSummaryList>,

    encounterMethodRetrieve(id: string, options?: RequestOptions): Promise<EncounterMethodDetail>,
}

/**
 * EncountersApi - factory function to inject configuration 
 * @export
 */
export const EncountersApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): EncountersApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
         * @summary List encounter conditions
         * @throws {RequiredError}
         */
        encounterConditionList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedEncounterConditionSummaryList> {
            const localVarFetchArgs = EncountersApiFetchParamCreator(configuration).encounterConditionList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Conditions which affect what pokemon might appear in the wild, e.g., day or night.
         * @summary Get encounter condition
         * @throws {RequiredError}
         */
        encounterConditionRetrieve(id: string, options?: RequestOptions = {}): Promise<EncounterConditionDetail> {
            const localVarFetchArgs = EncountersApiFetchParamCreator(configuration).encounterConditionRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
         * @summary List encounter condition values
         * @throws {RequiredError}
         */
        encounterConditionValueList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedEncounterConditionValueSummaryList> {
            const localVarFetchArgs = EncountersApiFetchParamCreator(configuration).encounterConditionValueList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Encounter condition values are the various states that an encounter condition can have, i.e., time of day can be either day or night.
         * @summary Get encounter condition value
         * @throws {RequiredError}
         */
        encounterConditionValueRetrieve(id: string, options?: RequestOptions = {}): Promise<EncounterConditionValueDetail> {
            const localVarFetchArgs = EncountersApiFetchParamCreator(configuration).encounterConditionValueRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
         * @summary List encounter methods
         * @throws {RequiredError}
         */
        encounterMethodList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedEncounterMethodSummaryList> {
            const localVarFetchArgs = EncountersApiFetchParamCreator(configuration).encounterMethodList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Methods by which the player might can encounter Pokémon in the wild, e.g., walking in tall grass. Check out Bulbapedia for greater detail.
         * @summary Get encounter method
         * @throws {RequiredError}
         */
        encounterMethodRetrieve(id: string, options?: RequestOptions = {}): Promise<EncounterMethodDetail> {
            const localVarFetchArgs = EncountersApiFetchParamCreator(configuration).encounterMethodRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * EvolutionApi - fetch parameter creator
 * @export
 */
export const EvolutionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pokémon they can evolve into up through the hierarchy.
         * @summary List evolution chains
         * @throws {RequiredError}
         */
        evolutionChainList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/evolution-chain/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pokémon they can evolve into up through the hierarchy.
         * @summary Get evolution chain
         * @throws {RequiredError}
         */
        evolutionChainRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling evolutionChainRetrieve.');
            }
            const localVarPath = `/api/v2/evolution-chain/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Evolution triggers are the events and conditions that cause a Pokémon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
         * @summary List evolution triggers
         * @throws {RequiredError}
         */
        evolutionTriggerList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/evolution-trigger/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Evolution triggers are the events and conditions that cause a Pokémon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
         * @summary Get evolution trigger
         * @throws {RequiredError}
         */
        evolutionTriggerRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling evolutionTriggerRetrieve.');
            }
            const localVarPath = `/api/v2/evolution-trigger/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type EvolutionApiType = { 
    evolutionChainList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedEvolutionChainSummaryList>,

    evolutionChainRetrieve(id: string, options?: RequestOptions): Promise<EvolutionChainDetail>,

    evolutionTriggerList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedEvolutionTriggerSummaryList>,

    evolutionTriggerRetrieve(id: string, options?: RequestOptions): Promise<EvolutionTriggerDetail>,
}

/**
 * EvolutionApi - factory function to inject configuration 
 * @export
 */
export const EvolutionApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): EvolutionApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pokémon they can evolve into up through the hierarchy.
         * @summary List evolution chains
         * @throws {RequiredError}
         */
        evolutionChainList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedEvolutionChainSummaryList> {
            const localVarFetchArgs = EvolutionApiFetchParamCreator(configuration).evolutionChainList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Evolution chains are essentially family trees. They start with the lowest stage within a family and detail evolution conditions for each as well as Pokémon they can evolve into up through the hierarchy.
         * @summary Get evolution chain
         * @throws {RequiredError}
         */
        evolutionChainRetrieve(id: string, options?: RequestOptions = {}): Promise<EvolutionChainDetail> {
            const localVarFetchArgs = EvolutionApiFetchParamCreator(configuration).evolutionChainRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Evolution triggers are the events and conditions that cause a Pokémon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
         * @summary List evolution triggers
         * @throws {RequiredError}
         */
        evolutionTriggerList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedEvolutionTriggerSummaryList> {
            const localVarFetchArgs = EvolutionApiFetchParamCreator(configuration).evolutionTriggerList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Evolution triggers are the events and conditions that cause a Pokémon to evolve. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Methods_of_evolution) for greater detail.
         * @summary Get evolution trigger
         * @throws {RequiredError}
         */
        evolutionTriggerRetrieve(id: string, options?: RequestOptions = {}): Promise<EvolutionTriggerDetail> {
            const localVarFetchArgs = EvolutionApiFetchParamCreator(configuration).evolutionTriggerRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * GamesApi - fetch parameter creator
 * @export
 */
export const GamesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * A generation is a grouping of the Pokémon games that separates them based on the Pokémon they include. In each generation, a new set of Pokémon, Moves, Abilities and Types that did not exist in the previous generation are released.
         * @summary List genrations
         * @throws {RequiredError}
         */
        generationList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/generation/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A generation is a grouping of the Pokémon games that separates them based on the Pokémon they include. In each generation, a new set of Pokémon, Moves, Abilities and Types that did not exist in the previous generation are released.
         * @summary Get genration
         * @throws {RequiredError}
         */
        generationRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling generationRetrieve.');
            }
            const localVarPath = `/api/v2/generation/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A Pokédex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pokémon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
         * @summary List pokedex
         * @throws {RequiredError}
         */
        pokedexList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pokedex/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A Pokédex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pokémon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
         * @summary Get pokedex
         * @throws {RequiredError}
         */
        pokedexRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pokedexRetrieve.');
            }
            const localVarPath = `/api/v2/pokedex/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Version groups categorize highly similar versions of the games.
         * @summary List version groups
         * @throws {RequiredError}
         */
        versionGroupList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/version-group/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Version groups categorize highly similar versions of the games.
         * @summary Get version group
         * @throws {RequiredError}
         */
        versionGroupRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling versionGroupRetrieve.');
            }
            const localVarPath = `/api/v2/version-group/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Versions of the games, e.g., Red, Blue or Yellow.
         * @summary List versions
         * @throws {RequiredError}
         */
        versionList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/version/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Versions of the games, e.g., Red, Blue or Yellow.
         * @summary Get version
         * @throws {RequiredError}
         */
        versionRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling versionRetrieve.');
            }
            const localVarPath = `/api/v2/version/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type GamesApiType = { 
    generationList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedGenerationSummaryList>,

    generationRetrieve(id: string, options?: RequestOptions): Promise<GenerationDetail>,

    pokedexList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPokedexSummaryList>,

    pokedexRetrieve(id: string, options?: RequestOptions): Promise<PokedexDetail>,

    versionGroupList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedVersionGroupSummaryList>,

    versionGroupRetrieve(id: string, options?: RequestOptions): Promise<VersionGroupDetail>,

    versionList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedVersionSummaryList>,

    versionRetrieve(id: string, options?: RequestOptions): Promise<VersionDetail>,
}

/**
 * GamesApi - factory function to inject configuration 
 * @export
 */
export const GamesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): GamesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * A generation is a grouping of the Pokémon games that separates them based on the Pokémon they include. In each generation, a new set of Pokémon, Moves, Abilities and Types that did not exist in the previous generation are released.
         * @summary List genrations
         * @throws {RequiredError}
         */
        generationList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedGenerationSummaryList> {
            const localVarFetchArgs = GamesApiFetchParamCreator(configuration).generationList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * A generation is a grouping of the Pokémon games that separates them based on the Pokémon they include. In each generation, a new set of Pokémon, Moves, Abilities and Types that did not exist in the previous generation are released.
         * @summary Get genration
         * @throws {RequiredError}
         */
        generationRetrieve(id: string, options?: RequestOptions = {}): Promise<GenerationDetail> {
            const localVarFetchArgs = GamesApiFetchParamCreator(configuration).generationRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * A Pokédex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pokémon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
         * @summary List pokedex
         * @throws {RequiredError}
         */
        pokedexList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPokedexSummaryList> {
            const localVarFetchArgs = GamesApiFetchParamCreator(configuration).pokedexList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * A Pokédex is a handheld electronic encyclopedia device; one which is capable of recording and retaining information of the various Pokémon in a given region with the exception of the national dex and some smaller dexes related to portions of a region. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pokedex) for greater detail.
         * @summary Get pokedex
         * @throws {RequiredError}
         */
        pokedexRetrieve(id: string, options?: RequestOptions = {}): Promise<PokedexDetail> {
            const localVarFetchArgs = GamesApiFetchParamCreator(configuration).pokedexRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Version groups categorize highly similar versions of the games.
         * @summary List version groups
         * @throws {RequiredError}
         */
        versionGroupList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedVersionGroupSummaryList> {
            const localVarFetchArgs = GamesApiFetchParamCreator(configuration).versionGroupList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Version groups categorize highly similar versions of the games.
         * @summary Get version group
         * @throws {RequiredError}
         */
        versionGroupRetrieve(id: string, options?: RequestOptions = {}): Promise<VersionGroupDetail> {
            const localVarFetchArgs = GamesApiFetchParamCreator(configuration).versionGroupRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Versions of the games, e.g., Red, Blue or Yellow.
         * @summary List versions
         * @throws {RequiredError}
         */
        versionList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedVersionSummaryList> {
            const localVarFetchArgs = GamesApiFetchParamCreator(configuration).versionList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Versions of the games, e.g., Red, Blue or Yellow.
         * @summary Get version
         * @throws {RequiredError}
         */
        versionRetrieve(id: string, options?: RequestOptions = {}): Promise<VersionDetail> {
            const localVarFetchArgs = GamesApiFetchParamCreator(configuration).versionRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * ItemsApi - fetch parameter creator
 * @export
 */
export const ItemsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Item attributes define particular aspects of items, e.g.\"usable in battle\" or \"consumable\".
         * @summary List item attributes
         * @throws {RequiredError}
         */
        itemAttributeList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/item-attribute/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Item attributes define particular aspects of items, e.g.\"usable in battle\" or \"consumable\".
         * @summary Get item attribute
         * @throws {RequiredError}
         */
        itemAttributeRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itemAttributeRetrieve.');
            }
            const localVarPath = `/api/v2/item-attribute/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Item categories determine where items will be placed in the players bag.
         * @summary List item categories
         * @throws {RequiredError}
         */
        itemCategoryList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/item-category/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Item categories determine where items will be placed in the players bag.
         * @summary Get item category
         * @throws {RequiredError}
         */
        itemCategoryRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itemCategoryRetrieve.');
            }
            const localVarPath = `/api/v2/item-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The various effects of the move\"Fling\" when used with different items.
         * @summary List item fling effects
         * @throws {RequiredError}
         */
        itemFlingEffectList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/item-fling-effect/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The various effects of the move\"Fling\" when used with different items.
         * @summary Get item fling effect
         * @throws {RequiredError}
         */
        itemFlingEffectRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itemFlingEffectRetrieve.');
            }
            const localVarPath = `/api/v2/item-fling-effect/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pokémon, or to access a new area.
         * @summary List items
         * @throws {RequiredError}
         */
        itemList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/item/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pockets within the players bag used for storing items by category.
         * @summary List item pockets
         * @throws {RequiredError}
         */
        itemPocketList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/item-pocket/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pockets within the players bag used for storing items by category.
         * @summary Get item pocket
         * @throws {RequiredError}
         */
        itemPocketRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itemPocketRetrieve.');
            }
            const localVarPath = `/api/v2/item-pocket/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pokémon, or to access a new area.
         * @summary Get item
         * @throws {RequiredError}
         */
        itemRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling itemRetrieve.');
            }
            const localVarPath = `/api/v2/item/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type ItemsApiType = { 
    itemAttributeList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedItemAttributeSummaryList>,

    itemAttributeRetrieve(id: string, options?: RequestOptions): Promise<ItemAttributeDetail>,

    itemCategoryList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedItemCategorySummaryList>,

    itemCategoryRetrieve(id: string, options?: RequestOptions): Promise<ItemCategoryDetail>,

    itemFlingEffectList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedItemFlingEffectSummaryList>,

    itemFlingEffectRetrieve(id: string, options?: RequestOptions): Promise<ItemFlingEffectDetail>,

    itemList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedItemSummaryList>,

    itemPocketList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedItemPocketSummaryList>,

    itemPocketRetrieve(id: string, options?: RequestOptions): Promise<ItemPocketDetail>,

    itemRetrieve(id: string, options?: RequestOptions): Promise<ItemDetail>,
}

/**
 * ItemsApi - factory function to inject configuration 
 * @export
 */
export const ItemsApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): ItemsApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Item attributes define particular aspects of items, e.g.\"usable in battle\" or \"consumable\".
         * @summary List item attributes
         * @throws {RequiredError}
         */
        itemAttributeList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedItemAttributeSummaryList> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemAttributeList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Item attributes define particular aspects of items, e.g.\"usable in battle\" or \"consumable\".
         * @summary Get item attribute
         * @throws {RequiredError}
         */
        itemAttributeRetrieve(id: string, options?: RequestOptions = {}): Promise<ItemAttributeDetail> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemAttributeRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Item categories determine where items will be placed in the players bag.
         * @summary List item categories
         * @throws {RequiredError}
         */
        itemCategoryList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedItemCategorySummaryList> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemCategoryList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Item categories determine where items will be placed in the players bag.
         * @summary Get item category
         * @throws {RequiredError}
         */
        itemCategoryRetrieve(id: string, options?: RequestOptions = {}): Promise<ItemCategoryDetail> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemCategoryRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * The various effects of the move\"Fling\" when used with different items.
         * @summary List item fling effects
         * @throws {RequiredError}
         */
        itemFlingEffectList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedItemFlingEffectSummaryList> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemFlingEffectList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * The various effects of the move\"Fling\" when used with different items.
         * @summary Get item fling effect
         * @throws {RequiredError}
         */
        itemFlingEffectRetrieve(id: string, options?: RequestOptions = {}): Promise<ItemFlingEffectDetail> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemFlingEffectRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pokémon, or to access a new area.
         * @summary List items
         * @throws {RequiredError}
         */
        itemList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedItemSummaryList> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Pockets within the players bag used for storing items by category.
         * @summary List item pockets
         * @throws {RequiredError}
         */
        itemPocketList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedItemPocketSummaryList> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemPocketList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Pockets within the players bag used for storing items by category.
         * @summary Get item pocket
         * @throws {RequiredError}
         */
        itemPocketRetrieve(id: string, options?: RequestOptions = {}): Promise<ItemPocketDetail> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemPocketRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * An item is an object in the games which the player can pick up, keep in their bag, and use in some manner. They have various uses, including healing, powering up, helping catch Pokémon, or to access a new area.
         * @summary Get item
         * @throws {RequiredError}
         */
        itemRetrieve(id: string, options?: RequestOptions = {}): Promise<ItemDetail> {
            const localVarFetchArgs = ItemsApiFetchParamCreator(configuration).itemRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * LocationApi - fetch parameter creator
 * @export
 */
export const LocationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pokémon encounters.
         * @summary List location areas
         * @throws {RequiredError}
         */
        locationAreaList(limit?: number, offset?: number, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/location-area/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pokémon encounters.
         * @summary Get location area
         * @throws {RequiredError}
         */
        locationAreaRetrieve(id: number, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling locationAreaRetrieve.');
            }
            const localVarPath = `/api/v2/location-area/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
         * @summary List locations
         * @throws {RequiredError}
         */
        locationList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/location/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
         * @summary Get location
         * @throws {RequiredError}
         */
        locationRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling locationRetrieve.');
            }
            const localVarPath = `/api/v2/location/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Areas used for grouping Pokémon encounters in Pal Park. They\'re like habitats that are specific to Pal Park.
         * @summary List pal park areas
         * @throws {RequiredError}
         */
        palParkAreaList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pal-park-area/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Areas used for grouping Pokémon encounters in Pal Park. They\'re like habitats that are specific to Pal Park.
         * @summary Get pal park area
         * @throws {RequiredError}
         */
        palParkAreaRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling palParkAreaRetrieve.');
            }
            const localVarPath = `/api/v2/pal-park-area/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A region is an organized area of the Pokémon world. Most often, the main difference between regions is the species of Pokémon that can be encountered within them.
         * @summary List regions
         * @throws {RequiredError}
         */
        regionList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/region/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A region is an organized area of the Pokémon world. Most often, the main difference between regions is the species of Pokémon that can be encountered within them.
         * @summary Get region
         * @throws {RequiredError}
         */
        regionRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling regionRetrieve.');
            }
            const localVarPath = `/api/v2/region/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type LocationApiType = { 
    locationAreaList(limit?: number, offset?: number, options?: RequestOptions): Promise<PaginatedLocationAreaSummaryList>,

    locationAreaRetrieve(id: number, options?: RequestOptions): Promise<LocationAreaDetail>,

    locationList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedLocationSummaryList>,

    locationRetrieve(id: string, options?: RequestOptions): Promise<LocationDetail>,

    palParkAreaList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPalParkAreaSummaryList>,

    palParkAreaRetrieve(id: string, options?: RequestOptions): Promise<PalParkAreaDetail>,

    regionList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedRegionSummaryList>,

    regionRetrieve(id: string, options?: RequestOptions): Promise<RegionDetail>,
}

/**
 * LocationApi - factory function to inject configuration 
 * @export
 */
export const LocationApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): LocationApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pokémon encounters.
         * @summary List location areas
         * @throws {RequiredError}
         */
        locationAreaList(limit?: number, offset?: number, options?: RequestOptions = {}): Promise<PaginatedLocationAreaSummaryList> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).locationAreaList(limit, offset, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Location areas are sections of areas, such as floors in a building or cave. Each area has its own set of possible Pokémon encounters.
         * @summary Get location area
         * @throws {RequiredError}
         */
        locationAreaRetrieve(id: number, options?: RequestOptions = {}): Promise<LocationAreaDetail> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).locationAreaRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
         * @summary List locations
         * @throws {RequiredError}
         */
        locationList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedLocationSummaryList> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).locationList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Locations that can be visited within the games. Locations make up sizable portions of regions, like cities or routes.
         * @summary Get location
         * @throws {RequiredError}
         */
        locationRetrieve(id: string, options?: RequestOptions = {}): Promise<LocationDetail> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).locationRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Areas used for grouping Pokémon encounters in Pal Park. They\'re like habitats that are specific to Pal Park.
         * @summary List pal park areas
         * @throws {RequiredError}
         */
        palParkAreaList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPalParkAreaSummaryList> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).palParkAreaList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Areas used for grouping Pokémon encounters in Pal Park. They\'re like habitats that are specific to Pal Park.
         * @summary Get pal park area
         * @throws {RequiredError}
         */
        palParkAreaRetrieve(id: string, options?: RequestOptions = {}): Promise<PalParkAreaDetail> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).palParkAreaRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * A region is an organized area of the Pokémon world. Most often, the main difference between regions is the species of Pokémon that can be encountered within them.
         * @summary List regions
         * @throws {RequiredError}
         */
        regionList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedRegionSummaryList> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).regionList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * A region is an organized area of the Pokémon world. Most often, the main difference between regions is the species of Pokémon that can be encountered within them.
         * @summary Get region
         * @throws {RequiredError}
         */
        regionRetrieve(id: string, options?: RequestOptions = {}): Promise<RegionDetail> {
            const localVarFetchArgs = LocationApiFetchParamCreator(configuration).regionRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MachinesApi - fetch parameter creator
 * @export
 */
export const MachinesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Machines are the representation of items that teach moves to Pokémon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
         * @summary List machines
         * @throws {RequiredError}
         */
        machineList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/machine/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Machines are the representation of items that teach moves to Pokémon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
         * @summary Get machine
         * @throws {RequiredError}
         */
        machineRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling machineRetrieve.');
            }
            const localVarPath = `/api/v2/machine/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MachinesApiType = { 
    machineList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedMachineSummaryList>,

    machineRetrieve(id: string, options?: RequestOptions): Promise<MachineDetail>,
}

/**
 * MachinesApi - factory function to inject configuration 
 * @export
 */
export const MachinesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MachinesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Machines are the representation of items that teach moves to Pokémon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
         * @summary List machines
         * @throws {RequiredError}
         */
        machineList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedMachineSummaryList> {
            const localVarFetchArgs = MachinesApiFetchParamCreator(configuration).machineList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Machines are the representation of items that teach moves to Pokémon. They vary from version to version, so it is not certain that one specific TM or HM corresponds to a single Machine.
         * @summary Get machine
         * @throws {RequiredError}
         */
        machineRetrieve(id: string, options?: RequestOptions = {}): Promise<MachineDetail> {
            const localVarFetchArgs = MachinesApiFetchParamCreator(configuration).machineRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * MovesApi - fetch parameter creator
 * @export
 */
export const MovesApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
         * @summary List move meta ailments
         * @throws {RequiredError}
         */
        moveAilmentList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/move-ailment/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
         * @summary Get move meta ailment
         * @throws {RequiredError}
         */
        moveAilmentRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveAilmentRetrieve.');
            }
            const localVarPath = `/api/v2/move-ailment/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
         * @summary List move battle styles
         * @throws {RequiredError}
         */
        moveBattleStyleList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/move-battle-style/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
         * @summary Get move battle style
         * @throws {RequiredError}
         */
        moveBattleStyleRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveBattleStyleRetrieve.');
            }
            const localVarPath = `/api/v2/move-battle-style/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Very general categories that loosely group move effects.
         * @summary List move meta categories
         * @throws {RequiredError}
         */
        moveCategoryList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/move-category/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Very general categories that loosely group move effects.
         * @summary Get move meta category
         * @throws {RequiredError}
         */
        moveCategoryRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveCategoryRetrieve.');
            }
            const localVarPath = `/api/v2/move-category/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Methods by which Pokémon can learn moves.
         * @summary List move learn methods
         * @throws {RequiredError}
         */
        moveLearnMethodList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/move-learn-method/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Methods by which Pokémon can learn moves.
         * @summary Get move learn method
         * @throws {RequiredError}
         */
        moveLearnMethodRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveLearnMethodRetrieve.');
            }
            const localVarPath = `/api/v2/move-learn-method/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
         * @summary List moves
         * @throws {RequiredError}
         */
        moveList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/move/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
         * @summary Get move
         * @throws {RequiredError}
         */
        moveRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveRetrieve.');
            }
            const localVarPath = `/api/v2/move/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
         * @summary List move targets
         * @throws {RequiredError}
         */
        moveTargetList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/move-target/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
         * @summary Get move target
         * @throws {RequiredError}
         */
        moveTargetRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveTargetRetrieve.');
            }
            const localVarPath = `/api/v2/move-target/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type MovesApiType = { 
    moveAilmentList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedMoveMetaAilmentSummaryList>,

    moveAilmentRetrieve(id: string, options?: RequestOptions): Promise<MoveMetaAilmentDetail>,

    moveBattleStyleList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedMoveBattleStyleSummaryList>,

    moveBattleStyleRetrieve(id: string, options?: RequestOptions): Promise<MoveBattleStyleDetail>,

    moveCategoryList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedMoveMetaCategorySummaryList>,

    moveCategoryRetrieve(id: string, options?: RequestOptions): Promise<MoveMetaCategoryDetail>,

    moveLearnMethodList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedMoveLearnMethodSummaryList>,

    moveLearnMethodRetrieve(id: string, options?: RequestOptions): Promise<MoveLearnMethodDetail>,

    moveList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedMoveSummaryList>,

    moveRetrieve(id: string, options?: RequestOptions): Promise<MoveDetail>,

    moveTargetList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedMoveTargetSummaryList>,

    moveTargetRetrieve(id: string, options?: RequestOptions): Promise<MoveTargetDetail>,
}

/**
 * MovesApi - factory function to inject configuration 
 * @export
 */
export const MovesApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): MovesApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
         * @summary List move meta ailments
         * @throws {RequiredError}
         */
        moveAilmentList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedMoveMetaAilmentSummaryList> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveAilmentList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Move Ailments are status conditions caused by moves used during battle. See [Bulbapedia](https://bulbapedia.bulbagarden.net/wiki/Status_condition) for greater detail.
         * @summary Get move meta ailment
         * @throws {RequiredError}
         */
        moveAilmentRetrieve(id: string, options?: RequestOptions = {}): Promise<MoveMetaAilmentDetail> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveAilmentRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
         * @summary List move battle styles
         * @throws {RequiredError}
         */
        moveBattleStyleList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedMoveBattleStyleSummaryList> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveBattleStyleList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Styles of moves when used in the Battle Palace. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Battle_Frontier_(Generation_III)) for greater detail.
         * @summary Get move battle style
         * @throws {RequiredError}
         */
        moveBattleStyleRetrieve(id: string, options?: RequestOptions = {}): Promise<MoveBattleStyleDetail> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveBattleStyleRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Very general categories that loosely group move effects.
         * @summary List move meta categories
         * @throws {RequiredError}
         */
        moveCategoryList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedMoveMetaCategorySummaryList> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveCategoryList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Very general categories that loosely group move effects.
         * @summary Get move meta category
         * @throws {RequiredError}
         */
        moveCategoryRetrieve(id: string, options?: RequestOptions = {}): Promise<MoveMetaCategoryDetail> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveCategoryRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Methods by which Pokémon can learn moves.
         * @summary List move learn methods
         * @throws {RequiredError}
         */
        moveLearnMethodList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedMoveLearnMethodSummaryList> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveLearnMethodList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Methods by which Pokémon can learn moves.
         * @summary Get move learn method
         * @throws {RequiredError}
         */
        moveLearnMethodRetrieve(id: string, options?: RequestOptions = {}): Promise<MoveLearnMethodDetail> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveLearnMethodRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
         * @summary List moves
         * @throws {RequiredError}
         */
        moveList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedMoveSummaryList> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Moves are the skills of Pokémon in battle. In battle, a Pokémon uses one move each turn. Some moves (including those learned by Hidden Machine) can be used outside of battle as well, usually for the purpose of removing obstacles or exploring new areas.
         * @summary Get move
         * @throws {RequiredError}
         */
        moveRetrieve(id: string, options?: RequestOptions = {}): Promise<MoveDetail> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
         * @summary List move targets
         * @throws {RequiredError}
         */
        moveTargetList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedMoveTargetSummaryList> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveTargetList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Targets moves can be directed at during battle. Targets can be Pokémon, environments or even other moves.
         * @summary Get move target
         * @throws {RequiredError}
         */
        moveTargetRetrieve(id: string, options?: RequestOptions = {}): Promise<MoveTargetDetail> {
            const localVarFetchArgs = MovesApiFetchParamCreator(configuration).moveTargetRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * PokemonApi - fetch parameter creator
 * @export
 */
export const PokemonApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
         * @throws {RequiredError}
         */
        abilityList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/ability/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
         * @throws {RequiredError}
         */
        abilityRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling abilityRetrieve.');
            }
            const localVarPath = `/api/v2/ability/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
         * @summary List charecterictics
         * @throws {RequiredError}
         */
        characteristicList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/characteristic/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
         * @summary Get characteristic
         * @throws {RequiredError}
         */
        characteristicRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling characteristicRetrieve.');
            }
            const localVarPath = `/api/v2/characteristic/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
         * @summary List egg groups
         * @throws {RequiredError}
         */
        eggGroupList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/egg-group/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
         * @summary Get egg group
         * @throws {RequiredError}
         */
        eggGroupRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling eggGroupRetrieve.');
            }
            const localVarPath = `/api/v2/egg-group/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
         * @summary List genders
         * @throws {RequiredError}
         */
        genderList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/gender/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
         * @summary Get gender
         * @throws {RequiredError}
         */
        genderRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling genderRetrieve.');
            }
            const localVarPath = `/api/v2/gender/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
         * @summary List growth rates
         * @throws {RequiredError}
         */
        growthRateList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/growth-rate/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
         * @summary Get growth rate
         * @throws {RequiredError}
         */
        growthRateRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling growthRateRetrieve.');
            }
            const localVarPath = `/api/v2/growth-rate/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Damage classes moves can have, e.g. physical, special, or non-damaging.
         * @summary List move damage classes
         * @throws {RequiredError}
         */
        moveDamageClassList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/move-damage-class/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Damage classes moves can have, e.g. physical, special, or non-damaging.
         * @summary Get move damage class
         * @throws {RequiredError}
         */
        moveDamageClassRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling moveDamageClassRetrieve.');
            }
            const localVarPath = `/api/v2/move-damage-class/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
         * @summary List natures
         * @throws {RequiredError}
         */
        natureList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/nature/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
         * @summary Get nature
         * @throws {RequiredError}
         */
        natureRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling natureRetrieve.');
            }
            const localVarPath = `/api/v2/nature/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
         * @summary List pokeathlon stats
         * @throws {RequiredError}
         */
        pokeathlonStatList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pokeathlon-stat/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
         * @summary Get pokeathlon stat
         * @throws {RequiredError}
         */
        pokeathlonStatRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pokeathlonStatRetrieve.');
            }
            const localVarPath = `/api/v2/pokeathlon-stat/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
         * @summary List pokemon colors
         * @throws {RequiredError}
         */
        pokemonColorList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pokemon-color/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
         * @summary Get pokemon color
         * @throws {RequiredError}
         */
        pokemonColorRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pokemonColorRetrieve.');
            }
            const localVarPath = `/api/v2/pokemon-color/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
         * @summary List pokemon forms
         * @throws {RequiredError}
         */
        pokemonFormList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pokemon-form/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
         * @summary Get pokemon form
         * @throws {RequiredError}
         */
        pokemonFormRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pokemonFormRetrieve.');
            }
            const localVarPath = `/api/v2/pokemon-form/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
         * @summary List pokemom habitas
         * @throws {RequiredError}
         */
        pokemonHabitatList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pokemon-habitat/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
         * @summary Get pokemom habita
         * @throws {RequiredError}
         */
        pokemonHabitatRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pokemonHabitatRetrieve.');
            }
            const localVarPath = `/api/v2/pokemon-habitat/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
         * @summary List pokemon
         * @throws {RequiredError}
         */
        pokemonList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pokemon/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
         * @summary Get pokemon
         * @throws {RequiredError}
         */
        pokemonRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pokemonRetrieve.');
            }
            const localVarPath = `/api/v2/pokemon/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shapes used for sorting Pokémon in a Pokédex.
         * @summary List pokemon shapes
         * @throws {RequiredError}
         */
        pokemonShapeList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pokemon-shape/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Shapes used for sorting Pokémon in a Pokédex.
         * @summary Get pokemon shape
         * @throws {RequiredError}
         */
        pokemonShapeRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pokemonShapeRetrieve.');
            }
            const localVarPath = `/api/v2/pokemon-shape/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
         * @summary List pokemon species
         * @throws {RequiredError}
         */
        pokemonSpeciesList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/pokemon-species/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
         * @summary Get pokemon species
         * @throws {RequiredError}
         */
        pokemonSpeciesRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling pokemonSpeciesRetrieve.');
            }
            const localVarPath = `/api/v2/pokemon-species/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
         * @summary List stats
         * @throws {RequiredError}
         */
        statList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/stat/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
         * @summary Get stat
         * @throws {RequiredError}
         */
        statRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling statRetrieve.');
            }
            const localVarPath = `/api/v2/stat/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
         * @summary List types
         * @throws {RequiredError}
         */
        typeList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/type/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
         * @summary Get types
         * @throws {RequiredError}
         */
        typeRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling typeRetrieve.');
            }
            const localVarPath = `/api/v2/type/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type PokemonApiType = { 
    abilityList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedAbilitySummaryList>,

    abilityRetrieve(id: string, options?: RequestOptions): Promise<AbilityDetail>,

    characteristicList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedCharacteristicSummaryList>,

    characteristicRetrieve(id: string, options?: RequestOptions): Promise<CharacteristicDetail>,

    eggGroupList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedEggGroupSummaryList>,

    eggGroupRetrieve(id: string, options?: RequestOptions): Promise<EggGroupDetail>,

    genderList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedGenderSummaryList>,

    genderRetrieve(id: string, options?: RequestOptions): Promise<GenderDetail>,

    growthRateList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedGrowthRateSummaryList>,

    growthRateRetrieve(id: string, options?: RequestOptions): Promise<GrowthRateDetail>,

    moveDamageClassList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedMoveDamageClassSummaryList>,

    moveDamageClassRetrieve(id: string, options?: RequestOptions): Promise<MoveDamageClassDetail>,

    natureList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedNatureSummaryList>,

    natureRetrieve(id: string, options?: RequestOptions): Promise<NatureDetail>,

    pokeathlonStatList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPokeathlonStatSummaryList>,

    pokeathlonStatRetrieve(id: string, options?: RequestOptions): Promise<PokeathlonStatDetail>,

    pokemonColorList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPokemonColorSummaryList>,

    pokemonColorRetrieve(id: string, options?: RequestOptions): Promise<PokemonColorDetail>,

    pokemonFormList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPokemonFormSummaryList>,

    pokemonFormRetrieve(id: string, options?: RequestOptions): Promise<PokemonFormDetail>,

    pokemonHabitatList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPokemonHabitatSummaryList>,

    pokemonHabitatRetrieve(id: string, options?: RequestOptions): Promise<PokemonHabitatDetail>,

    pokemonList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPokemonSummaryList>,

    pokemonRetrieve(id: string, options?: RequestOptions): Promise<PokemonDetail>,

    pokemonShapeList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPokemonShapeSummaryList>,

    pokemonShapeRetrieve(id: string, options?: RequestOptions): Promise<PokemonShapeDetail>,

    pokemonSpeciesList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedPokemonSpeciesSummaryList>,

    pokemonSpeciesRetrieve(id: string, options?: RequestOptions): Promise<PokemonSpeciesDetail>,

    statList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedStatSummaryList>,

    statRetrieve(id: string, options?: RequestOptions): Promise<StatDetail>,

    typeList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedTypeSummaryList>,

    typeRetrieve(id: string, options?: RequestOptions): Promise<TypeDetail>,
}

/**
 * PokemonApi - factory function to inject configuration 
 * @export
 */
export const PokemonApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): PokemonApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
         * @throws {RequiredError}
         */
        abilityList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedAbilitySummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).abilityList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Abilities provide passive effects for Pokémon in battle or in the overworld. Pokémon have multiple possible abilities but can have only one ability at a time. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Ability) for greater detail.
         * @throws {RequiredError}
         */
        abilityRetrieve(id: string, options?: RequestOptions = {}): Promise<AbilityDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).abilityRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
         * @summary List charecterictics
         * @throws {RequiredError}
         */
        characteristicList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedCharacteristicSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).characteristicList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Characteristics indicate which stat contains a Pokémon\'s highest IV. A Pokémon\'s Characteristic is determined by the remainder of its highest IV divided by 5 (gene_modulo). Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Characteristic) for greater detail.
         * @summary Get characteristic
         * @throws {RequiredError}
         */
        characteristicRetrieve(id: string, options?: RequestOptions = {}): Promise<CharacteristicDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).characteristicRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
         * @summary List egg groups
         * @throws {RequiredError}
         */
        eggGroupList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedEggGroupSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).eggGroupList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Egg Groups are categories which determine which Pokémon are able to interbreed. Pokémon may belong to either one or two Egg Groups. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Egg_Group) for greater detail.
         * @summary Get egg group
         * @throws {RequiredError}
         */
        eggGroupRetrieve(id: string, options?: RequestOptions = {}): Promise<EggGroupDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).eggGroupRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
         * @summary List genders
         * @throws {RequiredError}
         */
        genderList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedGenderSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).genderList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Genders were introduced in Generation II for the purposes of breeding Pokémon but can also result in visual differences or even different evolutionary lines. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Gender) for greater detail.
         * @summary Get gender
         * @throws {RequiredError}
         */
        genderRetrieve(id: string, options?: RequestOptions = {}): Promise<GenderDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).genderRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
         * @summary List growth rates
         * @throws {RequiredError}
         */
        growthRateList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedGrowthRateSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).growthRateList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Growth rates are the speed with which Pokémon gain levels through experience. Check out [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Experience) for greater detail.
         * @summary Get growth rate
         * @throws {RequiredError}
         */
        growthRateRetrieve(id: string, options?: RequestOptions = {}): Promise<GrowthRateDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).growthRateRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Damage classes moves can have, e.g. physical, special, or non-damaging.
         * @summary List move damage classes
         * @throws {RequiredError}
         */
        moveDamageClassList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedMoveDamageClassSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).moveDamageClassList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Damage classes moves can have, e.g. physical, special, or non-damaging.
         * @summary Get move damage class
         * @throws {RequiredError}
         */
        moveDamageClassRetrieve(id: string, options?: RequestOptions = {}): Promise<MoveDamageClassDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).moveDamageClassRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
         * @summary List natures
         * @throws {RequiredError}
         */
        natureList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedNatureSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).natureList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Natures influence how a Pokémon\'s stats grow. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Nature) for greater detail.
         * @summary Get nature
         * @throws {RequiredError}
         */
        natureRetrieve(id: string, options?: RequestOptions = {}): Promise<NatureDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).natureRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
         * @summary List pokeathlon stats
         * @throws {RequiredError}
         */
        pokeathlonStatList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPokeathlonStatSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokeathlonStatList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Pokeathlon Stats are different attributes of a Pokémon\'s performance in Pokéathlons. In Pokéathlons, competitions happen on different courses; one for each of the different Pokéathlon stats. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9athlon) for greater detail.
         * @summary Get pokeathlon stat
         * @throws {RequiredError}
         */
        pokeathlonStatRetrieve(id: string, options?: RequestOptions = {}): Promise<PokeathlonStatDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokeathlonStatRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
         * @summary List pokemon colors
         * @throws {RequiredError}
         */
        pokemonColorList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPokemonColorSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonColorList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Colors used for sorting Pokémon in a Pokédex. The color listed in the Pokédex is usually the color most apparent or covering each Pokémon\'s body. No orange category exists; Pokémon that are primarily orange are listed as red or brown.
         * @summary Get pokemon color
         * @throws {RequiredError}
         */
        pokemonColorRetrieve(id: string, options?: RequestOptions = {}): Promise<PokemonColorDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonColorRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
         * @summary List pokemon forms
         * @throws {RequiredError}
         */
        pokemonFormList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPokemonFormSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonFormList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Some Pokémon may appear in one of multiple, visually different forms. These differences are purely cosmetic. For variations within a Pokémon species, which do differ in more than just visuals, the \'Pokémon\' entity is used to represent such a variety.
         * @summary Get pokemon form
         * @throws {RequiredError}
         */
        pokemonFormRetrieve(id: string, options?: RequestOptions = {}): Promise<PokemonFormDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonFormRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
         * @summary List pokemom habitas
         * @throws {RequiredError}
         */
        pokemonHabitatList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPokemonHabitatSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonHabitatList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Habitats are generally different terrain Pokémon can be found in but can also be areas designated for rare or legendary Pokémon.
         * @summary Get pokemom habita
         * @throws {RequiredError}
         */
        pokemonHabitatRetrieve(id: string, options?: RequestOptions = {}): Promise<PokemonHabitatDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonHabitatRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
         * @summary List pokemon
         * @throws {RequiredError}
         */
        pokemonList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPokemonSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Pokémon are the creatures that inhabit the world of the Pokémon games. They can be caught using Pokéballs and trained by battling with other Pokémon. Each Pokémon belongs to a specific species but may take on a variant which makes it differ from other Pokémon of the same species, such as base stats, available abilities and typings. See [Bulbapedia](http://bulbapedia.bulbagarden.net/wiki/Pok%C3%A9mon_(species)) for greater detail.
         * @summary Get pokemon
         * @throws {RequiredError}
         */
        pokemonRetrieve(id: string, options?: RequestOptions = {}): Promise<PokemonDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Shapes used for sorting Pokémon in a Pokédex.
         * @summary List pokemon shapes
         * @throws {RequiredError}
         */
        pokemonShapeList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPokemonShapeSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonShapeList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Shapes used for sorting Pokémon in a Pokédex.
         * @summary Get pokemon shape
         * @throws {RequiredError}
         */
        pokemonShapeRetrieve(id: string, options?: RequestOptions = {}): Promise<PokemonShapeDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonShapeRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
         * @summary List pokemon species
         * @throws {RequiredError}
         */
        pokemonSpeciesList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedPokemonSpeciesSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonSpeciesList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * A Pokémon Species forms the basis for at least one Pokémon. Attributes of a Pokémon species are shared across all varieties of Pokémon within the species. A good example is Wormadam; Wormadam is the species which can be found in three different varieties, Wormadam-Trash, Wormadam-Sandy and Wormadam-Plant.
         * @summary Get pokemon species
         * @throws {RequiredError}
         */
        pokemonSpeciesRetrieve(id: string, options?: RequestOptions = {}): Promise<PokemonSpeciesDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).pokemonSpeciesRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
         * @summary List stats
         * @throws {RequiredError}
         */
        statList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedStatSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).statList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Stats determine certain aspects of battles. Each Pokémon has a value for each stat which grows as they gain levels and can be altered momentarily by effects in battles.
         * @summary Get stat
         * @throws {RequiredError}
         */
        statRetrieve(id: string, options?: RequestOptions = {}): Promise<StatDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).statRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
         * @summary List types
         * @throws {RequiredError}
         */
        typeList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedTypeSummaryList> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).typeList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Types are properties for Pokémon and their moves. Each type has three properties: which types of Pokémon it is super effective against, which types of Pokémon it is not very effective against, and which types of Pokémon it is completely ineffective against.
         * @summary Get types
         * @throws {RequiredError}
         */
        typeRetrieve(id: string, options?: RequestOptions = {}): Promise<TypeDetail> {
            const localVarFetchArgs = PokemonApiFetchParamCreator(configuration).typeRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


/**
 * UtilityApi - fetch parameter creator
 * @export
 */
export const UtilityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Languages for translations of API resource information.
         * @summary List languages
         * @throws {RequiredError}
         */
        languageList(limit?: number, offset?: number, q?: string, options: RequestOptions): FetchArgs {
            const localVarPath = `/api/v2/language/`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = ((limit:any):string);
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = ((offset:any):string);
            }

            if (q !== undefined) {
                localVarQueryParameter['q'] = ((q:any):string);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Languages for translations of API resource information.
         * @summary Get language
         * @throws {RequiredError}
         */
        languageRetrieve(id: string, options: RequestOptions): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling languageRetrieve.');
            }
            const localVarPath = `/api/v2/language/{id}/`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions: RequestOptions = Object.assign({}, { method: 'GET' }, options);
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};

            // authentication basicAuth required
            // http basic authentication required
            if (configuration && (configuration.username || configuration.password)) {
                localVarHeaderParameter["Authorization"] = "Basic " + btoa(configuration.username + ":" + configuration.password);
            }

            // authentication cookieAuth required

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            localVarUrlObj.search = null;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

export type UtilityApiType = { 
    languageList(limit?: number, offset?: number, q?: string, options?: RequestOptions): Promise<PaginatedLanguageSummaryList>,

    languageRetrieve(id: string, options?: RequestOptions): Promise<LanguageDetail>,
}

/**
 * UtilityApi - factory function to inject configuration 
 * @export
 */
export const UtilityApi = function(configuration?: Configuration, fetch: FetchAPI = portableFetch): UtilityApiType {
    const basePath: string = (configuration && configuration.basePath) || BASE_PATH;
    return {
        /**
         * Languages for translations of API resource information.
         * @summary List languages
         * @throws {RequiredError}
         */
        languageList(limit?: number, offset?: number, q?: string, options?: RequestOptions = {}): Promise<PaginatedLanguageSummaryList> {
            const localVarFetchArgs = UtilityApiFetchParamCreator(configuration).languageList(limit, offset, q, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
        /**
         * Languages for translations of API resource information.
         * @summary Get language
         * @throws {RequiredError}
         */
        languageRetrieve(id: string, options?: RequestOptions = {}): Promise<LanguageDetail> {
            const localVarFetchArgs = UtilityApiFetchParamCreator(configuration).languageRetrieve(id, options);
            return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                if (response.status >= 200 && response.status < 300) {
                    return response.json();
                } else {
                    throw response;
                }
            });
        },
    }
};


export type ApiTypes = { 
    BerriesApi: BerriesApiType,

    ContestsApi: ContestsApiType,

    EncountersApi: EncountersApiType,

    EvolutionApi: EvolutionApiType,

    GamesApi: GamesApiType,

    ItemsApi: ItemsApiType,

    LocationApi: LocationApiType,

    MachinesApi: MachinesApiType,

    MovesApi: MovesApiType,

    PokemonApi: PokemonApiType,

    UtilityApi: UtilityApiType,
 }
