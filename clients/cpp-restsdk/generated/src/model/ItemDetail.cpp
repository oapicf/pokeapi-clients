/**
 * PokéAPI
 * All the Pokémon data you'll ever need in one place, easily accessible through a modern free open-source RESTful API.  ## What is this?  This is a full RESTful API linked to an extensive database detailing everything about the Pokémon main game series.  We've covered everything from Pokémon to Berry Flavors.  ## Where do I start?  We have awesome [documentation](https://pokeapi.co/docs/v2) on how to use this API. It takes minutes to get started.  This API will always be publicly available and will never require any extensive setup process to consume.  Created by [**Paul Hallett**(]https://github.com/phalt) and other [**PokéAPI contributors***](https://github.com/PokeAPI/pokeapi#contributing) around the world. Pokémon and Pokémon character names are trademarks of Nintendo.     
 *
 * The version of the OpenAPI document: 2.7.0
 * Contact: blah+oapicf@cliffano.com
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.18.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */



#include "CppRestOpenAPIClient/model/ItemDetail.h"

namespace org {
namespace openapitools {
namespace client {
namespace model {

ItemDetail::ItemDetail()
{
    m_Id = 0;
    m_IdIsSet = false;
    m_Name = utility::conversions::to_string_t("");
    m_NameIsSet = false;
    m_Fling_effectIsSet = false;
    m_AttributesIsSet = false;
    m_CategoryIsSet = false;
    m_Effect_entriesIsSet = false;
    m_Flavor_text_entriesIsSet = false;
    m_Game_indicesIsSet = false;
    m_NamesIsSet = false;
    m_Held_by_pokemonIsSet = false;
    m_SpritesIsSet = false;
    m_Baby_trigger_forIsSet = false;
    m_MachinesIsSet = false;
}

ItemDetail::~ItemDetail()
{
}

void ItemDetail::validate()
{
    // TODO: implement validation
}

web::json::value ItemDetail::toJson() const
{
    web::json::value val = web::json::value::object();
    if(m_IdIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("id"))] = ModelBase::toJson(m_Id);
    }
    if(m_NameIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("name"))] = ModelBase::toJson(m_Name);
    }
    if(m_Cost.has_value())
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("cost"))] = ModelBase::toJson(m_Cost.get());
    }
    if(m_Fling_power.has_value())
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("fling_power"))] = ModelBase::toJson(m_Fling_power.get());
    }
    if(m_Fling_effectIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("fling_effect"))] = ModelBase::toJson(m_Fling_effect);
    }
    if(m_AttributesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("attributes"))] = ModelBase::toJson(m_Attributes);
    }
    if(m_CategoryIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("category"))] = ModelBase::toJson(m_Category);
    }
    if(m_Effect_entriesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("effect_entries"))] = ModelBase::toJson(m_Effect_entries);
    }
    if(m_Flavor_text_entriesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("flavor_text_entries"))] = ModelBase::toJson(m_Flavor_text_entries);
    }
    if(m_Game_indicesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("game_indices"))] = ModelBase::toJson(m_Game_indices);
    }
    if(m_NamesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("names"))] = ModelBase::toJson(m_Names);
    }
    if(m_Held_by_pokemonIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("held_by_pokemon"))] = ModelBase::toJson(m_Held_by_pokemon);
    }
    if(m_SpritesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("sprites"))] = ModelBase::toJson(m_Sprites);
    }
    if(m_Baby_trigger_forIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("baby_trigger_for"))] = ModelBase::toJson(m_Baby_trigger_for);
    }
    if(m_MachinesIsSet)
    {
        
        val[utility::conversions::to_string_t(_XPLATSTR("machines"))] = ModelBase::toJson(m_Machines);
    }

    return val;
}

bool ItemDetail::fromJson(const web::json::value& val)
{
    bool ok = true;
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("id"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("id")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setId;
            ok &= ModelBase::fromJson(fieldValue, refVal_setId);
            setId(refVal_setId);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("name"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("name")));
        if(!fieldValue.is_null())
        {
            utility::string_t refVal_setName;
            ok &= ModelBase::fromJson(fieldValue, refVal_setName);
            setName(refVal_setName);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("cost"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("cost")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setCost;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCost);
            setCost(refVal_setCost);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("fling_power"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("fling_power")));
        if(!fieldValue.is_null())
        {
            int32_t refVal_setFlingPower;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFlingPower);
            setFlingPower(refVal_setFlingPower);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("fling_effect"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("fling_effect")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ItemFlingEffectSummary> refVal_setFlingEffect;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFlingEffect);
            setFlingEffect(refVal_setFlingEffect);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("attributes"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("attributes")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<AbilityDetail_pokemon_inner_pokemon>> refVal_setAttributes;
            ok &= ModelBase::fromJson(fieldValue, refVal_setAttributes);
            setAttributes(refVal_setAttributes);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("category"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("category")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ItemCategorySummary> refVal_setCategory;
            ok &= ModelBase::fromJson(fieldValue, refVal_setCategory);
            setCategory(refVal_setCategory);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("effect_entries"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("effect_entries")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<ItemEffectText>> refVal_setEffectEntries;
            ok &= ModelBase::fromJson(fieldValue, refVal_setEffectEntries);
            setEffectEntries(refVal_setEffectEntries);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("flavor_text_entries"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("flavor_text_entries")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<ItemFlavorText>> refVal_setFlavorTextEntries;
            ok &= ModelBase::fromJson(fieldValue, refVal_setFlavorTextEntries);
            setFlavorTextEntries(refVal_setFlavorTextEntries);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("game_indices"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("game_indices")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<ItemGameIndex>> refVal_setGameIndices;
            ok &= ModelBase::fromJson(fieldValue, refVal_setGameIndices);
            setGameIndices(refVal_setGameIndices);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("names"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("names")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<ItemName>> refVal_setNames;
            ok &= ModelBase::fromJson(fieldValue, refVal_setNames);
            setNames(refVal_setNames);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("held_by_pokemon"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("held_by_pokemon")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<ItemDetail_held_by_pokemon_inner>> refVal_setHeldByPokemon;
            ok &= ModelBase::fromJson(fieldValue, refVal_setHeldByPokemon);
            setHeldByPokemon(refVal_setHeldByPokemon);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("sprites"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("sprites")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ItemDetail_sprites> refVal_setSprites;
            ok &= ModelBase::fromJson(fieldValue, refVal_setSprites);
            setSprites(refVal_setSprites);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("baby_trigger_for"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("baby_trigger_for")));
        if(!fieldValue.is_null())
        {
            std::shared_ptr<ItemDetail_baby_trigger_for> refVal_setBabyTriggerFor;
            ok &= ModelBase::fromJson(fieldValue, refVal_setBabyTriggerFor);
            setBabyTriggerFor(refVal_setBabyTriggerFor);
            
        }
    }
    if(val.has_field(utility::conversions::to_string_t(_XPLATSTR("machines"))))
    {
        const web::json::value& fieldValue = val.at(utility::conversions::to_string_t(_XPLATSTR("machines")));
        if(!fieldValue.is_null())
        {
            std::vector<std::shared_ptr<ItemDetail_machines_inner>> refVal_setMachines;
            ok &= ModelBase::fromJson(fieldValue, refVal_setMachines);
            setMachines(refVal_setMachines);
            
        }
    }
    return ok;
}

void ItemDetail::toMultipart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix) const
{
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }
    if(m_IdIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("id")), m_Id));
    }
    if(m_NameIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("name")), m_Name));
    }
    if(m_Cost.has_value())
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("cost")), m_Cost.get()));
    }
    if(m_Fling_power.has_value())
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("fling_power")), m_Fling_power.get()));
    }
    if(m_Fling_effectIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("fling_effect")), m_Fling_effect));
    }
    if(m_AttributesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("attributes")), m_Attributes));
    }
    if(m_CategoryIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("category")), m_Category));
    }
    if(m_Effect_entriesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("effect_entries")), m_Effect_entries));
    }
    if(m_Flavor_text_entriesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("flavor_text_entries")), m_Flavor_text_entries));
    }
    if(m_Game_indicesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("game_indices")), m_Game_indices));
    }
    if(m_NamesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("names")), m_Names));
    }
    if(m_Held_by_pokemonIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("held_by_pokemon")), m_Held_by_pokemon));
    }
    if(m_SpritesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("sprites")), m_Sprites));
    }
    if(m_Baby_trigger_forIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("baby_trigger_for")), m_Baby_trigger_for));
    }
    if(m_MachinesIsSet)
    {
        multipart->add(ModelBase::toHttpContent(namePrefix + utility::conversions::to_string_t(_XPLATSTR("machines")), m_Machines));
    }
}

bool ItemDetail::fromMultiPart(std::shared_ptr<MultipartFormData> multipart, const utility::string_t& prefix)
{
    bool ok = true;
    utility::string_t namePrefix = prefix;
    if(namePrefix.size() > 0 && namePrefix.substr(namePrefix.size() - 1) != utility::conversions::to_string_t(_XPLATSTR(".")))
    {
        namePrefix += utility::conversions::to_string_t(_XPLATSTR("."));
    }

    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("id"))))
    {
        int32_t refVal_setId;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("id"))), refVal_setId );
        setId(refVal_setId);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("name"))))
    {
        utility::string_t refVal_setName;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("name"))), refVal_setName );
        setName(refVal_setName);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("cost"))))
    {
        int32_t refVal_setCost;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("cost"))), refVal_setCost );
        setCost(refVal_setCost);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("fling_power"))))
    {
        int32_t refVal_setFlingPower;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("fling_power"))), refVal_setFlingPower );
        setFlingPower(refVal_setFlingPower);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("fling_effect"))))
    {
        std::shared_ptr<ItemFlingEffectSummary> refVal_setFlingEffect;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("fling_effect"))), refVal_setFlingEffect );
        setFlingEffect(refVal_setFlingEffect);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("attributes"))))
    {
        std::vector<std::shared_ptr<AbilityDetail_pokemon_inner_pokemon>> refVal_setAttributes;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("attributes"))), refVal_setAttributes );
        setAttributes(refVal_setAttributes);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("category"))))
    {
        std::shared_ptr<ItemCategorySummary> refVal_setCategory;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("category"))), refVal_setCategory );
        setCategory(refVal_setCategory);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("effect_entries"))))
    {
        std::vector<std::shared_ptr<ItemEffectText>> refVal_setEffectEntries;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("effect_entries"))), refVal_setEffectEntries );
        setEffectEntries(refVal_setEffectEntries);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("flavor_text_entries"))))
    {
        std::vector<std::shared_ptr<ItemFlavorText>> refVal_setFlavorTextEntries;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("flavor_text_entries"))), refVal_setFlavorTextEntries );
        setFlavorTextEntries(refVal_setFlavorTextEntries);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("game_indices"))))
    {
        std::vector<std::shared_ptr<ItemGameIndex>> refVal_setGameIndices;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("game_indices"))), refVal_setGameIndices );
        setGameIndices(refVal_setGameIndices);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("names"))))
    {
        std::vector<std::shared_ptr<ItemName>> refVal_setNames;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("names"))), refVal_setNames );
        setNames(refVal_setNames);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("held_by_pokemon"))))
    {
        std::vector<std::shared_ptr<ItemDetail_held_by_pokemon_inner>> refVal_setHeldByPokemon;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("held_by_pokemon"))), refVal_setHeldByPokemon );
        setHeldByPokemon(refVal_setHeldByPokemon);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("sprites"))))
    {
        std::shared_ptr<ItemDetail_sprites> refVal_setSprites;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("sprites"))), refVal_setSprites );
        setSprites(refVal_setSprites);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("baby_trigger_for"))))
    {
        std::shared_ptr<ItemDetail_baby_trigger_for> refVal_setBabyTriggerFor;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("baby_trigger_for"))), refVal_setBabyTriggerFor );
        setBabyTriggerFor(refVal_setBabyTriggerFor);
    }
    if(multipart->hasContent(utility::conversions::to_string_t(_XPLATSTR("machines"))))
    {
        std::vector<std::shared_ptr<ItemDetail_machines_inner>> refVal_setMachines;
        ok &= ModelBase::fromHttpContent(multipart->getContent(utility::conversions::to_string_t(_XPLATSTR("machines"))), refVal_setMachines );
        setMachines(refVal_setMachines);
    }
    return ok;
}


int32_t ItemDetail::getId() const
{
    return m_Id;
}

void ItemDetail::setId(int32_t value)
{
    m_Id = value;
    m_IdIsSet = true;
}

bool ItemDetail::idIsSet() const
{
    return m_IdIsSet;
}

void ItemDetail::unsetId()
{
    m_IdIsSet = false;
}
utility::string_t ItemDetail::getName() const
{
    return m_Name;
}


void ItemDetail::setName(const utility::string_t& value)
{
    m_Name = value;
    m_NameIsSet = true;
}

bool ItemDetail::nameIsSet() const
{
    return m_NameIsSet;
}

void ItemDetail::unsetName()
{
    m_NameIsSet = false;
}
int32_t ItemDetail::getCost() const
{
    return m_Cost.get();
}

void ItemDetail::setCost(int32_t value)
{
    m_Cost = value;
}

bool ItemDetail::costIsSet() const
{
    return m_Cost.has_value();
}

void ItemDetail::unsetCost()
{
    m_Cost.reset();
}
int32_t ItemDetail::getFlingPower() const
{
    return m_Fling_power.get();
}

void ItemDetail::setFlingPower(int32_t value)
{
    m_Fling_power = value;
}

bool ItemDetail::flingPowerIsSet() const
{
    return m_Fling_power.has_value();
}

void ItemDetail::unsetFling_power()
{
    m_Fling_power.reset();
}
std::shared_ptr<ItemFlingEffectSummary> ItemDetail::getFlingEffect() const
{
    return m_Fling_effect;
}


void ItemDetail::setFlingEffect(const std::shared_ptr<ItemFlingEffectSummary>& value)
{
    m_Fling_effect = value;
    m_Fling_effectIsSet = true;
}

bool ItemDetail::flingEffectIsSet() const
{
    return m_Fling_effectIsSet;
}

void ItemDetail::unsetFling_effect()
{
    m_Fling_effectIsSet = false;
}
std::vector<std::shared_ptr<AbilityDetail_pokemon_inner_pokemon>> ItemDetail::getAttributes() const
{
    return m_Attributes;
}


void ItemDetail::setAttributes(const std::vector<std::shared_ptr<AbilityDetail_pokemon_inner_pokemon>>& value)
{
    m_Attributes = value;
    m_AttributesIsSet = true;
}

bool ItemDetail::attributesIsSet() const
{
    return m_AttributesIsSet;
}

void ItemDetail::unsetAttributes()
{
    m_AttributesIsSet = false;
}
std::shared_ptr<ItemCategorySummary> ItemDetail::getCategory() const
{
    return m_Category;
}


void ItemDetail::setCategory(const std::shared_ptr<ItemCategorySummary>& value)
{
    m_Category = value;
    m_CategoryIsSet = true;
}

bool ItemDetail::categoryIsSet() const
{
    return m_CategoryIsSet;
}

void ItemDetail::unsetCategory()
{
    m_CategoryIsSet = false;
}
std::vector<std::shared_ptr<ItemEffectText>> ItemDetail::getEffectEntries() const
{
    return m_Effect_entries;
}


void ItemDetail::setEffectEntries(const std::vector<std::shared_ptr<ItemEffectText>>& value)
{
    m_Effect_entries = value;
    m_Effect_entriesIsSet = true;
}

bool ItemDetail::effectEntriesIsSet() const
{
    return m_Effect_entriesIsSet;
}

void ItemDetail::unsetEffect_entries()
{
    m_Effect_entriesIsSet = false;
}
std::vector<std::shared_ptr<ItemFlavorText>> ItemDetail::getFlavorTextEntries() const
{
    return m_Flavor_text_entries;
}


void ItemDetail::setFlavorTextEntries(const std::vector<std::shared_ptr<ItemFlavorText>>& value)
{
    m_Flavor_text_entries = value;
    m_Flavor_text_entriesIsSet = true;
}

bool ItemDetail::flavorTextEntriesIsSet() const
{
    return m_Flavor_text_entriesIsSet;
}

void ItemDetail::unsetFlavor_text_entries()
{
    m_Flavor_text_entriesIsSet = false;
}
std::vector<std::shared_ptr<ItemGameIndex>> ItemDetail::getGameIndices() const
{
    return m_Game_indices;
}


void ItemDetail::setGameIndices(const std::vector<std::shared_ptr<ItemGameIndex>>& value)
{
    m_Game_indices = value;
    m_Game_indicesIsSet = true;
}

bool ItemDetail::gameIndicesIsSet() const
{
    return m_Game_indicesIsSet;
}

void ItemDetail::unsetGame_indices()
{
    m_Game_indicesIsSet = false;
}
std::vector<std::shared_ptr<ItemName>> ItemDetail::getNames() const
{
    return m_Names;
}


void ItemDetail::setNames(const std::vector<std::shared_ptr<ItemName>>& value)
{
    m_Names = value;
    m_NamesIsSet = true;
}

bool ItemDetail::namesIsSet() const
{
    return m_NamesIsSet;
}

void ItemDetail::unsetNames()
{
    m_NamesIsSet = false;
}
std::vector<std::shared_ptr<ItemDetail_held_by_pokemon_inner>> ItemDetail::getHeldByPokemon() const
{
    return m_Held_by_pokemon;
}


void ItemDetail::setHeldByPokemon(const std::vector<std::shared_ptr<ItemDetail_held_by_pokemon_inner>>& value)
{
    m_Held_by_pokemon = value;
    m_Held_by_pokemonIsSet = true;
}

bool ItemDetail::heldByPokemonIsSet() const
{
    return m_Held_by_pokemonIsSet;
}

void ItemDetail::unsetHeld_by_pokemon()
{
    m_Held_by_pokemonIsSet = false;
}
std::shared_ptr<ItemDetail_sprites> ItemDetail::getSprites() const
{
    return m_Sprites;
}


void ItemDetail::setSprites(const std::shared_ptr<ItemDetail_sprites>& value)
{
    m_Sprites = value;
    m_SpritesIsSet = true;
}

bool ItemDetail::spritesIsSet() const
{
    return m_SpritesIsSet;
}

void ItemDetail::unsetSprites()
{
    m_SpritesIsSet = false;
}
std::shared_ptr<ItemDetail_baby_trigger_for> ItemDetail::getBabyTriggerFor() const
{
    return m_Baby_trigger_for;
}


void ItemDetail::setBabyTriggerFor(const std::shared_ptr<ItemDetail_baby_trigger_for>& value)
{
    m_Baby_trigger_for = value;
    m_Baby_trigger_forIsSet = true;
}

bool ItemDetail::babyTriggerForIsSet() const
{
    return m_Baby_trigger_forIsSet;
}

void ItemDetail::unsetBaby_trigger_for()
{
    m_Baby_trigger_forIsSet = false;
}
std::vector<std::shared_ptr<ItemDetail_machines_inner>> ItemDetail::getMachines() const
{
    return m_Machines;
}


void ItemDetail::setMachines(const std::vector<std::shared_ptr<ItemDetail_machines_inner>>& value)
{
    m_Machines = value;
    m_MachinesIsSet = true;
}

bool ItemDetail::machinesIsSet() const
{
    return m_MachinesIsSet;
}

void ItemDetail::unsetMachines()
{
    m_MachinesIsSet = false;
}

}
}
}
}


